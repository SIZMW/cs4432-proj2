package simpledb.planner;

import simpledb.tx.Transaction;
import simpledb.query.*;
import simpledb.parse.*;
import simpledb.server.SimpleDB;
import simpledb.materialize.SmartMergeJoinPlan;
import java.util.*;

/**
 * Always uses SmartMergeJoinPlan.
 * @author lwang5
 */
public class ExploitSortQueryPlanner implements QueryPlanner {

    private Transaction transaction;
    private List<TablePlan> tablePlans;
    /**
     * Creates a query plan as follows.  It first takes the SmartMergeJoin
     * of all fields. It then selects on the predicate;
     * and finally it projects on the field list. 
     */
    public Plan createPlan(QueryData data, Transaction tx) {
        transaction = tx;

        //Step 1: Create a plan for each mentioned table or view
        tablePlans = new ArrayList<TablePlan>();
        for (String tblname : data.tables()) {
            tablePlans.add(new TablePlan(tblname, tx));
        }

        // Choose the smallest size plan
        Plan currentPlan = getSmallestSelectPlan(data.pred());

        // Add plans to the join order
        while (!tablePlans.isEmpty()) {
            Plan temp = getSmallestMergeJoinPlan(currentPlan, data.pred());
            currentPlan = temp;
        }

        //Step 4: Project on the field names
        Plan projectPlan = new ProjectPlan(currentPlan, data.fields());
        return projectPlan;
    }

    private Plan getSmallestSelectPlan(Predicate pred) {
        TablePlan bestTablePlan = null;
        Plan bestPlan = null;
        for (TablePlan tp : tablePlans) {
            Plan temp = new SelectPlan(tp, pred);
            if (bestPlan == null || tp.recordsOutput() < bestPlan.recordsOutput()) {
                bestTablePlan = tp;
                bestPlan = temp;
            }
        }
        tablePlans.remove(bestTablePlan);
        return bestPlan;
    }

    private Plan getSmallestMergeJoinPlan(Plan currentPlan, Predicate pred) {
        TablePlan bestTablePlan = null;
        Plan bestPlan = null;
        for (TablePlan tp : tablePlans) {
            Plan temp = makeMergeJoinPlan(tp, currentPlan, pred);
            if (temp != null && (bestPlan == null || temp.recordsOutput() < bestPlan.recordsOutput())) {
                bestTablePlan = tp;
                bestPlan = temp;
            }
        }
        if (bestPlan != null) {
            tablePlans.remove(bestTablePlan);
        }
        return bestPlan;
    }

    private Plan makeMergeJoinPlan(Plan p1, Plan p2, Predicate pred) {
        for (String field1: p1.schema().fields()) {
            String field2 = pred.equatesWithField(field1);
            if (field2 != null && p1.schema().hasField(field2)) {
                Plan plan = new SmartMergeJoinPlan(p1, p2, field1, field2, transaction);

                Predicate joinPred = pred.joinPred(p1.schema(), p2.schema());
                if (joinPred != null) {
                    return new SelectPlan(plan, joinPred);
                } else {
                    return plan;
                }
            }
        }
        return null;
    }
}
