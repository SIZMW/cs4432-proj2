Only in ../cs4432-proj2/src/simpledb/: DataGenerator.java
Only in ../cs4432-proj2/src/simpledb/: MergeJoinDataGenerator.java
diff -r simpledb/SimpleDB_2.10/simpledb/buffer/BasicBufferMgr.java ../cs4432-proj2/src/simpledb/buffer/BasicBufferMgr.java
1,119c1,119
< package simpledb.buffer;
< 
< import simpledb.file.*;
< 
< /**
<  * Manages the pinning and unpinning of buffers to blocks.
<  * @author Edward Sciore
<  *
<  */
< class BasicBufferMgr {
<    private Buffer[] bufferpool;
<    private int numAvailable;
<    
<    /**
<     * Creates a buffer manager having the specified number 
<     * of buffer slots.
<     * This constructor depends on both the {@link FileMgr} and
<     * {@link simpledb.log.LogMgr LogMgr} objects 
<     * that it gets from the class
<     * {@link simpledb.server.SimpleDB}.
<     * Those objects are created during system initialization.
<     * Thus this constructor cannot be called until 
<     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
<     * is called first.
<     * @param numbuffs the number of buffer slots to allocate
<     */
<    BasicBufferMgr(int numbuffs) {
<       bufferpool = new Buffer[numbuffs];
<       numAvailable = numbuffs;
<       for (int i=0; i<numbuffs; i++)
<          bufferpool[i] = new Buffer();
<    }
<    
<    /**
<     * Flushes the dirty buffers modified by the specified transaction.
<     * @param txnum the transaction's id number
<     */
<    synchronized void flushAll(int txnum) {
<       for (Buffer buff : bufferpool)
<          if (buff.isModifiedBy(txnum))
<          buff.flush();
<    }
<    
<    /**
<     * Pins a buffer to the specified block. 
<     * If there is already a buffer assigned to that block
<     * then that buffer is used;  
<     * otherwise, an unpinned buffer from the pool is chosen.
<     * Returns a null value if there are no available buffers.
<     * @param blk a reference to a disk block
<     * @return the pinned buffer
<     */
<    synchronized Buffer pin(Block blk) {
<       Buffer buff = findExistingBuffer(blk);
<       if (buff == null) {
<          buff = chooseUnpinnedBuffer();
<          if (buff == null)
<             return null;
<          buff.assignToBlock(blk);
<       }
<       if (!buff.isPinned())
<          numAvailable--;
<       buff.pin();
<       return buff;
<    }
<    
<    /**
<     * Allocates a new block in the specified file, and
<     * pins a buffer to it. 
<     * Returns null (without allocating the block) if 
<     * there are no available buffers.
<     * @param filename the name of the file
<     * @param fmtr a pageformatter object, used to format the new block
<     * @return the pinned buffer
<     */
<    synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
<       Buffer buff = chooseUnpinnedBuffer();
<       if (buff == null)
<          return null;
<       buff.assignToNew(filename, fmtr);
<       numAvailable--;
<       buff.pin();
<       return buff;
<    }
<    
<    /**
<     * Unpins the specified buffer.
<     * @param buff the buffer to be unpinned
<     */
<    synchronized void unpin(Buffer buff) {
<       buff.unpin();
<       if (!buff.isPinned())
<          numAvailable++;
<    }
<    
<    /**
<     * Returns the number of available (i.e. unpinned) buffers.
<     * @return the number of available buffers
<     */
<    int available() {
<       return numAvailable;
<    }
<    
<    private Buffer findExistingBuffer(Block blk) {
<       for (Buffer buff : bufferpool) {
<          Block b = buff.block();
<          if (b != null && b.equals(blk))
<             return buff;
<       }
<       return null;
<    }
<    
<    private Buffer chooseUnpinnedBuffer() {
<       for (Buffer buff : bufferpool)
<          if (!buff.isPinned())
<          return buff;
<       return null;
<    }
< }
---
> package simpledb.buffer;
> 
> import simpledb.file.*;
> 
> /**
>  * Manages the pinning and unpinning of buffers to blocks.
>  * @author Edward Sciore
>  *
>  */
> class BasicBufferMgr {
>    private Buffer[] bufferpool;
>    private int numAvailable;
>    
>    /**
>     * Creates a buffer manager having the specified number 
>     * of buffer slots.
>     * This constructor depends on both the {@link FileMgr} and
>     * {@link simpledb.log.LogMgr LogMgr} objects 
>     * that it gets from the class
>     * {@link simpledb.server.SimpleDB}.
>     * Those objects are created during system initialization.
>     * Thus this constructor cannot be called until 
>     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
>     * is called first.
>     * @param numbuffs the number of buffer slots to allocate
>     */
>    BasicBufferMgr(int numbuffs) {
>       bufferpool = new Buffer[numbuffs];
>       numAvailable = numbuffs;
>       for (int i=0; i<numbuffs; i++)
>          bufferpool[i] = new Buffer();
>    }
>    
>    /**
>     * Flushes the dirty buffers modified by the specified transaction.
>     * @param txnum the transaction's id number
>     */
>    synchronized void flushAll(int txnum) {
>       for (Buffer buff : bufferpool)
>          if (buff.isModifiedBy(txnum))
>          buff.flush();
>    }
>    
>    /**
>     * Pins a buffer to the specified block. 
>     * If there is already a buffer assigned to that block
>     * then that buffer is used;  
>     * otherwise, an unpinned buffer from the pool is chosen.
>     * Returns a null value if there are no available buffers.
>     * @param blk a reference to a disk block
>     * @return the pinned buffer
>     */
>    synchronized Buffer pin(Block blk) {
>       Buffer buff = findExistingBuffer(blk);
>       if (buff == null) {
>          buff = chooseUnpinnedBuffer();
>          if (buff == null)
>             return null;
>          buff.assignToBlock(blk);
>       }
>       if (!buff.isPinned())
>          numAvailable--;
>       buff.pin();
>       return buff;
>    }
>    
>    /**
>     * Allocates a new block in the specified file, and
>     * pins a buffer to it. 
>     * Returns null (without allocating the block) if 
>     * there are no available buffers.
>     * @param filename the name of the file
>     * @param fmtr a pageformatter object, used to format the new block
>     * @return the pinned buffer
>     */
>    synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
>       Buffer buff = chooseUnpinnedBuffer();
>       if (buff == null)
>          return null;
>       buff.assignToNew(filename, fmtr);
>       numAvailable--;
>       buff.pin();
>       return buff;
>    }
>    
>    /**
>     * Unpins the specified buffer.
>     * @param buff the buffer to be unpinned
>     */
>    synchronized void unpin(Buffer buff) {
>       buff.unpin();
>       if (!buff.isPinned())
>          numAvailable++;
>    }
>    
>    /**
>     * Returns the number of available (i.e. unpinned) buffers.
>     * @return the number of available buffers
>     */
>    int available() {
>       return numAvailable;
>    }
>    
>    private Buffer findExistingBuffer(Block blk) {
>       for (Buffer buff : bufferpool) {
>          Block b = buff.block();
>          if (b != null && b.equals(blk))
>             return buff;
>       }
>       return null;
>    }
>    
>    private Buffer chooseUnpinnedBuffer() {
>       for (Buffer buff : bufferpool)
>          if (!buff.isPinned())
>          return buff;
>       return null;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/buffer/Buffer.java ../cs4432-proj2/src/simpledb/buffer/Buffer.java
1,189c1,189
< package simpledb.buffer;
< 
< import simpledb.server.SimpleDB;
< import simpledb.file.*;
< 
< /**
<  * An individual buffer.
<  * A buffer wraps a page and stores information about its status,
<  * such as the disk block associated with the page,
<  * the number of times the block has been pinned,
<  * whether the contents of the page have been modified,
<  * and if so, the id of the modifying transaction and
<  * the LSN of the corresponding log record.
<  * @author Edward Sciore
<  */
< public class Buffer {
<    private Page contents = new Page();
<    private Block blk = null;
<    private int pins = 0;
<    private int modifiedBy = -1;  // negative means not modified
<    private int logSequenceNumber = -1; // negative means no corresponding log record
< 
<    /**
<     * Creates a new buffer, wrapping a new 
<     * {@link simpledb.file.Page page}.  
<     * This constructor is called exclusively by the 
<     * class {@link BasicBufferMgr}.   
<     * It depends on  the 
<     * {@link simpledb.log.LogMgr LogMgr} object 
<     * that it gets from the class
<     * {@link simpledb.server.SimpleDB}.
<     * That object is created during system initialization.
<     * Thus this constructor cannot be called until 
<     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
<     * is called first.
<     */
<    public Buffer() {}
<    
<    /**
<     * Returns the integer value at the specified offset of the
<     * buffer's page.
<     * If an integer was not stored at that location,
<     * the behavior of the method is unpredictable.
<     * @param offset the byte offset of the page
<     * @return the integer value at that offset
<     */
<    public int getInt(int offset) {
<       return contents.getInt(offset);
<    }
< 
<    /**
<     * Returns the string value at the specified offset of the
<     * buffer's page.
<     * If a string was not stored at that location,
<     * the behavior of the method is unpredictable.
<     * @param offset the byte offset of the page
<     * @return the string value at that offset
<     */
<    public String getString(int offset) {
<       return contents.getString(offset);
<    }
< 
<    /**
<     * Writes an integer to the specified offset of the
<     * buffer's page.
<     * This method assumes that the transaction has already
<     * written an appropriate log record.
<     * The buffer saves the id of the transaction
<     * and the LSN of the log record.
<     * A negative lsn value indicates that a log record
<     * was not necessary.
<     * @param offset the byte offset within the page
<     * @param val the new integer value to be written
<     * @param txnum the id of the transaction performing the modification
<     * @param lsn the LSN of the corresponding log record
<     */
<    public void setInt(int offset, int val, int txnum, int lsn) {
<       modifiedBy = txnum;
<       if (lsn >= 0)
< 	      logSequenceNumber = lsn;
<       contents.setInt(offset, val);
<    }
< 
<    /**
<     * Writes a string to the specified offset of the
<     * buffer's page.
<     * This method assumes that the transaction has already
<     * written an appropriate log record.
<     * A negative lsn value indicates that a log record
<     * was not necessary.
<     * The buffer saves the id of the transaction
<     * and the LSN of the log record.
<     * @param offset the byte offset within the page
<     * @param val the new string value to be written
<     * @param txnum the id of the transaction performing the modification
<     * @param lsn the LSN of the corresponding log record
<     */
<    public void setString(int offset, String val, int txnum, int lsn) {
<       modifiedBy = txnum;
<       if (lsn >= 0)
< 	      logSequenceNumber = lsn;
<       contents.setString(offset, val);
<    }
< 
<    /**
<     * Returns a reference to the disk block
<     * that the buffer is pinned to.
<     * @return a reference to a disk block
<     */
<    public Block block() {
<       return blk;
<    }
< 
<    /**
<     * Writes the page to its disk block if the
<     * page is dirty.
<     * The method ensures that the corresponding log
<     * record has been written to disk prior to writing
<     * the page to disk.
<     */
<    void flush() {
<       if (modifiedBy >= 0) {
<          SimpleDB.logMgr().flush(logSequenceNumber);
<          contents.write(blk);
<          modifiedBy = -1;
<       }
<    }
< 
<    /**
<     * Increases the buffer's pin count.
<     */
<    void pin() {
<       pins++;
<    }
< 
<    /**
<     * Decreases the buffer's pin count.
<     */
<    void unpin() {
<       pins--;
<    }
< 
<    /**
<     * Returns true if the buffer is currently pinned
<     * (that is, if it has a nonzero pin count).
<     * @return true if the buffer is pinned
<     */
<    boolean isPinned() {
<       return pins > 0;
<    }
< 
<    /**
<     * Returns true if the buffer is dirty
<     * due to a modification by the specified transaction.
<     * @param txnum the id of the transaction
<     * @return true if the transaction modified the buffer
<     */
<    boolean isModifiedBy(int txnum) {
<       return txnum == modifiedBy;
<    }
< 
<    /**
<     * Reads the contents of the specified block into
<     * the buffer's page.
<     * If the buffer was dirty, then the contents
<     * of the previous page are first written to disk.
<     * @param b a reference to the data block
<     */
<    void assignToBlock(Block b) {
<       flush();
<       blk = b;
<       contents.read(blk);
<       pins = 0;
<    }
< 
<    /**
<     * Initializes the buffer's page according to the specified formatter,
<     * and appends the page to the specified file.
<     * If the buffer was dirty, then the contents
<     * of the previous page are first written to disk.
<     * @param filename the name of the file
<     * @param fmtr a page formatter, used to initialize the page
<     */
<    void assignToNew(String filename, PageFormatter fmtr) {
<       flush();
<       fmtr.format(contents);
<       blk = contents.append(filename);
<       pins = 0;
<    }
---
> package simpledb.buffer;
> 
> import simpledb.server.SimpleDB;
> import simpledb.file.*;
> 
> /**
>  * An individual buffer.
>  * A buffer wraps a page and stores information about its status,
>  * such as the disk block associated with the page,
>  * the number of times the block has been pinned,
>  * whether the contents of the page have been modified,
>  * and if so, the id of the modifying transaction and
>  * the LSN of the corresponding log record.
>  * @author Edward Sciore
>  */
> public class Buffer {
>    private Page contents = new Page();
>    private Block blk = null;
>    private int pins = 0;
>    private int modifiedBy = -1;  // negative means not modified
>    private int logSequenceNumber = -1; // negative means no corresponding log record
> 
>    /**
>     * Creates a new buffer, wrapping a new 
>     * {@link simpledb.file.Page page}.  
>     * This constructor is called exclusively by the 
>     * class {@link BasicBufferMgr}.   
>     * It depends on  the 
>     * {@link simpledb.log.LogMgr LogMgr} object 
>     * that it gets from the class
>     * {@link simpledb.server.SimpleDB}.
>     * That object is created during system initialization.
>     * Thus this constructor cannot be called until 
>     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
>     * is called first.
>     */
>    public Buffer() {}
>    
>    /**
>     * Returns the integer value at the specified offset of the
>     * buffer's page.
>     * If an integer was not stored at that location,
>     * the behavior of the method is unpredictable.
>     * @param offset the byte offset of the page
>     * @return the integer value at that offset
>     */
>    public int getInt(int offset) {
>       return contents.getInt(offset);
>    }
> 
>    /**
>     * Returns the string value at the specified offset of the
>     * buffer's page.
>     * If a string was not stored at that location,
>     * the behavior of the method is unpredictable.
>     * @param offset the byte offset of the page
>     * @return the string value at that offset
>     */
>    public String getString(int offset) {
>       return contents.getString(offset);
>    }
> 
>    /**
>     * Writes an integer to the specified offset of the
>     * buffer's page.
>     * This method assumes that the transaction has already
>     * written an appropriate log record.
>     * The buffer saves the id of the transaction
>     * and the LSN of the log record.
>     * A negative lsn value indicates that a log record
>     * was not necessary.
>     * @param offset the byte offset within the page
>     * @param val the new integer value to be written
>     * @param txnum the id of the transaction performing the modification
>     * @param lsn the LSN of the corresponding log record
>     */
>    public void setInt(int offset, int val, int txnum, int lsn) {
>       modifiedBy = txnum;
>       if (lsn >= 0)
> 	      logSequenceNumber = lsn;
>       contents.setInt(offset, val);
>    }
> 
>    /**
>     * Writes a string to the specified offset of the
>     * buffer's page.
>     * This method assumes that the transaction has already
>     * written an appropriate log record.
>     * A negative lsn value indicates that a log record
>     * was not necessary.
>     * The buffer saves the id of the transaction
>     * and the LSN of the log record.
>     * @param offset the byte offset within the page
>     * @param val the new string value to be written
>     * @param txnum the id of the transaction performing the modification
>     * @param lsn the LSN of the corresponding log record
>     */
>    public void setString(int offset, String val, int txnum, int lsn) {
>       modifiedBy = txnum;
>       if (lsn >= 0)
> 	      logSequenceNumber = lsn;
>       contents.setString(offset, val);
>    }
> 
>    /**
>     * Returns a reference to the disk block
>     * that the buffer is pinned to.
>     * @return a reference to a disk block
>     */
>    public Block block() {
>       return blk;
>    }
> 
>    /**
>     * Writes the page to its disk block if the
>     * page is dirty.
>     * The method ensures that the corresponding log
>     * record has been written to disk prior to writing
>     * the page to disk.
>     */
>    void flush() {
>       if (modifiedBy >= 0) {
>          SimpleDB.logMgr().flush(logSequenceNumber);
>          contents.write(blk);
>          modifiedBy = -1;
>       }
>    }
> 
>    /**
>     * Increases the buffer's pin count.
>     */
>    void pin() {
>       pins++;
>    }
> 
>    /**
>     * Decreases the buffer's pin count.
>     */
>    void unpin() {
>       pins--;
>    }
> 
>    /**
>     * Returns true if the buffer is currently pinned
>     * (that is, if it has a nonzero pin count).
>     * @return true if the buffer is pinned
>     */
>    boolean isPinned() {
>       return pins > 0;
>    }
> 
>    /**
>     * Returns true if the buffer is dirty
>     * due to a modification by the specified transaction.
>     * @param txnum the id of the transaction
>     * @return true if the transaction modified the buffer
>     */
>    boolean isModifiedBy(int txnum) {
>       return txnum == modifiedBy;
>    }
> 
>    /**
>     * Reads the contents of the specified block into
>     * the buffer's page.
>     * If the buffer was dirty, then the contents
>     * of the previous page are first written to disk.
>     * @param b a reference to the data block
>     */
>    void assignToBlock(Block b) {
>       flush();
>       blk = b;
>       contents.read(blk);
>       pins = 0;
>    }
> 
>    /**
>     * Initializes the buffer's page according to the specified formatter,
>     * and appends the page to the specified file.
>     * If the buffer was dirty, then the contents
>     * of the previous page are first written to disk.
>     * @param filename the name of the file
>     * @param fmtr a page formatter, used to initialize the page
>     */
>    void assignToNew(String filename, PageFormatter fmtr) {
>       flush();
>       fmtr.format(contents);
>       blk = contents.append(filename);
>       pins = 0;
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/buffer/BufferMgr.java ../cs4432-proj2/src/simpledb/buffer/BufferMgr.java
1,124c1,124
< package simpledb.buffer;
< 
< import simpledb.file.*;
< 
< /**
<  * The publicly-accessible buffer manager.
<  * A buffer manager wraps a basic buffer manager, and
<  * provides the same methods. The difference is that
<  * the methods {@link #pin(Block) pin} and 
<  * {@link #pinNew(String, PageFormatter) pinNew}
<  * will never return null.
<  * If no buffers are currently available, then the
<  * calling thread will be placed on a waiting list.
<  * The waiting threads are removed from the list when 
<  * a buffer becomes available.
<  * If a thread has been waiting for a buffer for an
<  * excessive amount of time (currently, 10 seconds)
<  * then a {@link BufferAbortException} is thrown.
<  * @author Edward Sciore
<  */
< public class BufferMgr {
<    private static final long MAX_TIME = 10000; // 10 seconds
<    private BasicBufferMgr bufferMgr;
<    
<    /**
<     * Creates a new buffer manager having the specified 
<     * number of buffers.
<     * This constructor depends on both the {@link FileMgr} and
<     * {@link simpledb.log.LogMgr LogMgr} objects 
<     * that it gets from the class
<     * {@link simpledb.server.SimpleDB}.
<     * Those objects are created during system initialization.
<     * Thus this constructor cannot be called until 
<     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
<     * is called first.
<     * @param numbuffers the number of buffer slots to allocate
<     */
<    public BufferMgr(int numbuffers) {
<       bufferMgr = new BasicBufferMgr(numbuffers);
<    }
<    
<    /**
<     * Pins a buffer to the specified block, potentially
<     * waiting until a buffer becomes available.
<     * If no buffer becomes available within a fixed 
<     * time period, then a {@link BufferAbortException} is thrown.
<     * @param blk a reference to a disk block
<     * @return the buffer pinned to that block
<     */
<    public synchronized Buffer pin(Block blk) {
<       try {
<          long timestamp = System.currentTimeMillis();
<          Buffer buff = bufferMgr.pin(blk);
<          while (buff == null && !waitingTooLong(timestamp)) {
<             wait(MAX_TIME);
<             buff = bufferMgr.pin(blk);
<          }
<          if (buff == null)
<             throw new BufferAbortException();
<          return buff;
<       }
<       catch(InterruptedException e) {
<          throw new BufferAbortException();
<       }
<    }
<    
<    /**
<     * Pins a buffer to a new block in the specified file, 
<     * potentially waiting until a buffer becomes available.
<     * If no buffer becomes available within a fixed 
<     * time period, then a {@link BufferAbortException} is thrown.
<     * @param filename the name of the file
<     * @param fmtr the formatter used to initialize the page
<     * @return the buffer pinned to that block
<     */
<    public synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
<       try {
<          long timestamp = System.currentTimeMillis();
<          Buffer buff = bufferMgr.pinNew(filename, fmtr);
<          while (buff == null && !waitingTooLong(timestamp)) {
<             wait(MAX_TIME);
<             buff = bufferMgr.pinNew(filename, fmtr);
<          }
<          if (buff == null)
<             throw new BufferAbortException();
<          return buff;
<       }
<       catch(InterruptedException e) {
<          throw new BufferAbortException();
<       }
<    }
<    
<    /**
<     * Unpins the specified buffer. 
<     * If the buffer's pin count becomes 0,
<     * then the threads on the wait list are notified.
<     * @param buff the buffer to be unpinned
<     */
<    public synchronized void unpin(Buffer buff) {
<       bufferMgr.unpin(buff);
<       if (!buff.isPinned())
<          notifyAll();
<    }
<    
<    /**
<     * Flushes the dirty buffers modified by the specified transaction.
<     * @param txnum the transaction's id number
<     */
<    public void flushAll(int txnum) {
<       bufferMgr.flushAll(txnum);
<    }
<    
<    /**
<     * Returns the number of available (ie unpinned) buffers.
<     * @return the number of available buffers
<     */
<    public int available() {
<       return bufferMgr.available();
<    }
<    
<    private boolean waitingTooLong(long starttime) {
<       return System.currentTimeMillis() - starttime > MAX_TIME;
<    }
< }
---
> package simpledb.buffer;
> 
> import simpledb.file.*;
> 
> /**
>  * The publicly-accessible buffer manager.
>  * A buffer manager wraps a basic buffer manager, and
>  * provides the same methods. The difference is that
>  * the methods {@link #pin(Block) pin} and 
>  * {@link #pinNew(String, PageFormatter) pinNew}
>  * will never return null.
>  * If no buffers are currently available, then the
>  * calling thread will be placed on a waiting list.
>  * The waiting threads are removed from the list when 
>  * a buffer becomes available.
>  * If a thread has been waiting for a buffer for an
>  * excessive amount of time (currently, 10 seconds)
>  * then a {@link BufferAbortException} is thrown.
>  * @author Edward Sciore
>  */
> public class BufferMgr {
>    private static final long MAX_TIME = 10000; // 10 seconds
>    private BasicBufferMgr bufferMgr;
>    
>    /**
>     * Creates a new buffer manager having the specified 
>     * number of buffers.
>     * This constructor depends on both the {@link FileMgr} and
>     * {@link simpledb.log.LogMgr LogMgr} objects 
>     * that it gets from the class
>     * {@link simpledb.server.SimpleDB}.
>     * Those objects are created during system initialization.
>     * Thus this constructor cannot be called until 
>     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
>     * is called first.
>     * @param numbuffers the number of buffer slots to allocate
>     */
>    public BufferMgr(int numbuffers) {
>       bufferMgr = new BasicBufferMgr(numbuffers);
>    }
>    
>    /**
>     * Pins a buffer to the specified block, potentially
>     * waiting until a buffer becomes available.
>     * If no buffer becomes available within a fixed 
>     * time period, then a {@link BufferAbortException} is thrown.
>     * @param blk a reference to a disk block
>     * @return the buffer pinned to that block
>     */
>    public synchronized Buffer pin(Block blk) {
>       try {
>          long timestamp = System.currentTimeMillis();
>          Buffer buff = bufferMgr.pin(blk);
>          while (buff == null && !waitingTooLong(timestamp)) {
>             wait(MAX_TIME);
>             buff = bufferMgr.pin(blk);
>          }
>          if (buff == null)
>             throw new BufferAbortException();
>          return buff;
>       }
>       catch(InterruptedException e) {
>          throw new BufferAbortException();
>       }
>    }
>    
>    /**
>     * Pins a buffer to a new block in the specified file, 
>     * potentially waiting until a buffer becomes available.
>     * If no buffer becomes available within a fixed 
>     * time period, then a {@link BufferAbortException} is thrown.
>     * @param filename the name of the file
>     * @param fmtr the formatter used to initialize the page
>     * @return the buffer pinned to that block
>     */
>    public synchronized Buffer pinNew(String filename, PageFormatter fmtr) {
>       try {
>          long timestamp = System.currentTimeMillis();
>          Buffer buff = bufferMgr.pinNew(filename, fmtr);
>          while (buff == null && !waitingTooLong(timestamp)) {
>             wait(MAX_TIME);
>             buff = bufferMgr.pinNew(filename, fmtr);
>          }
>          if (buff == null)
>             throw new BufferAbortException();
>          return buff;
>       }
>       catch(InterruptedException e) {
>          throw new BufferAbortException();
>       }
>    }
>    
>    /**
>     * Unpins the specified buffer. 
>     * If the buffer's pin count becomes 0,
>     * then the threads on the wait list are notified.
>     * @param buff the buffer to be unpinned
>     */
>    public synchronized void unpin(Buffer buff) {
>       bufferMgr.unpin(buff);
>       if (!buff.isPinned())
>          notifyAll();
>    }
>    
>    /**
>     * Flushes the dirty buffers modified by the specified transaction.
>     * @param txnum the transaction's id number
>     */
>    public void flushAll(int txnum) {
>       bufferMgr.flushAll(txnum);
>    }
>    
>    /**
>     * Returns the number of available (ie unpinned) buffers.
>     * @return the number of available buffers
>     */
>    public int available() {
>       return bufferMgr.available();
>    }
>    
>    private boolean waitingTooLong(long starttime) {
>       return System.currentTimeMillis() - starttime > MAX_TIME;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/buffer/PageFormatter.java ../cs4432-proj2/src/simpledb/buffer/PageFormatter.java
1,20c1,20
< package simpledb.buffer;
< 
< import simpledb.file.Page;
< 
< /**
<  * An interface used to initialize a new block on disk.
<  * There will be an implementing class for each "type" of
<  * disk block.
<  * @author Edward Sciore
<  */
< public interface PageFormatter {
<    /**
<     * Initializes a page, whose contents will be
<     * written to a new disk block.
<     * This method is called only during the method
<     * {@link Buffer#assignToNew}.
<     * @param p a buffer page
<     */
<    public void format(Page p);
< }
---
> package simpledb.buffer;
> 
> import simpledb.file.Page;
> 
> /**
>  * An interface used to initialize a new block on disk.
>  * There will be an implementing class for each "type" of
>  * disk block.
>  * @author Edward Sciore
>  */
> public interface PageFormatter {
>    /**
>     * Initializes a page, whose contents will be
>     * written to a new disk block.
>     * This method is called only during the method
>     * {@link Buffer#assignToNew}.
>     * @param p a buffer page
>     */
>    public void format(Page p);
> }
diff -r simpledb/SimpleDB_2.10/simpledb/file/Block.java ../cs4432-proj2/src/simpledb/file/Block.java
1,53c1,53
< package simpledb.file;
< 
< /**
<  * A reference to a disk block.
<  * A Block object consists of a filename and a block number.
<  * It does not hold the contents of the block;
<  * instead, that is the job of a {@link Page} object.
<  * @author Edward Sciore
<  */
< public class Block {
<    private String filename;
<    private int blknum;
<    
<    /**
<     * Constructs a block reference 
<     * for the specified filename and block number.
<     * @param filename the name of the file
<     * @param blknum the block number
<     */
<    public Block(String filename, int blknum) {
<       this.filename = filename;
<       this.blknum   = blknum;
<    }
<    
<    /**
<     * Returns the name of the file where the block lives.
<     * @return the filename
<     */
<    public String fileName() {
<       return filename;
<    }
<    
<    /**
<     * Returns the location of the block within the file.
<     * @return the block number
<     */
<    public int number() {
<       return blknum;
<    }
<    
<    public boolean equals(Object obj) {
<       Block blk = (Block) obj;
<       return filename.equals(blk.filename) && blknum == blk.blknum;
<    }
<    
<    public String toString() {
<       return "[file " + filename + ", block " + blknum + "]";
<    }
<    
<    public int hashCode() {
<       return toString().hashCode();
<    }
< }
---
> package simpledb.file;
> 
> /**
>  * A reference to a disk block.
>  * A Block object consists of a filename and a block number.
>  * It does not hold the contents of the block;
>  * instead, that is the job of a {@link Page} object.
>  * @author Edward Sciore
>  */
> public class Block {
>    private String filename;
>    private int blknum;
>    
>    /**
>     * Constructs a block reference 
>     * for the specified filename and block number.
>     * @param filename the name of the file
>     * @param blknum the block number
>     */
>    public Block(String filename, int blknum) {
>       this.filename = filename;
>       this.blknum   = blknum;
>    }
>    
>    /**
>     * Returns the name of the file where the block lives.
>     * @return the filename
>     */
>    public String fileName() {
>       return filename;
>    }
>    
>    /**
>     * Returns the location of the block within the file.
>     * @return the block number
>     */
>    public int number() {
>       return blknum;
>    }
>    
>    public boolean equals(Object obj) {
>       Block blk = (Block) obj;
>       return filename.equals(blk.filename) && blknum == blk.blknum;
>    }
>    
>    public String toString() {
>       return "[file " + filename + ", block " + blknum + "]";
>    }
>    
>    public int hashCode() {
>       return toString().hashCode();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/file/FileMgr.java ../cs4432-proj2/src/simpledb/file/FileMgr.java
1,142c1,180
< package simpledb.file;
< 
< import static simpledb.file.Page.BLOCK_SIZE;
< import java.io.*;
< import java.nio.ByteBuffer;
< import java.nio.channels.FileChannel;
< import java.util.*;
< 
< /**
<  * The SimpleDB file manager.
<  * The database system stores its data as files within a specified directory.
<  * The file manager provides methods for reading the contents of
<  * a file block to a Java byte buffer,
<  * writing the contents of a byte buffer to a file block,
<  * and appending the contents of a byte buffer to the end of a file.
<  * These methods are called exclusively by the class {@link simpledb.file.Page Page},
<  * and are thus package-private.
<  * The class also contains two public methods:
<  * Method {@link #isNew() isNew} is called during system initialization by {@link simpledb.server.SimpleDB#init}.
<  * Method {@link #size(String) size} is called by the log manager and transaction manager to
<  * determine the end of the file.
<  * @author Edward Sciore
<  */
< public class FileMgr {
<    private File dbDirectory;
<    private boolean isNew;
<    private Map<String,FileChannel> openFiles = new HashMap<String,FileChannel>();
< 
<    /**
<     * Creates a file manager for the specified database.
<     * The database will be stored in a folder of that name
<     * in the user's home directory.
<     * If the folder does not exist, then a folder containing
<     * an empty database is created automatically.
<     * Files for all temporary tables (i.e. tables beginning with "temp") are deleted.
<     * @param dbname the name of the directory that holds the database
<     */
<    public FileMgr(String dbname) {
<       String homedir = System.getProperty("user.home");
<       dbDirectory = new File(homedir, dbname);
<       isNew = !dbDirectory.exists();
< 
<       // create the directory if the database is new
<       if (isNew && !dbDirectory.mkdir())
<          throw new RuntimeException("cannot create " + dbname);
< 
<       // remove any leftover temporary tables
<       for (String filename : dbDirectory.list())
<          if (filename.startsWith("temp"))
<          new File(dbDirectory, filename).delete();
<    }
< 
<    /**
<     * Reads the contents of a disk block into a bytebuffer.
<     * @param blk a reference to a disk block
<     * @param bb  the bytebuffer
<     */
<    synchronized void read(Block blk, ByteBuffer bb) {
<       try {
<          bb.clear();
<          FileChannel fc = getFile(blk.fileName());
<          fc.read(bb, blk.number() * BLOCK_SIZE);
<       }
<       catch (IOException e) {
<          throw new RuntimeException("cannot read block " + blk);
<       }
<    }
< 
<    /**
<     * Writes the contents of a bytebuffer into a disk block.
<     * @param blk a reference to a disk block
<     * @param bb  the bytebuffer
<     */
<    synchronized void write(Block blk, ByteBuffer bb) {
<       try {
<          bb.rewind();
<          FileChannel fc = getFile(blk.fileName());
<          fc.write(bb, blk.number() * BLOCK_SIZE);
<       }
<       catch (IOException e) {
<          throw new RuntimeException("cannot write block" + blk);
<       }
<    }
< 
<    /**
<     * Appends the contents of a bytebuffer to the end
<     * of the specified file.
<     * @param filename the name of the file
<     * @param bb  the bytebuffer
<     * @return a reference to the newly-created block.
<     */
<    synchronized Block append(String filename, ByteBuffer bb) {
<       int newblknum = size(filename);
<       Block blk = new Block(filename, newblknum);
<       write(blk, bb);
<       return blk;
<    }
< 
<    /**
<     * Returns the number of blocks in the specified file.
<     * @param filename the name of the file
<     * @return the number of blocks in the file
<     */
<    public synchronized int size(String filename) {
<       try {
<          FileChannel fc = getFile(filename);
<          return (int)(fc.size() / BLOCK_SIZE);
<       }
<       catch (IOException e) {
<          throw new RuntimeException("cannot access " + filename);
<       }
<    }
< 
<    /**
<     * Returns a boolean indicating whether the file manager
<     * had to create a new database directory.
<     * @return true if the database is new
<     */
<    public boolean isNew() {
<       return isNew;
<    }
< 
<    /**
<     * Returns the file channel for the specified filename.
<     * The file channel is stored in a map keyed on the filename.
<     * If the file is not open, then it is opened and the file channel
<     * is added to the map.
<     * @param filename the specified filename
<     * @return the file channel associated with the open file.
<     * @throws IOException
<     */
<    private FileChannel getFile(String filename) throws IOException {
<       FileChannel fc = openFiles.get(filename);
<       if (fc == null) {
<          File dbTable = new File(dbDirectory, filename);
<          RandomAccessFile f = new RandomAccessFile(dbTable, "rws");
<          fc = f.getChannel();
<          openFiles.put(filename, fc);
<       }
<       return fc;
<    }
< }
---
> package simpledb.file;
> 
> import static simpledb.file.Page.BLOCK_SIZE;
> import java.io.*;
> import java.nio.ByteBuffer;
> import java.nio.channels.FileChannel;
> import java.util.*;
> 
> /**
>  * The SimpleDB file manager.
>  * The database system stores its data as files within a specified directory.
>  * The file manager provides methods for reading the contents of
>  * a file block to a Java byte buffer,
>  * writing the contents of a byte buffer to a file block,
>  * and appending the contents of a byte buffer to the end of a file.
>  * These methods are called exclusively by the class {@link simpledb.file.Page Page},
>  * and are thus package-private.
>  * The class also contains two public methods:
>  * Method {@link #isNew() isNew} is called during system initialization by {@link simpledb.server.SimpleDB#init}.
>  * Method {@link #size(String) size} is called by the log manager and transaction manager to
>  * determine the end of the file.
>  * @author Edward Sciore
>  *
>  * CS 4432 Project 2
>  *
>  * IO logging is done here. 
>  * Each time a file is read, written, updated, or deleted, the IO count is incremented.
>  */
> public class FileMgr {
>     private File dbDirectory;
>     private boolean isNew;
>     private Map<String,FileChannel> openFiles = new HashMap<String,FileChannel>();
> 
>     // Records number of ios done. 
>     private long ios;
> 
>     /**
>      * Creates a file manager for the specified database.
>      * The database will be stored in a folder of that name
>      * in the user's home directory.
>      * If the folder does not exist, then a folder containing
>      * an empty database is created automatically.
>      * Files for all temporary tables (i.e. tables beginning with "temp") are deleted.
>      * @param dbname the name of the directory that holds the database
>      */
>     public FileMgr(String dbname) {
>         String homedir = System.getProperty("user.home");
>         dbDirectory = new File(homedir, dbname);
>         isNew = !dbDirectory.exists();
> 
>         // create the directory if the database is new
>         if (isNew && !dbDirectory.mkdir())
>             throw new RuntimeException("cannot create " + dbname);
> 
>         // remove any leftover temporary tables
>         for (String filename : dbDirectory.list())
>             if (filename.startsWith("temp"))
>             new File(dbDirectory, filename).delete();
>         ios = 0;
>     }
> 
>     /**
>      * Reads the contents of a disk block into a bytebuffer.
>      * @param blk a reference to a disk block
>      * @param bb  the bytebuffer
>      */
>     synchronized void read(Block blk, ByteBuffer bb) {
>         try {
>             bb.clear();
>             FileChannel fc = getFile(blk.fileName());
>             fc.read(bb, blk.number() * BLOCK_SIZE);
>             ios++;
>         }
>         catch (IOException e) {
>             throw new RuntimeException("cannot read block " + blk);
>         }
>     }
> 
>     /**
>      * Writes the contents of a bytebuffer into a disk block.
>      * @param blk a reference to a disk block
>      * @param bb  the bytebuffer
>      */
>     synchronized void write(Block blk, ByteBuffer bb) {
>         try {
>             bb.rewind();
>             FileChannel fc = getFile(blk.fileName());
>             fc.write(bb, blk.number() * BLOCK_SIZE);
>             ios++;
>         }
>         catch (IOException e) {
>             throw new RuntimeException("cannot write block" + blk);
>         }
>     }
> 
>     /**
>      * Appends the contents of a bytebuffer to the end
>      * of the specified file.
>      * @param filename the name of the file
>      * @param bb  the bytebuffer
>      * @return a reference to the newly-created block.
>      */
>     synchronized Block append(String filename, ByteBuffer bb) {
>         int newblknum = size(filename);
>         Block blk = new Block(filename, newblknum);
>         write(blk, bb);
>         return blk;
>     }
> 
>     /**
>      * Returns the number of blocks in the specified file.
>      * @param filename the name of the file
>      * @return the number of blocks in the file
>      */
>     public synchronized int size(String filename) {
>         try {
>             FileChannel fc = getFile(filename);
>             return (int)(fc.size() / BLOCK_SIZE);
>         }
>         catch (IOException e) {
>             throw new RuntimeException("cannot access " + filename);
>         }
>     }
> 
>     /**
>      * Returns a boolean indicating whether the file manager
>      * had to create a new database directory.
>      * @return true if the database is new
>      */
>     public boolean isNew() {
>         return isNew;
>     }
> 
>     /**
>      * Returns the file channel for the specified filename.
>      * The file channel is stored in a map keyed on the filename.
>      * If the file is not open, then it is opened and the file channel
>      * is added to the map.
>      * @param filename the specified filename
>      * @return the file channel associated with the open file.
>      * @throws IOException
>      */
>     private FileChannel getFile(String filename) throws IOException {
>         FileChannel fc = openFiles.get(filename);
>         if (fc == null) {
>             File dbTable = new File(dbDirectory, filename);
>             RandomAccessFile f = new RandomAccessFile(dbTable, "rws");
>             fc = f.getChannel();
>             openFiles.put(filename, fc);
>         }
>         ios++;
>         return fc;
>     }
> 
>     /**
>      * CS 4432 Project 2
>      * 
>      * Deletes a file
>      * @param filename the specified filename
>      * @throws IOException
>      */
>     public void deleteFile(String filename) throws IOException {
>         FileChannel fc = openFiles.get(filename);
>         if (fc != null) {
>             fc.close();
>             openFiles.remove(filename);
>             File dbTable = new File(dbDirectory, filename);
>             dbTable.delete();
>             ios++;
>         }
>     }
> 
>     /**
>      *
>      * @return The number of IOs done by this manager
>      */
>     public long getIos() {
>         return ios;
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/file/Page.java ../cs4432-proj2/src/simpledb/file/Page.java
1,159c1,159
< package simpledb.file;
< 
< import simpledb.server.SimpleDB;
< import java.nio.ByteBuffer;
< import java.nio.charset.Charset;
< 
< /**
<  * The contents of a disk block in memory.
<  * A page is treated as an array of BLOCK_SIZE bytes.
<  * There are methods to get/set values into this array,
<  * and to read/write the contents of this array to a disk block.
<  * 
<  * For an example of how to use Page and 
<  * {@link Block} objects, 
<  * consider the following code fragment.  
<  * The first portion increments the integer at offset 792 of block 6 of file junk.  
<  * The second portion stores the string "hello" at offset 20 of a page, 
<  * and then appends it to a new block of the file.  
<  * It then reads that block into another page 
<  * and extracts the value "hello" into variable s.
<  * <pre>
<  * Page p1 = new Page();
<  * Block blk = new Block("junk", 6);
<  * p1.read(blk);
<  * int n = p1.getInt(792);
<  * p1.setInt(792, n+1);
<  * p1.write(blk);
<  *
<  * Page p2 = new Page();
<  * p2.setString(20, "hello");
<  * blk = p2.append("junk");
<  * Page p3 = new Page();
<  * p3.read(blk);
<  * String s = p3.getString(20);
<  * </pre>
<  * @author Edward Sciore
<  */
< public class Page {
<    /**
<     * The number of bytes in a block.
<     * This value is set unreasonably low, so that it is easier
<     * to create and test databases having a lot of blocks.
<     * A more realistic value would be 4K.
<     */
<    public static final int BLOCK_SIZE = 400;
<    
<    /**
<     * The size of an integer in bytes.
<     * This value is almost certainly 4, but it is
<     * a good idea to encode this value as a constant. 
<     */
<    public static final int INT_SIZE = Integer.SIZE / Byte.SIZE;
<    
<    /**
<     * The maximum size, in bytes, of a string of length n.
<     * A string is represented as the encoding of its characters,
<     * preceded by an integer denoting the number of bytes in this encoding.
<     * If the JVM uses the US-ASCII encoding, then each char
<     * is stored in one byte, so a string of n characters
<     * has a size of 4+n bytes.
<     * @param n the size of the string
<     * @return the maximum number of bytes required to store a string of size n
<     */
<    public static final int STR_SIZE(int n) {
<       float bytesPerChar = Charset.defaultCharset().newEncoder().maxBytesPerChar();
<       return INT_SIZE + (n * (int)bytesPerChar);
<    }
<    
<    private ByteBuffer contents = ByteBuffer.allocateDirect(BLOCK_SIZE);
<    private FileMgr filemgr = SimpleDB.fileMgr();
<    
<    /**
<     * Creates a new page.  Although the constructor takes no arguments,
<     * it depends on a {@link FileMgr} object that it gets from the
<     * method {@link simpledb.server.SimpleDB#fileMgr()}.
<     * That object is created during system initialization.
<     * Thus this constructor cannot be called until either
<     * {@link simpledb.server.SimpleDB#init(String)} or
<     * {@link simpledb.server.SimpleDB#initFileMgr(String)} or
<     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
<     * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)}
<     * is called first.
<     */
<    public Page() {}
<    
<    /**
<     * Populates the page with the contents of the specified disk block. 
<     * @param blk a reference to a disk block
<     */
<    public synchronized void read(Block blk) {
<       filemgr.read(blk, contents);
<    }
<    
<    /**
<     * Writes the contents of the page to the specified disk block.
<     * @param blk a reference to a disk block
<     */
<    public synchronized void write(Block blk) {
<       filemgr.write(blk, contents);
<    }
<    
<    /**
<     * Appends the contents of the page to the specified file.
<     * @param filename the name of the file
<     * @return the reference to the newly-created disk block
<     */
<    public synchronized Block append(String filename) {
<       return filemgr.append(filename, contents);
<    }
<    
<    /**
<     * Returns the integer value at a specified offset of the page.
<     * If an integer was not stored at that location, 
<     * the behavior of the method is unpredictable.
<     * @param offset the byte offset within the page
<     * @return the integer value at that offset
<     */
<    public synchronized int getInt(int offset) {
<       contents.position(offset);
<       return contents.getInt();
<    }
<    
<    /**
<     * Writes an integer to the specified offset on the page.
<     * @param offset the byte offset within the page
<     * @param val the integer to be written to the page
<     */
<    public synchronized void setInt(int offset, int val) {
<       contents.position(offset);
<       contents.putInt(val);
<    }
<    
<    /**
<     * Returns the string value at the specified offset of the page.
<     * If a string was not stored at that location,
<     * the behavior of the method is unpredictable.
<     * @param offset the byte offset within the page
<     * @return the string value at that offset
<     */
<    public synchronized String getString(int offset) {
<       contents.position(offset);
<       int len = contents.getInt();
<       byte[] byteval = new byte[len];
<       contents.get(byteval);
<       return new String(byteval);
<    }
<    
<    /**
<     * Writes a string to the specified offset on the page.
<     * @param offset the byte offset within the page
<     * @param val the string to be written to the page
<     */
<    public synchronized void setString(int offset, String val) {
<       contents.position(offset);
<       byte[] byteval = val.getBytes();
<       contents.putInt(byteval.length);
<       contents.put(byteval);
<    }
< }
---
> package simpledb.file;
> 
> import simpledb.server.SimpleDB;
> import java.nio.ByteBuffer;
> import java.nio.charset.Charset;
> 
> /**
>  * The contents of a disk block in memory.
>  * A page is treated as an array of BLOCK_SIZE bytes.
>  * There are methods to get/set values into this array,
>  * and to read/write the contents of this array to a disk block.
>  * 
>  * For an example of how to use Page and 
>  * {@link Block} objects, 
>  * consider the following code fragment.  
>  * The first portion increments the integer at offset 792 of block 6 of file junk.  
>  * The second portion stores the string "hello" at offset 20 of a page, 
>  * and then appends it to a new block of the file.  
>  * It then reads that block into another page 
>  * and extracts the value "hello" into variable s.
>  * <pre>
>  * Page p1 = new Page();
>  * Block blk = new Block("junk", 6);
>  * p1.read(blk);
>  * int n = p1.getInt(792);
>  * p1.setInt(792, n+1);
>  * p1.write(blk);
>  *
>  * Page p2 = new Page();
>  * p2.setString(20, "hello");
>  * blk = p2.append("junk");
>  * Page p3 = new Page();
>  * p3.read(blk);
>  * String s = p3.getString(20);
>  * </pre>
>  * @author Edward Sciore
>  */
> public class Page {
>    /**
>     * The number of bytes in a block.
>     * This value is set unreasonably low, so that it is easier
>     * to create and test databases having a lot of blocks.
>     * A more realistic value would be 4K.
>     */
>    public static final int BLOCK_SIZE = 400;
>    
>    /**
>     * The size of an integer in bytes.
>     * This value is almost certainly 4, but it is
>     * a good idea to encode this value as a constant. 
>     */
>    public static final int INT_SIZE = Integer.SIZE / Byte.SIZE;
>    
>    /**
>     * The maximum size, in bytes, of a string of length n.
>     * A string is represented as the encoding of its characters,
>     * preceded by an integer denoting the number of bytes in this encoding.
>     * If the JVM uses the US-ASCII encoding, then each char
>     * is stored in one byte, so a string of n characters
>     * has a size of 4+n bytes.
>     * @param n the size of the string
>     * @return the maximum number of bytes required to store a string of size n
>     */
>    public static final int STR_SIZE(int n) {
>       float bytesPerChar = Charset.defaultCharset().newEncoder().maxBytesPerChar();
>       return INT_SIZE + (n * (int)bytesPerChar);
>    }
>    
>    private ByteBuffer contents = ByteBuffer.allocateDirect(BLOCK_SIZE);
>    private FileMgr filemgr = SimpleDB.fileMgr();
>    
>    /**
>     * Creates a new page.  Although the constructor takes no arguments,
>     * it depends on a {@link FileMgr} object that it gets from the
>     * method {@link simpledb.server.SimpleDB#fileMgr()}.
>     * That object is created during system initialization.
>     * Thus this constructor cannot be called until either
>     * {@link simpledb.server.SimpleDB#init(String)} or
>     * {@link simpledb.server.SimpleDB#initFileMgr(String)} or
>     * {@link simpledb.server.SimpleDB#initFileAndLogMgr(String)} or
>     * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)}
>     * is called first.
>     */
>    public Page() {}
>    
>    /**
>     * Populates the page with the contents of the specified disk block. 
>     * @param blk a reference to a disk block
>     */
>    public synchronized void read(Block blk) {
>       filemgr.read(blk, contents);
>    }
>    
>    /**
>     * Writes the contents of the page to the specified disk block.
>     * @param blk a reference to a disk block
>     */
>    public synchronized void write(Block blk) {
>       filemgr.write(blk, contents);
>    }
>    
>    /**
>     * Appends the contents of the page to the specified file.
>     * @param filename the name of the file
>     * @return the reference to the newly-created disk block
>     */
>    public synchronized Block append(String filename) {
>       return filemgr.append(filename, contents);
>    }
>    
>    /**
>     * Returns the integer value at a specified offset of the page.
>     * If an integer was not stored at that location, 
>     * the behavior of the method is unpredictable.
>     * @param offset the byte offset within the page
>     * @return the integer value at that offset
>     */
>    public synchronized int getInt(int offset) {
>       contents.position(offset);
>       return contents.getInt();
>    }
>    
>    /**
>     * Writes an integer to the specified offset on the page.
>     * @param offset the byte offset within the page
>     * @param val the integer to be written to the page
>     */
>    public synchronized void setInt(int offset, int val) {
>       contents.position(offset);
>       contents.putInt(val);
>    }
>    
>    /**
>     * Returns the string value at the specified offset of the page.
>     * If a string was not stored at that location,
>     * the behavior of the method is unpredictable.
>     * @param offset the byte offset within the page
>     * @return the string value at that offset
>     */
>    public synchronized String getString(int offset) {
>       contents.position(offset);
>       int len = contents.getInt();
>       byte[] byteval = new byte[len];
>       contents.get(byteval);
>       return new String(byteval);
>    }
>    
>    /**
>     * Writes a string to the specified offset on the page.
>     * @param offset the byte offset within the page
>     * @param val the string to be written to the page
>     */
>    public synchronized void setString(int offset, String val) {
>       contents.position(offset);
>       byte[] byteval = val.getBytes();
>       contents.putInt(byteval.length);
>       contents.put(byteval);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/Index.java ../cs4432-proj2/src/simpledb/index/Index.java
1,54c1,54
< package simpledb.index;
< 
< import simpledb.record.RID;
< import simpledb.query.Constant;
< 
< /**
<  * This interface contains methods to traverse an index.
<  * @author Edward Sciore
<  *
<  */
< public interface Index {
<    
<    /**
<     * Positions the index before the first record
<     * having the specified search key.
<     * @param searchkey the search key value.
<     */
<    public void    beforeFirst(Constant searchkey);
<    
<    /**
<     * Moves the index to the next record having the
<     * search key specified in the beforeFirst method. 
<     * Returns false if there are no more such index records.
<     * @return false if no other index records have the search key.
<     */
<    public boolean next();
<    
<    /**
<     * Returns the dataRID value stored in the current index record. 
<     * @return the dataRID stored in the current index record.
<     */
<    public RID     getDataRid();
<    
<    /**
<     * Inserts an index record having the specified
<     * dataval and dataRID values.
<     * @param dataval the dataval in the new index record.
<     * @param datarid the dataRID in the new index record.
<     */
<    public void    insert(Constant dataval, RID datarid);
<    
<    /**
<     * Deletes the index record having the specified
<     * dataval and dataRID values.
<     * @param dataval the dataval of the deleted index record
<     * @param datarid the dataRID of the deleted index record
<     */
<    public void    delete(Constant dataval, RID datarid);
<    
<    /**
<     * Closes the index.
<     */
<    public void    close();
< }
---
> package simpledb.index;
> 
> import simpledb.record.RID;
> import simpledb.query.Constant;
> 
> /**
>  * This interface contains methods to traverse an index.
>  * @author Edward Sciore
>  *
>  */
> public interface Index {
>    
>    /**
>     * Positions the index before the first record
>     * having the specified search key.
>     * @param searchkey the search key value.
>     */
>    public void    beforeFirst(Constant searchkey);
>    
>    /**
>     * Moves the index to the next record having the
>     * search key specified in the beforeFirst method. 
>     * Returns false if there are no more such index records.
>     * @return false if no other index records have the search key.
>     */
>    public boolean next();
>    
>    /**
>     * Returns the dataRID value stored in the current index record. 
>     * @return the dataRID stored in the current index record.
>     */
>    public RID     getDataRid();
>    
>    /**
>     * Inserts an index record having the specified
>     * dataval and dataRID values.
>     * @param dataval the dataval in the new index record.
>     * @param datarid the dataRID in the new index record.
>     */
>    public void    insert(Constant dataval, RID datarid);
>    
>    /**
>     * Deletes the index record having the specified
>     * dataval and dataRID values.
>     * @param dataval the dataval of the deleted index record
>     * @param datarid the dataRID of the deleted index record
>     */
>    public void    delete(Constant dataval, RID datarid);
>    
>    /**
>     * Closes the index.
>     */
>    public void    close();
> }
Only in ../cs4432-proj2/src/simpledb/index: IndexType.java
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/BTPageFormatter.java ../cs4432-proj2/src/simpledb/index/btree/BTPageFormatter.java
1,55c1,55
< package simpledb.index.btree;
< 
< import static simpledb.file.Page.*;
< import static java.sql.Types.INTEGER;
< import simpledb.file.Page;
< import simpledb.buffer.PageFormatter;
< import simpledb.record.TableInfo;
< 
< /**
<  * An object that can format a page to look like an
<  * empty B-tree block.
<  * @author Edward Sciore
<  */
< public class BTPageFormatter implements PageFormatter {
<    private TableInfo ti;
<    private int flag;
<    
<    /**
<     * Creates a formatter for a new page of the
<     * specified B-tree index.
<     * @param ti the index's metadata
<     * @param flag the page's initial flag value
<     */
<    public BTPageFormatter(TableInfo ti, int flag) {
<       this.ti = ti;
<       this.flag = flag;
<    }
<    
<    /** 
<     * Formats the page by initializing as many index-record slots
<     * as possible to have default values.
<     * Each integer field is given a value of 0, and
<     * each string field is given a value of "".
<     * The location that indicates the number of records
<     * in the page is also set to 0.
<     * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
<     */
<    public void format(Page page) {
<       page.setInt(0, flag);
<       page.setInt(INT_SIZE, 0);  // #records = 0
<       int recsize = ti.recordLength();
<       for (int pos=2*INT_SIZE; pos+recsize<=BLOCK_SIZE; pos += recsize)
<          makeDefaultRecord(page, pos);
<    }
<    
<    private void makeDefaultRecord(Page page, int pos) {
<       for (String fldname : ti.schema().fields()) {
<          int offset = ti.offset(fldname);
<          if (ti.schema().type(fldname) == INTEGER)
<             page.setInt(pos + offset, 0);
<          else
<             page.setString(pos + offset, "");
<       }
<    }
< }
---
> package simpledb.index.btree;
> 
> import static simpledb.file.Page.*;
> import static java.sql.Types.INTEGER;
> import simpledb.file.Page;
> import simpledb.buffer.PageFormatter;
> import simpledb.record.TableInfo;
> 
> /**
>  * An object that can format a page to look like an
>  * empty B-tree block.
>  * @author Edward Sciore
>  */
> public class BTPageFormatter implements PageFormatter {
>    private TableInfo ti;
>    private int flag;
>    
>    /**
>     * Creates a formatter for a new page of the
>     * specified B-tree index.
>     * @param ti the index's metadata
>     * @param flag the page's initial flag value
>     */
>    public BTPageFormatter(TableInfo ti, int flag) {
>       this.ti = ti;
>       this.flag = flag;
>    }
>    
>    /** 
>     * Formats the page by initializing as many index-record slots
>     * as possible to have default values.
>     * Each integer field is given a value of 0, and
>     * each string field is given a value of "".
>     * The location that indicates the number of records
>     * in the page is also set to 0.
>     * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
>     */
>    public void format(Page page) {
>       page.setInt(0, flag);
>       page.setInt(INT_SIZE, 0);  // #records = 0
>       int recsize = ti.recordLength();
>       for (int pos=2*INT_SIZE; pos+recsize<=BLOCK_SIZE; pos += recsize)
>          makeDefaultRecord(page, pos);
>    }
>    
>    private void makeDefaultRecord(Page page, int pos) {
>       for (String fldname : ti.schema().fields()) {
>          int offset = ti.offset(fldname);
>          if (ti.schema().type(fldname) == INTEGER)
>             page.setInt(pos + offset, 0);
>          else
>             page.setString(pos + offset, "");
>       }
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/BTreeDir.java ../cs4432-proj2/src/simpledb/index/btree/BTreeDir.java
1,117c1,117
< package simpledb.index.btree;
< 
< import simpledb.file.Block;
< import simpledb.tx.Transaction;
< import simpledb.record.TableInfo;
< import simpledb.query.Constant;
< 
< /**
<  * A B-tree directory block.
<  * @author Edward Sciore
<  */
< public class BTreeDir {
<    private TableInfo ti;
<    private Transaction tx;
<    private String filename;
<    private BTreePage contents;
< 
<    /**
<     * Creates an object to hold the contents of the specified
<     * B-tree block.
<     * @param blk a reference to the specified B-tree block
<     * @param ti the metadata of the B-tree directory file
<     * @param tx the calling transaction
<     */
<    BTreeDir(Block blk, TableInfo ti, Transaction tx) {
<       this.ti = ti;
<       this.tx = tx;
<       filename = blk.fileName();
<       contents = new BTreePage(blk, ti, tx);
<    }
< 
<    /**
<     * Closes the directory page.
<     */
<    public void close() {
<       contents.close();
<    }
< 
<    /**
<     * Returns the block number of the B-tree leaf block
<     * that contains the specified search key.
<     * @param searchkey the search key value
<     * @return the block number of the leaf block containing that search key
<     */
<    public int search(Constant searchkey) {
<       Block childblk = findChildBlock(searchkey);
<       while (contents.getFlag() > 0) {
<          contents.close();
<          contents = new BTreePage(childblk, ti, tx);
<          childblk = findChildBlock(searchkey);
<       }
<       return childblk.number();
<    }
< 
<    /**
<     * Creates a new root block for the B-tree.
<     * The new root will have two children:
<     * the old root, and the specified block.
<     * Since the root must always be in block 0 of the file,
<     * the contents of the old root will get transferred to a new block.
<     * @param e the directory entry to be added as a child of the new root
<     */
<    public void makeNewRoot(DirEntry e) {
<       Constant firstval = contents.getDataVal(0);
<       int level = contents.getFlag();
<       Block newblk = contents.split(0, level); //ie, transfer all the records
<       DirEntry oldroot = new DirEntry(firstval, newblk.number());
<       insertEntry(oldroot);
<       insertEntry(e);
<       contents.setFlag(level+1);
<    }
< 
<    /**
<     * Inserts a new directory entry into the B-tree block.
<     * If the block is at level 0, then the entry is inserted there.
<     * Otherwise, the entry is inserted into the appropriate
<     * child node, and the return value is examined.
<     * A non-null return value indicates that the child node
<     * split, and so the returned entry is inserted into
<     * this block.
<     * If this block splits, then the method similarly returns
<     * the entry information of the new block to its caller;
<     * otherwise, the method returns null.
<     * @param e the directory entry to be inserted
<     * @return the directory entry of the newly-split block, if one exists; otherwise, null
<     */
<    public DirEntry insert(DirEntry e) {
<       if (contents.getFlag() == 0)
<          return insertEntry(e);
<       Block childblk = findChildBlock(e.dataVal());
<       BTreeDir child = new BTreeDir(childblk, ti, tx);
<       DirEntry myentry = child.insert(e);
<       child.close();
<       return (myentry != null) ? insertEntry(myentry) : null;
<    }
< 
<    private DirEntry insertEntry(DirEntry e) {
<       int newslot = 1 + contents.findSlotBefore(e.dataVal());
<       contents.insertDir(newslot, e.dataVal(), e.blockNumber());
<       if (!contents.isFull())
<          return null;
<       // else page is full, so split it
<       int level = contents.getFlag();
<       int splitpos = contents.getNumRecs() / 2;
<       Constant splitval = contents.getDataVal(splitpos);
<       Block newblk = contents.split(splitpos, level);
<       return new DirEntry(splitval, newblk.number());
<    }
< 
<    private Block findChildBlock(Constant searchkey) {
<       int slot = contents.findSlotBefore(searchkey);
<       if (contents.getDataVal(slot+1).equals(searchkey))
<          slot++;
<       int blknum = contents.getChildNum(slot);
<       return new Block(filename, blknum);
<    }
< }
---
> package simpledb.index.btree;
> 
> import simpledb.file.Block;
> import simpledb.tx.Transaction;
> import simpledb.record.TableInfo;
> import simpledb.query.Constant;
> 
> /**
>  * A B-tree directory block.
>  * @author Edward Sciore
>  */
> public class BTreeDir {
>    private TableInfo ti;
>    private Transaction tx;
>    private String filename;
>    private BTreePage contents;
> 
>    /**
>     * Creates an object to hold the contents of the specified
>     * B-tree block.
>     * @param blk a reference to the specified B-tree block
>     * @param ti the metadata of the B-tree directory file
>     * @param tx the calling transaction
>     */
>    BTreeDir(Block blk, TableInfo ti, Transaction tx) {
>       this.ti = ti;
>       this.tx = tx;
>       filename = blk.fileName();
>       contents = new BTreePage(blk, ti, tx);
>    }
> 
>    /**
>     * Closes the directory page.
>     */
>    public void close() {
>       contents.close();
>    }
> 
>    /**
>     * Returns the block number of the B-tree leaf block
>     * that contains the specified search key.
>     * @param searchkey the search key value
>     * @return the block number of the leaf block containing that search key
>     */
>    public int search(Constant searchkey) {
>       Block childblk = findChildBlock(searchkey);
>       while (contents.getFlag() > 0) {
>          contents.close();
>          contents = new BTreePage(childblk, ti, tx);
>          childblk = findChildBlock(searchkey);
>       }
>       return childblk.number();
>    }
> 
>    /**
>     * Creates a new root block for the B-tree.
>     * The new root will have two children:
>     * the old root, and the specified block.
>     * Since the root must always be in block 0 of the file,
>     * the contents of the old root will get transferred to a new block.
>     * @param e the directory entry to be added as a child of the new root
>     */
>    public void makeNewRoot(DirEntry e) {
>       Constant firstval = contents.getDataVal(0);
>       int level = contents.getFlag();
>       Block newblk = contents.split(0, level); //ie, transfer all the records
>       DirEntry oldroot = new DirEntry(firstval, newblk.number());
>       insertEntry(oldroot);
>       insertEntry(e);
>       contents.setFlag(level+1);
>    }
> 
>    /**
>     * Inserts a new directory entry into the B-tree block.
>     * If the block is at level 0, then the entry is inserted there.
>     * Otherwise, the entry is inserted into the appropriate
>     * child node, and the return value is examined.
>     * A non-null return value indicates that the child node
>     * split, and so the returned entry is inserted into
>     * this block.
>     * If this block splits, then the method similarly returns
>     * the entry information of the new block to its caller;
>     * otherwise, the method returns null.
>     * @param e the directory entry to be inserted
>     * @return the directory entry of the newly-split block, if one exists; otherwise, null
>     */
>    public DirEntry insert(DirEntry e) {
>       if (contents.getFlag() == 0)
>          return insertEntry(e);
>       Block childblk = findChildBlock(e.dataVal());
>       BTreeDir child = new BTreeDir(childblk, ti, tx);
>       DirEntry myentry = child.insert(e);
>       child.close();
>       return (myentry != null) ? insertEntry(myentry) : null;
>    }
> 
>    private DirEntry insertEntry(DirEntry e) {
>       int newslot = 1 + contents.findSlotBefore(e.dataVal());
>       contents.insertDir(newslot, e.dataVal(), e.blockNumber());
>       if (!contents.isFull())
>          return null;
>       // else page is full, so split it
>       int level = contents.getFlag();
>       int splitpos = contents.getNumRecs() / 2;
>       Constant splitval = contents.getDataVal(splitpos);
>       Block newblk = contents.split(splitpos, level);
>       return new DirEntry(splitval, newblk.number());
>    }
> 
>    private Block findChildBlock(Constant searchkey) {
>       int slot = contents.findSlotBefore(searchkey);
>       if (contents.getDataVal(slot+1).equals(searchkey))
>          slot++;
>       int blknum = contents.getChildNum(slot);
>       return new Block(filename, blknum);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/BTreeIndex.java ../cs4432-proj2/src/simpledb/index/btree/BTreeIndex.java
1,154c1,154
< package simpledb.index.btree;
< 
< import static java.sql.Types.INTEGER;
< import simpledb.file.Block;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /**
<  * A B-tree implementation of the Index interface.
<  * @author Edward Sciore
<  */
< public class BTreeIndex implements Index {
<    private Transaction tx;
<    private TableInfo dirTi, leafTi;
<    private BTreeLeaf leaf = null;
<    private Block rootblk;
< 
<    /**
<     * Opens a B-tree index for the specified index.
<     * The method determines the appropriate files
<     * for the leaf and directory records,
<     * creating them if they did not exist.
<     * @param idxname the name of the index
<     * @param leafsch the schema of the leaf index records
<     * @param tx the calling transaction
<     */
<    public BTreeIndex(String idxname, Schema leafsch, Transaction tx) {
<       this.tx = tx;
<       // deal with the leaves
<       String leaftbl = idxname + "leaf";
<       leafTi = new TableInfo(leaftbl, leafsch);
<       if (tx.size(leafTi.fileName()) == 0)
<          tx.append(leafTi.fileName(), new BTPageFormatter(leafTi, -1));
< 
<       // deal with the directory
<       Schema dirsch = new Schema();
<       dirsch.add("block",   leafsch);
<       dirsch.add("dataval", leafsch);
<       String dirtbl = idxname + "dir";
<       dirTi = new TableInfo(dirtbl, dirsch);
<       rootblk = new Block(dirTi.fileName(), 0);
<       if (tx.size(dirTi.fileName()) == 0)
<          // create new root block
<          tx.append(dirTi.fileName(), new BTPageFormatter(dirTi, 0));
<       BTreePage page = new BTreePage(rootblk, dirTi, tx);
<       if (page.getNumRecs() == 0) {
< 			// insert initial directory entry
<          int fldtype = dirsch.type("dataval");
<          Constant minval = (fldtype == INTEGER) ?
<             new IntConstant(Integer.MIN_VALUE) :
<             new StringConstant("");
<          page.insertDir(0, minval, 0);
< 		}
<       page.close();
<    }
< 
<    /**
<     * Traverses the directory to find the leaf block corresponding
<     * to the specified search key.
<     * The method then opens a page for that leaf block, and
<     * positions the page before the first record (if any)
<     * having that search key.
<     * The leaf page is kept open, for use by the methods next
<     * and getDataRid.
<     * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
<     */
<    public void beforeFirst(Constant searchkey) {
<       close();
<       BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
<       int blknum = root.search(searchkey);
<       root.close();
<       Block leafblk = new Block(leafTi.fileName(), blknum);
<       leaf = new BTreeLeaf(leafblk, leafTi, searchkey, tx);
<    }
< 
<    /**
<     * Moves to the next leaf record having the
<     * previously-specified search key.
<     * Returns false if there are no more such leaf records.
<     * @see simpledb.index.Index#next()
<     */
<    public boolean next() {
<       return leaf.next();
<    }
< 
<    /**
<     * Returns the dataRID value from the current leaf record.
<     * @see simpledb.index.Index#getDataRid()
<     */
<    public RID getDataRid() {
<       return leaf.getDataRid();
<    }
< 
<    /**
<     * Inserts the specified record into the index.
<     * The method first traverses the directory to find
<     * the appropriate leaf page; then it inserts
<     * the record into the leaf.
<     * If the insertion causes the leaf to split, then
<     * the method calls insert on the root,
<     * passing it the directory entry of the new leaf page.
<     * If the root node splits, then makeNewRoot is called.
<     * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
<     */
<    public void insert(Constant dataval, RID datarid) {
<       beforeFirst(dataval);
<       DirEntry e = leaf.insert(datarid);
<       leaf.close();
<       if (e == null)
<          return;
<       BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
<       DirEntry e2 = root.insert(e);
<       if (e2 != null)
<          root.makeNewRoot(e2);
<       root.close();
<    }
< 
<    /**
<     * Deletes the specified index record.
<     * The method first traverses the directory to find
<     * the leaf page containing that record; then it
<     * deletes the record from the page.
<     * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
<     */
<    public void delete(Constant dataval, RID datarid) {
<       beforeFirst(dataval);
<       leaf.delete(datarid);
<       leaf.close();
<    }
< 
<    /**
<     * Closes the index by closing its open leaf page,
<     * if necessary.
<     * @see simpledb.index.Index#close()
<     */
<    public void close() {
<       if (leaf != null)
<          leaf.close();
<    }
< 
<    /**
<     * Estimates the number of block accesses
<     * required to find all index records having
<     * a particular search key.
<     * @param numblocks the number of blocks in the B-tree directory
<     * @param rpb the number of index entries per block
<     * @return the estimated traversal cost
<     */
<    public static int searchCost(int numblocks, int rpb) {
<       return 1 + (int)(Math.log(numblocks) / Math.log(rpb));
<    }
< }
---
> package simpledb.index.btree;
> 
> import static java.sql.Types.INTEGER;
> import simpledb.file.Block;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /**
>  * A B-tree implementation of the Index interface.
>  * @author Edward Sciore
>  */
> public class BTreeIndex implements Index {
>    private Transaction tx;
>    private TableInfo dirTi, leafTi;
>    private BTreeLeaf leaf = null;
>    private Block rootblk;
> 
>    /**
>     * Opens a B-tree index for the specified index.
>     * The method determines the appropriate files
>     * for the leaf and directory records,
>     * creating them if they did not exist.
>     * @param idxname the name of the index
>     * @param leafsch the schema of the leaf index records
>     * @param tx the calling transaction
>     */
>    public BTreeIndex(String idxname, Schema leafsch, Transaction tx) {
>       this.tx = tx;
>       // deal with the leaves
>       String leaftbl = idxname + "leaf";
>       leafTi = new TableInfo(leaftbl, leafsch);
>       if (tx.size(leafTi.fileName()) == 0)
>          tx.append(leafTi.fileName(), new BTPageFormatter(leafTi, -1));
> 
>       // deal with the directory
>       Schema dirsch = new Schema();
>       dirsch.add("block",   leafsch);
>       dirsch.add("dataval", leafsch);
>       String dirtbl = idxname + "dir";
>       dirTi = new TableInfo(dirtbl, dirsch);
>       rootblk = new Block(dirTi.fileName(), 0);
>       if (tx.size(dirTi.fileName()) == 0)
>          // create new root block
>          tx.append(dirTi.fileName(), new BTPageFormatter(dirTi, 0));
>       BTreePage page = new BTreePage(rootblk, dirTi, tx);
>       if (page.getNumRecs() == 0) {
> 			// insert initial directory entry
>          int fldtype = dirsch.type("dataval");
>          Constant minval = (fldtype == INTEGER) ?
>             new IntConstant(Integer.MIN_VALUE) :
>             new StringConstant("");
>          page.insertDir(0, minval, 0);
> 		}
>       page.close();
>    }
> 
>    /**
>     * Traverses the directory to find the leaf block corresponding
>     * to the specified search key.
>     * The method then opens a page for that leaf block, and
>     * positions the page before the first record (if any)
>     * having that search key.
>     * The leaf page is kept open, for use by the methods next
>     * and getDataRid.
>     * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
>     */
>    public void beforeFirst(Constant searchkey) {
>       close();
>       BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
>       int blknum = root.search(searchkey);
>       root.close();
>       Block leafblk = new Block(leafTi.fileName(), blknum);
>       leaf = new BTreeLeaf(leafblk, leafTi, searchkey, tx);
>    }
> 
>    /**
>     * Moves to the next leaf record having the
>     * previously-specified search key.
>     * Returns false if there are no more such leaf records.
>     * @see simpledb.index.Index#next()
>     */
>    public boolean next() {
>       return leaf.next();
>    }
> 
>    /**
>     * Returns the dataRID value from the current leaf record.
>     * @see simpledb.index.Index#getDataRid()
>     */
>    public RID getDataRid() {
>       return leaf.getDataRid();
>    }
> 
>    /**
>     * Inserts the specified record into the index.
>     * The method first traverses the directory to find
>     * the appropriate leaf page; then it inserts
>     * the record into the leaf.
>     * If the insertion causes the leaf to split, then
>     * the method calls insert on the root,
>     * passing it the directory entry of the new leaf page.
>     * If the root node splits, then makeNewRoot is called.
>     * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
>     */
>    public void insert(Constant dataval, RID datarid) {
>       beforeFirst(dataval);
>       DirEntry e = leaf.insert(datarid);
>       leaf.close();
>       if (e == null)
>          return;
>       BTreeDir root = new BTreeDir(rootblk, dirTi, tx);
>       DirEntry e2 = root.insert(e);
>       if (e2 != null)
>          root.makeNewRoot(e2);
>       root.close();
>    }
> 
>    /**
>     * Deletes the specified index record.
>     * The method first traverses the directory to find
>     * the leaf page containing that record; then it
>     * deletes the record from the page.
>     * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
>     */
>    public void delete(Constant dataval, RID datarid) {
>       beforeFirst(dataval);
>       leaf.delete(datarid);
>       leaf.close();
>    }
> 
>    /**
>     * Closes the index by closing its open leaf page,
>     * if necessary.
>     * @see simpledb.index.Index#close()
>     */
>    public void close() {
>       if (leaf != null)
>          leaf.close();
>    }
> 
>    /**
>     * Estimates the number of block accesses
>     * required to find all index records having
>     * a particular search key.
>     * @param numblocks the number of blocks in the B-tree directory
>     * @param rpb the number of index entries per block
>     * @return the estimated traversal cost
>     */
>    public static int searchCost(int numblocks, int rpb) {
>       return 1 + (int)(Math.log(numblocks) / Math.log(rpb));
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/BTreeLeaf.java ../cs4432-proj2/src/simpledb/index/btree/BTreeLeaf.java
1,149c1,149
< package simpledb.index.btree;
< 
< import simpledb.file.Block;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.Constant;
< 
< /**
<  * An object that holds the contents of a B-tree leaf block.
<  * @author Edward Sciore
<  */
< public class BTreeLeaf {
<    private TableInfo ti;
<    private Transaction tx;
<    private Constant searchkey;
<    private BTreePage contents;
<    private int currentslot;
<    
<    /**
<     * Opens a page to hold the specified leaf block.
<     * The page is positioned immediately before the first record
<     * having the specified search key (if any).
<     * @param blk a reference to the disk block
<     * @param ti the metadata of the B-tree leaf file
<     * @param searchkey the search key value
<     * @param tx the calling transaction
<     */
<    public BTreeLeaf(Block blk, TableInfo ti, Constant searchkey, Transaction tx) {
<       this.ti = ti;
<       this.tx = tx;
<       this.searchkey = searchkey;
<       contents = new BTreePage(blk, ti, tx);
<       currentslot = contents.findSlotBefore(searchkey);
<    }
<    
<    /**
<     * Closes the leaf page.
<     */
<    public void close() {
<       contents.close();
<    }
<    
<    /**
<     * Moves to the next leaf record having the 
<     * previously-specified search key.
<     * Returns false if there is no more such records.
<     * @return false if there are no more leaf records for the search key
<     */
<    public boolean next() {
<       currentslot++;
<       if (currentslot >= contents.getNumRecs()) 
<          return tryOverflow();
<       else if (contents.getDataVal(currentslot).equals(searchkey))
<          return true;
<       else 
<          return tryOverflow();
<    }
<    
<    /**
<     * Returns the dataRID value of the current leaf record.
<     * @return the dataRID of the current record
<     */
<    public RID getDataRid() {
<       return contents.getDataRid(currentslot);
<    }
<    
<    /**
<     * Deletes the leaf record having the specified dataRID
<     * @param datarid the dataRId whose record is to be deleted
<     */
<    public void delete(RID datarid) {
<       while(next())
<          if(getDataRid().equals(datarid)) {
<          contents.delete(currentslot);
<          return;
<       }
<    }
<    
<    /**
<     * Inserts a new leaf record having the specified dataRID
<     * and the previously-specified search key.
<     * If the record does not fit in the page, then 
<     * the page splits and the method returns the
<     * directory entry for the new page;
<     * otherwise, the method returns null.  
<     * If all of the records in the page have the same dataval,
<     * then the block does not split; instead, all but one of the
<     * records are placed into an overflow block.
<     * @param datarid the dataRID value of the new record
<     * @return the directory entry of the newly-split page, if one exists.
<     */
<    public DirEntry insert(RID datarid) {
<    	// bug fix:  If the page has an overflow page 
<    	// and the searchkey of the new record would be lowest in its page, 
<    	// we need to first move the entire contents of that page to a new block
<    	// and then insert the new record in the now-empty current page.
<    	if (contents.getFlag() >= 0 && contents.getDataVal(0).compareTo(searchkey) > 0) {
<    		Constant firstval = contents.getDataVal(0);
<    		Block newblk = contents.split(0, contents.getFlag());
<    		currentslot = 0;
<    		contents.setFlag(-1);
<    		contents.insertLeaf(currentslot, searchkey, datarid); 
<    		return new DirEntry(firstval, newblk.number());  
<    	}
< 	  
<       currentslot++;
<       contents.insertLeaf(currentslot, searchkey, datarid);
<       if (!contents.isFull())
<          return null;
<       // else page is full, so split it
<       Constant firstkey = contents.getDataVal(0);
<       Constant lastkey  = contents.getDataVal(contents.getNumRecs()-1);
<       if (lastkey.equals(firstkey)) {
<          // create an overflow block to hold all but the first record
<          Block newblk = contents.split(1, contents.getFlag());
<          contents.setFlag(newblk.number());
<          return null;
<       }
<       else {
<          int splitpos = contents.getNumRecs() / 2;
<          Constant splitkey = contents.getDataVal(splitpos);
<          if (splitkey.equals(firstkey)) {
<             // move right, looking for the next key
<             while (contents.getDataVal(splitpos).equals(splitkey))
<                splitpos++;
<             splitkey = contents.getDataVal(splitpos);
<          }
<          else {
<             // move left, looking for first entry having that key
<             while (contents.getDataVal(splitpos-1).equals(splitkey))
<                splitpos--;
<          }
<          Block newblk = contents.split(splitpos, -1);
<          return new DirEntry(splitkey, newblk.number());
<       }
<    }
<    
<    private boolean tryOverflow() {
<       Constant firstkey = contents.getDataVal(0);
<       int flag = contents.getFlag();
<       if (!searchkey.equals(firstkey) || flag < 0)
<          return false;
<       contents.close();
<       Block nextblk = new Block(ti.fileName(), flag);
<       contents = new BTreePage(nextblk, ti, tx);
<       currentslot = 0;
<       return true;
<    }
< }
---
> package simpledb.index.btree;
> 
> import simpledb.file.Block;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.Constant;
> 
> /**
>  * An object that holds the contents of a B-tree leaf block.
>  * @author Edward Sciore
>  */
> public class BTreeLeaf {
>    private TableInfo ti;
>    private Transaction tx;
>    private Constant searchkey;
>    private BTreePage contents;
>    private int currentslot;
>    
>    /**
>     * Opens a page to hold the specified leaf block.
>     * The page is positioned immediately before the first record
>     * having the specified search key (if any).
>     * @param blk a reference to the disk block
>     * @param ti the metadata of the B-tree leaf file
>     * @param searchkey the search key value
>     * @param tx the calling transaction
>     */
>    public BTreeLeaf(Block blk, TableInfo ti, Constant searchkey, Transaction tx) {
>       this.ti = ti;
>       this.tx = tx;
>       this.searchkey = searchkey;
>       contents = new BTreePage(blk, ti, tx);
>       currentslot = contents.findSlotBefore(searchkey);
>    }
>    
>    /**
>     * Closes the leaf page.
>     */
>    public void close() {
>       contents.close();
>    }
>    
>    /**
>     * Moves to the next leaf record having the 
>     * previously-specified search key.
>     * Returns false if there is no more such records.
>     * @return false if there are no more leaf records for the search key
>     */
>    public boolean next() {
>       currentslot++;
>       if (currentslot >= contents.getNumRecs()) 
>          return tryOverflow();
>       else if (contents.getDataVal(currentslot).equals(searchkey))
>          return true;
>       else 
>          return tryOverflow();
>    }
>    
>    /**
>     * Returns the dataRID value of the current leaf record.
>     * @return the dataRID of the current record
>     */
>    public RID getDataRid() {
>       return contents.getDataRid(currentslot);
>    }
>    
>    /**
>     * Deletes the leaf record having the specified dataRID
>     * @param datarid the dataRId whose record is to be deleted
>     */
>    public void delete(RID datarid) {
>       while(next())
>          if(getDataRid().equals(datarid)) {
>          contents.delete(currentslot);
>          return;
>       }
>    }
>    
>    /**
>     * Inserts a new leaf record having the specified dataRID
>     * and the previously-specified search key.
>     * If the record does not fit in the page, then 
>     * the page splits and the method returns the
>     * directory entry for the new page;
>     * otherwise, the method returns null.  
>     * If all of the records in the page have the same dataval,
>     * then the block does not split; instead, all but one of the
>     * records are placed into an overflow block.
>     * @param datarid the dataRID value of the new record
>     * @return the directory entry of the newly-split page, if one exists.
>     */
>    public DirEntry insert(RID datarid) {
>    	// bug fix:  If the page has an overflow page 
>    	// and the searchkey of the new record would be lowest in its page, 
>    	// we need to first move the entire contents of that page to a new block
>    	// and then insert the new record in the now-empty current page.
>    	if (contents.getFlag() >= 0 && contents.getDataVal(0).compareTo(searchkey) > 0) {
>    		Constant firstval = contents.getDataVal(0);
>    		Block newblk = contents.split(0, contents.getFlag());
>    		currentslot = 0;
>    		contents.setFlag(-1);
>    		contents.insertLeaf(currentslot, searchkey, datarid); 
>    		return new DirEntry(firstval, newblk.number());  
>    	}
> 	  
>       currentslot++;
>       contents.insertLeaf(currentslot, searchkey, datarid);
>       if (!contents.isFull())
>          return null;
>       // else page is full, so split it
>       Constant firstkey = contents.getDataVal(0);
>       Constant lastkey  = contents.getDataVal(contents.getNumRecs()-1);
>       if (lastkey.equals(firstkey)) {
>          // create an overflow block to hold all but the first record
>          Block newblk = contents.split(1, contents.getFlag());
>          contents.setFlag(newblk.number());
>          return null;
>       }
>       else {
>          int splitpos = contents.getNumRecs() / 2;
>          Constant splitkey = contents.getDataVal(splitpos);
>          if (splitkey.equals(firstkey)) {
>             // move right, looking for the next key
>             while (contents.getDataVal(splitpos).equals(splitkey))
>                splitpos++;
>             splitkey = contents.getDataVal(splitpos);
>          }
>          else {
>             // move left, looking for first entry having that key
>             while (contents.getDataVal(splitpos-1).equals(splitkey))
>                splitpos--;
>          }
>          Block newblk = contents.split(splitpos, -1);
>          return new DirEntry(splitkey, newblk.number());
>       }
>    }
>    
>    private boolean tryOverflow() {
>       Constant firstkey = contents.getDataVal(0);
>       int flag = contents.getFlag();
>       if (!searchkey.equals(firstkey) || flag < 0)
>          return false;
>       contents.close();
>       Block nextblk = new Block(ti.fileName(), flag);
>       contents = new BTreePage(nextblk, ti, tx);
>       currentslot = 0;
>       return true;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/BTreePage.java ../cs4432-proj2/src/simpledb/index/btree/BTreePage.java
1,261c1,261
< package simpledb.index.btree;
< 
< import static java.sql.Types.INTEGER;
< import static simpledb.file.Page.*;
< import simpledb.file.Block;
< import simpledb.record.*;
< import simpledb.query.*;
< import simpledb.tx.Transaction;
< 
< /**
<  * B-tree directory and leaf pages have many commonalities:
<  * in particular, their records are stored in sorted order, 
<  * and pages split when full.
<  * A BTreePage object contains this common functionality.
<  * @author Edward Sciore
<  */
< public class BTreePage {
<    private Block currentblk;
<    private TableInfo ti;
<    private Transaction tx;
<    private int slotsize;
<    
<    /**
<     * Opens a page for the specified B-tree block.
<     * @param currentblk a reference to the B-tree block
<     * @param ti the metadata for the particular B-tree file
<     * @param tx the calling transaction
<     */
<    public BTreePage(Block currentblk, TableInfo ti, Transaction tx) {
<       this.currentblk = currentblk;
<       this.ti = ti;
<       this.tx = tx;
<       slotsize = ti.recordLength();
<       tx.pin(currentblk);
<    }
<    
<    /**
<     * Calculates the position where the first record having
<     * the specified search key should be, then returns
<     * the position before it.
<     * @param searchkey the search key
<     * @return the position before where the search key goes
<     */
<    public int findSlotBefore(Constant searchkey) {
<       int slot = 0;
<       while (slot < getNumRecs() && getDataVal(slot).compareTo(searchkey) < 0)
<          slot++;
<       return slot-1;
<    }
<    
<    /**
<     * Closes the page by unpinning its buffer.
<     */
<    public void close() {
<       if (currentblk != null)
<          tx.unpin(currentblk);
<       currentblk = null;
<    }
<    
<    /**
<     * Returns true if the block is full.
<     * @return true if the block is full
<     */
<    public boolean isFull() {
<       return slotpos(getNumRecs()+1) >= BLOCK_SIZE;
<    }
<    
<    /**
<     * Splits the page at the specified position.
<     * A new page is created, and the records of the page
<     * starting at the split position are transferred to the new page.
<     * @param splitpos the split position
<     * @param flag the initial value of the flag field
<     * @return the reference to the new block
<     */
<    public Block split(int splitpos, int flag) {
<       Block newblk = appendNew(flag);
<       BTreePage newpage = new BTreePage(newblk, ti, tx);
<       transferRecs(splitpos, newpage);
<       newpage.setFlag(flag);
<       newpage.close();
<       return newblk;
<    }
<    
<    /**
<     * Returns the dataval of the record at the specified slot.
<     * @param slot the integer slot of an index record
<     * @return the dataval of the record at that slot
<     */
<    public Constant getDataVal(int slot) {
<       return getVal(slot, "dataval");
<    }
<    
<    /**
<     * Returns the value of the page's flag field
<     * @return the value of the page's flag field
<     */
<    public int getFlag() {
<       return tx.getInt(currentblk, 0);
<    }
<    
<    /**
<     * Sets the page's flag field to the specified value
<     * @param val the new value of the page flag
<     */
<    public void setFlag(int val) {
<       tx.setInt(currentblk, 0, val);
<    }
<    
<    /**
<     * Appends a new block to the end of the specified B-tree file,
<     * having the specified flag value.
<     * @param flag the initial value of the flag
<     * @return a reference to the newly-created block
<     */
<    public Block appendNew(int flag) {
<       return tx.append(ti.fileName(), new BTPageFormatter(ti, flag));
<    }
<    
<    // Methods called only by BTreeDir
<    
<    /**
<     * Returns the block number stored in the index record 
<     * at the specified slot.
<     * @param slot the slot of an index record
<     * @return the block number stored in that record
<     */
<    public int getChildNum(int slot) {
<       return getInt(slot, "block");
<    }
<    
<    /**
<     * Inserts a directory entry at the specified slot.
<     * @param slot the slot of an index record
<     * @param val the dataval to be stored
<     * @param blknum the block number to be stored
<     */
<    public void insertDir(int slot, Constant val, int blknum) {
<       insert(slot);
<       setVal(slot, "dataval", val);
<       setInt(slot, "block", blknum);
<    }
<    
<    // Methods called only by BTreeLeaf
<    
<    /**
<     * Returns the dataRID value stored in the specified leaf index record.
<     * @param slot the slot of the desired index record
<     * @return the dataRID value store at that slot
<     */
<    public RID getDataRid(int slot) {
<       return new RID(getInt(slot, "block"), getInt(slot, "id"));
<    }
<    
<    /**
<     * Inserts a leaf index record at the specified slot.
<     * @param slot the slot of the desired index record
<     * @param val the new dataval
<     * @param rid the new dataRID
<     */
<    public void insertLeaf(int slot, Constant val, RID rid) {
<       insert(slot);
<       setVal(slot, "dataval", val);
<       setInt(slot, "block", rid.blockNumber());
<       setInt(slot, "id", rid.id());
<    }
<    
<    /**
<     * Deletes the index record at the specified slot.
<     * @param slot the slot of the deleted index record
<     */
<    public void delete(int slot) {
<       for (int i=slot+1; i<getNumRecs(); i++)
<          copyRecord(i, i-1);
<       setNumRecs(getNumRecs()-1);
<       return;
<    }
<    
<    /**
<     * Returns the number of index records in this page.
<     * @return the number of index records in this page
<     */
<    public int getNumRecs() {
<       return tx.getInt(currentblk, INT_SIZE);
<    }
<    
<    // Private methods
<    
<    private int getInt(int slot, String fldname) {
<       int pos = fldpos(slot, fldname);
<       return tx.getInt(currentblk, pos);
<    }
<    
<    private String getString(int slot, String fldname) {
<       int pos = fldpos(slot, fldname);
<       return tx.getString(currentblk, pos);
<    }
<    
<    private Constant getVal(int slot, String fldname) {
<       int type = ti.schema().type(fldname);
<       if (type == INTEGER)
<          return new IntConstant(getInt(slot, fldname));
<       else
<          return new StringConstant(getString(slot, fldname));
<    }
<    
<    private void setInt(int slot, String fldname, int val) {
<       int pos = fldpos(slot, fldname);
<       tx.setInt(currentblk, pos, val);
<    }
<    
<    private void setString(int slot, String fldname, String val) {
<       int pos = fldpos(slot, fldname);
<       tx.setString(currentblk, pos, val);
<    }
<    
<    private void setVal(int slot, String fldname, Constant val) {
<       int type = ti.schema().type(fldname);
<       if (type == INTEGER)
<          setInt(slot, fldname, (Integer)val.asJavaVal());
<       else
<          setString(slot, fldname, (String)val.asJavaVal());
<    }
<    
<    private void setNumRecs(int n) {
<       tx.setInt(currentblk, INT_SIZE, n);
<    }
<    
<    private void insert(int slot) {
<       for (int i=getNumRecs(); i>slot; i--)
<          copyRecord(i-1, i);
<       setNumRecs(getNumRecs()+1);
<    }
<    
<    private void copyRecord(int from, int to) {
<       Schema sch = ti.schema();
<       for (String fldname : sch.fields())
<          setVal(to, fldname, getVal(from, fldname));
<    }
<    
<    private void transferRecs(int slot, BTreePage dest) {
<       int destslot = 0;
<       while (slot < getNumRecs()) {
<          dest.insert(destslot);
<          Schema sch = ti.schema();
<          for (String fldname : sch.fields())
<             dest.setVal(destslot, fldname, getVal(slot, fldname));
<          delete(slot);
<          destslot++;
<       }
<    }
<    
<    private int fldpos(int slot, String fldname) {
<       int offset = ti.offset(fldname);
<       return slotpos(slot) + offset;
<    }
<    
<    private int slotpos(int slot) {
<       return INT_SIZE + INT_SIZE + (slot * slotsize);
<    }
< }
---
> package simpledb.index.btree;
> 
> import static java.sql.Types.INTEGER;
> import static simpledb.file.Page.*;
> import simpledb.file.Block;
> import simpledb.record.*;
> import simpledb.query.*;
> import simpledb.tx.Transaction;
> 
> /**
>  * B-tree directory and leaf pages have many commonalities:
>  * in particular, their records are stored in sorted order, 
>  * and pages split when full.
>  * A BTreePage object contains this common functionality.
>  * @author Edward Sciore
>  */
> public class BTreePage {
>    private Block currentblk;
>    private TableInfo ti;
>    private Transaction tx;
>    private int slotsize;
>    
>    /**
>     * Opens a page for the specified B-tree block.
>     * @param currentblk a reference to the B-tree block
>     * @param ti the metadata for the particular B-tree file
>     * @param tx the calling transaction
>     */
>    public BTreePage(Block currentblk, TableInfo ti, Transaction tx) {
>       this.currentblk = currentblk;
>       this.ti = ti;
>       this.tx = tx;
>       slotsize = ti.recordLength();
>       tx.pin(currentblk);
>    }
>    
>    /**
>     * Calculates the position where the first record having
>     * the specified search key should be, then returns
>     * the position before it.
>     * @param searchkey the search key
>     * @return the position before where the search key goes
>     */
>    public int findSlotBefore(Constant searchkey) {
>       int slot = 0;
>       while (slot < getNumRecs() && getDataVal(slot).compareTo(searchkey) < 0)
>          slot++;
>       return slot-1;
>    }
>    
>    /**
>     * Closes the page by unpinning its buffer.
>     */
>    public void close() {
>       if (currentblk != null)
>          tx.unpin(currentblk);
>       currentblk = null;
>    }
>    
>    /**
>     * Returns true if the block is full.
>     * @return true if the block is full
>     */
>    public boolean isFull() {
>       return slotpos(getNumRecs()+1) >= BLOCK_SIZE;
>    }
>    
>    /**
>     * Splits the page at the specified position.
>     * A new page is created, and the records of the page
>     * starting at the split position are transferred to the new page.
>     * @param splitpos the split position
>     * @param flag the initial value of the flag field
>     * @return the reference to the new block
>     */
>    public Block split(int splitpos, int flag) {
>       Block newblk = appendNew(flag);
>       BTreePage newpage = new BTreePage(newblk, ti, tx);
>       transferRecs(splitpos, newpage);
>       newpage.setFlag(flag);
>       newpage.close();
>       return newblk;
>    }
>    
>    /**
>     * Returns the dataval of the record at the specified slot.
>     * @param slot the integer slot of an index record
>     * @return the dataval of the record at that slot
>     */
>    public Constant getDataVal(int slot) {
>       return getVal(slot, "dataval");
>    }
>    
>    /**
>     * Returns the value of the page's flag field
>     * @return the value of the page's flag field
>     */
>    public int getFlag() {
>       return tx.getInt(currentblk, 0);
>    }
>    
>    /**
>     * Sets the page's flag field to the specified value
>     * @param val the new value of the page flag
>     */
>    public void setFlag(int val) {
>       tx.setInt(currentblk, 0, val);
>    }
>    
>    /**
>     * Appends a new block to the end of the specified B-tree file,
>     * having the specified flag value.
>     * @param flag the initial value of the flag
>     * @return a reference to the newly-created block
>     */
>    public Block appendNew(int flag) {
>       return tx.append(ti.fileName(), new BTPageFormatter(ti, flag));
>    }
>    
>    // Methods called only by BTreeDir
>    
>    /**
>     * Returns the block number stored in the index record 
>     * at the specified slot.
>     * @param slot the slot of an index record
>     * @return the block number stored in that record
>     */
>    public int getChildNum(int slot) {
>       return getInt(slot, "block");
>    }
>    
>    /**
>     * Inserts a directory entry at the specified slot.
>     * @param slot the slot of an index record
>     * @param val the dataval to be stored
>     * @param blknum the block number to be stored
>     */
>    public void insertDir(int slot, Constant val, int blknum) {
>       insert(slot);
>       setVal(slot, "dataval", val);
>       setInt(slot, "block", blknum);
>    }
>    
>    // Methods called only by BTreeLeaf
>    
>    /**
>     * Returns the dataRID value stored in the specified leaf index record.
>     * @param slot the slot of the desired index record
>     * @return the dataRID value store at that slot
>     */
>    public RID getDataRid(int slot) {
>       return new RID(getInt(slot, "block"), getInt(slot, "id"));
>    }
>    
>    /**
>     * Inserts a leaf index record at the specified slot.
>     * @param slot the slot of the desired index record
>     * @param val the new dataval
>     * @param rid the new dataRID
>     */
>    public void insertLeaf(int slot, Constant val, RID rid) {
>       insert(slot);
>       setVal(slot, "dataval", val);
>       setInt(slot, "block", rid.blockNumber());
>       setInt(slot, "id", rid.id());
>    }
>    
>    /**
>     * Deletes the index record at the specified slot.
>     * @param slot the slot of the deleted index record
>     */
>    public void delete(int slot) {
>       for (int i=slot+1; i<getNumRecs(); i++)
>          copyRecord(i, i-1);
>       setNumRecs(getNumRecs()-1);
>       return;
>    }
>    
>    /**
>     * Returns the number of index records in this page.
>     * @return the number of index records in this page
>     */
>    public int getNumRecs() {
>       return tx.getInt(currentblk, INT_SIZE);
>    }
>    
>    // Private methods
>    
>    private int getInt(int slot, String fldname) {
>       int pos = fldpos(slot, fldname);
>       return tx.getInt(currentblk, pos);
>    }
>    
>    private String getString(int slot, String fldname) {
>       int pos = fldpos(slot, fldname);
>       return tx.getString(currentblk, pos);
>    }
>    
>    private Constant getVal(int slot, String fldname) {
>       int type = ti.schema().type(fldname);
>       if (type == INTEGER)
>          return new IntConstant(getInt(slot, fldname));
>       else
>          return new StringConstant(getString(slot, fldname));
>    }
>    
>    private void setInt(int slot, String fldname, int val) {
>       int pos = fldpos(slot, fldname);
>       tx.setInt(currentblk, pos, val);
>    }
>    
>    private void setString(int slot, String fldname, String val) {
>       int pos = fldpos(slot, fldname);
>       tx.setString(currentblk, pos, val);
>    }
>    
>    private void setVal(int slot, String fldname, Constant val) {
>       int type = ti.schema().type(fldname);
>       if (type == INTEGER)
>          setInt(slot, fldname, (Integer)val.asJavaVal());
>       else
>          setString(slot, fldname, (String)val.asJavaVal());
>    }
>    
>    private void setNumRecs(int n) {
>       tx.setInt(currentblk, INT_SIZE, n);
>    }
>    
>    private void insert(int slot) {
>       for (int i=getNumRecs(); i>slot; i--)
>          copyRecord(i-1, i);
>       setNumRecs(getNumRecs()+1);
>    }
>    
>    private void copyRecord(int from, int to) {
>       Schema sch = ti.schema();
>       for (String fldname : sch.fields())
>          setVal(to, fldname, getVal(from, fldname));
>    }
>    
>    private void transferRecs(int slot, BTreePage dest) {
>       int destslot = 0;
>       while (slot < getNumRecs()) {
>          dest.insert(destslot);
>          Schema sch = ti.schema();
>          for (String fldname : sch.fields())
>             dest.setVal(destslot, fldname, getVal(slot, fldname));
>          delete(slot);
>          destslot++;
>       }
>    }
>    
>    private int fldpos(int slot, String fldname) {
>       int offset = ti.offset(fldname);
>       return slotpos(slot) + offset;
>    }
>    
>    private int slotpos(int slot) {
>       return INT_SIZE + INT_SIZE + (slot * slotsize);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/btree/DirEntry.java ../cs4432-proj2/src/simpledb/index/btree/DirEntry.java
1,40c1,40
< package simpledb.index.btree;
< 
< import simpledb.query.Constant;
< 
< /**
<  * A directory entry has two components: the number of the child block,
<  * and the dataval of the first record in that block.
<  * @author Edward Sciore
<  */
< public class DirEntry {
<    private Constant dataval;
<    private int blocknum;
<    
<    /**
<     * Creates a new entry for the specified dataval and block number.
<     * @param dataval the dataval
<     * @param blocknum the block number
<     */
<    public DirEntry(Constant dataval, int blocknum) {
<       this.dataval  = dataval;
<       this.blocknum = blocknum;
<    }
<    
<    /**
<     * Returns the dataval component of the entry
<     * @return the dataval component of the entry
<     */
<    public Constant dataVal() {
<       return dataval;
<    }
<    
<    /**
<     * Returns the block number component of the entry
<     * @return the block number component of the entry
<     */
<    public int blockNumber() {
<       return blocknum;
<    }
< }
< 
---
> package simpledb.index.btree;
> 
> import simpledb.query.Constant;
> 
> /**
>  * A directory entry has two components: the number of the child block,
>  * and the dataval of the first record in that block.
>  * @author Edward Sciore
>  */
> public class DirEntry {
>    private Constant dataval;
>    private int blocknum;
>    
>    /**
>     * Creates a new entry for the specified dataval and block number.
>     * @param dataval the dataval
>     * @param blocknum the block number
>     */
>    public DirEntry(Constant dataval, int blocknum) {
>       this.dataval  = dataval;
>       this.blocknum = blocknum;
>    }
>    
>    /**
>     * Returns the dataval component of the entry
>     * @return the dataval component of the entry
>     */
>    public Constant dataVal() {
>       return dataval;
>    }
>    
>    /**
>     * Returns the block number component of the entry
>     * @return the block number component of the entry
>     */
>    public int blockNumber() {
>       return blocknum;
>    }
> }
> 
Only in ../cs4432-proj2/src/simpledb/index/hash: ExtensibleHashIndex.java
diff -r simpledb/SimpleDB_2.10/simpledb/index/hash/HashIndex.java ../cs4432-proj2/src/simpledb/index/hash/HashIndex.java
1,127c1,127
< package simpledb.index.hash;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /**
<  * A static hash implementation of the Index interface.
<  * A fixed number of buckets is allocated (currently, 100),
<  * and each bucket is implemented as a file of index records.
<  * @author Edward Sciore
<  */
< public class HashIndex implements Index {
< 	public static int NUM_BUCKETS = 100;
< 	private String idxname;
< 	private Schema sch;
< 	private Transaction tx;
< 	private Constant searchkey = null;
< 	private TableScan ts = null;
< 
< 	/**
< 	 * Opens a hash index for the specified index.
< 	 * @param idxname the name of the index
< 	 * @param sch the schema of the index records
< 	 * @param tx the calling transaction
< 	 */
< 	public HashIndex(String idxname, Schema sch, Transaction tx) {
< 		this.idxname = idxname;
< 		this.sch = sch;
< 		this.tx = tx;
< 	}
< 
< 	/**
< 	 * Positions the index before the first index record
< 	 * having the specified search key.
< 	 * The method hashes the search key to determine the bucket,
< 	 * and then opens a table scan on the file
< 	 * corresponding to the bucket.
< 	 * The table scan for the previous bucket (if any) is closed.
< 	 * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
< 	 */
< 	public void beforeFirst(Constant searchkey) {
< 		close();
< 		this.searchkey = searchkey;
< 		int bucket = searchkey.hashCode() % NUM_BUCKETS;
< 		String tblname = idxname + bucket;
< 		TableInfo ti = new TableInfo(tblname, sch);
< 		ts = new TableScan(ti, tx);
< 	}
< 
< 	/**
< 	 * Moves to the next record having the search key.
< 	 * The method loops through the table scan for the bucket,
< 	 * looking for a matching record, and returning false
< 	 * if there are no more such records.
< 	 * @see simpledb.index.Index#next()
< 	 */
< 	public boolean next() {
< 		while (ts.next())
< 			if (ts.getVal("dataval").equals(searchkey))
< 				return true;
< 		return false;
< 	}
< 
< 	/**
< 	 * Retrieves the dataRID from the current record
< 	 * in the table scan for the bucket.
< 	 * @see simpledb.index.Index#getDataRid()
< 	 */
< 	public RID getDataRid() {
< 		int blknum = ts.getInt("block");
< 		int id = ts.getInt("id");
< 		return new RID(blknum, id);
< 	}
< 
< 	/**
< 	 * Inserts a new record into the table scan for the bucket.
< 	 * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
< 	 */
< 	public void insert(Constant val, RID rid) {
< 		beforeFirst(val);
< 		ts.insert();
< 		ts.setInt("block", rid.blockNumber());
< 		ts.setInt("id", rid.id());
< 		ts.setVal("dataval", val);
< 	}
< 
< 	/**
< 	 * Deletes the specified record from the table scan for
< 	 * the bucket.  The method starts at the beginning of the
< 	 * scan, and loops through the records until the
< 	 * specified record is found.
< 	 * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
< 	 */
< 	public void delete(Constant val, RID rid) {
< 		beforeFirst(val);
< 		while(next())
< 			if (getDataRid().equals(rid)) {
< 				ts.delete();
< 				return;
< 			}
< 	}
< 
< 	/**
< 	 * Closes the index by closing the current table scan.
< 	 * @see simpledb.index.Index#close()
< 	 */
< 	public void close() {
< 		if (ts != null)
< 			ts.close();
< 	}
< 
< 	/**
< 	 * Returns the cost of searching an index file having the
< 	 * specified number of blocks.
< 	 * The method assumes that all buckets are about the
< 	 * same size, and so the cost is simply the size of
< 	 * the bucket.
< 	 * @param numblocks the number of blocks of index records
< 	 * @param rpb the number of records per block (not used here)
< 	 * @return the cost of traversing the index
< 	 */
< 	public static int searchCost(int numblocks, int rpb){
< 		return numblocks / HashIndex.NUM_BUCKETS;
< 	}
< }
---
> package simpledb.index.hash;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /**
>  * A static hash implementation of the Index interface.
>  * A fixed number of buckets is allocated (currently, 100),
>  * and each bucket is implemented as a file of index records.
>  * @author Edward Sciore
>  */
> public class HashIndex implements Index {
> 	public static int NUM_BUCKETS = 100;
> 	private String idxname;
> 	private Schema sch;
> 	private Transaction tx;
> 	private Constant searchkey = null;
> 	private TableScan ts = null;
> 
> 	/**
> 	 * Opens a hash index for the specified index.
> 	 * @param idxname the name of the index
> 	 * @param sch the schema of the index records
> 	 * @param tx the calling transaction
> 	 */
> 	public HashIndex(String idxname, Schema sch, Transaction tx) {
> 		this.idxname = idxname;
> 		this.sch = sch;
> 		this.tx = tx;
> 	}
> 
> 	/**
> 	 * Positions the index before the first index record
> 	 * having the specified search key.
> 	 * The method hashes the search key to determine the bucket,
> 	 * and then opens a table scan on the file
> 	 * corresponding to the bucket.
> 	 * The table scan for the previous bucket (if any) is closed.
> 	 * @see simpledb.index.Index#beforeFirst(simpledb.query.Constant)
> 	 */
> 	public void beforeFirst(Constant searchkey) {
> 		close();
> 		this.searchkey = searchkey;
> 		int bucket = searchkey.hashCode() % NUM_BUCKETS;
> 		String tblname = idxname + bucket;
> 		TableInfo ti = new TableInfo(tblname, sch);
> 		ts = new TableScan(ti, tx);
> 	}
> 
> 	/**
> 	 * Moves to the next record having the search key.
> 	 * The method loops through the table scan for the bucket,
> 	 * looking for a matching record, and returning false
> 	 * if there are no more such records.
> 	 * @see simpledb.index.Index#next()
> 	 */
> 	public boolean next() {
> 		while (ts.next())
> 			if (ts.getVal("dataval").equals(searchkey))
> 				return true;
> 		return false;
> 	}
> 
> 	/**
> 	 * Retrieves the dataRID from the current record
> 	 * in the table scan for the bucket.
> 	 * @see simpledb.index.Index#getDataRid()
> 	 */
> 	public RID getDataRid() {
> 		int blknum = ts.getInt("block");
> 		int id = ts.getInt("id");
> 		return new RID(blknum, id);
> 	}
> 
> 	/**
> 	 * Inserts a new record into the table scan for the bucket.
> 	 * @see simpledb.index.Index#insert(simpledb.query.Constant, simpledb.record.RID)
> 	 */
> 	public void insert(Constant val, RID rid) {
> 		beforeFirst(val);
> 		ts.insert();
> 		ts.setInt("block", rid.blockNumber());
> 		ts.setInt("id", rid.id());
> 		ts.setVal("dataval", val);
> 	}
> 
> 	/**
> 	 * Deletes the specified record from the table scan for
> 	 * the bucket.  The method starts at the beginning of the
> 	 * scan, and loops through the records until the
> 	 * specified record is found.
> 	 * @see simpledb.index.Index#delete(simpledb.query.Constant, simpledb.record.RID)
> 	 */
> 	public void delete(Constant val, RID rid) {
> 		beforeFirst(val);
> 		while(next())
> 			if (getDataRid().equals(rid)) {
> 				ts.delete();
> 				return;
> 			}
> 	}
> 
> 	/**
> 	 * Closes the index by closing the current table scan.
> 	 * @see simpledb.index.Index#close()
> 	 */
> 	public void close() {
> 		if (ts != null)
> 			ts.close();
> 	}
> 
> 	/**
> 	 * Returns the cost of searching an index file having the
> 	 * specified number of blocks.
> 	 * The method assumes that all buckets are about the
> 	 * same size, and so the cost is simply the size of
> 	 * the bucket.
> 	 * @param numblocks the number of blocks of index records
> 	 * @param rpb the number of records per block (not used here)
> 	 * @return the cost of traversing the index
> 	 */
> 	public static int searchCost(int numblocks, int rpb){
> 		return numblocks / HashIndex.NUM_BUCKETS;
> 	}
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/planner/IndexUpdatePlanner.java ../cs4432-proj2/src/simpledb/index/planner/IndexUpdatePlanner.java
1,120c1,145
< package simpledb.index.planner;
< 
< import java.util.Iterator;
< import java.util.Map;
< 
< import simpledb.record.RID;
< import simpledb.server.SimpleDB;
< import simpledb.tx.Transaction;
< import simpledb.index.Index;
< import simpledb.metadata.IndexInfo;
< import simpledb.parse.*;
< import simpledb.planner.*;
< import simpledb.query.*;
< 
< /**
<  * A modification of the basic update planner.
<  * It dispatches each update statement to the corresponding
<  * index planner.
<  * @author Edward Sciore
<  */
< public class IndexUpdatePlanner implements UpdatePlanner {
<    
<    public int executeInsert(InsertData data, Transaction tx) {
<       String tblname = data.tableName();
<       Plan p = new TablePlan(tblname, tx);
<       
<       // first, insert the record
<       UpdateScan s = (UpdateScan) p.open();
<       s.insert();
<       RID rid = s.getRid();
<       
<       // then modify each field, inserting an index record if appropriate
<       Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
<       Iterator<Constant> valIter = data.vals().iterator();
<       for (String fldname : data.fields()) {
<          Constant val = valIter.next();
<          System.out.println("Modify field " + fldname + " to val " + val);
<          s.setVal(fldname, val);
<          
<          IndexInfo ii = indexes.get(fldname);
<          if (ii != null) {
<             Index idx = ii.open();
<             idx.insert(val, rid);
<             idx.close();
<          }
<       }
<       s.close();
<       return 1;
<    }
<    
<    public int executeDelete(DeleteData data, Transaction tx) {
<       String tblname = data.tableName();
<       Plan p = new TablePlan(tblname, tx);
<       p = new SelectPlan(p, data.pred());
<       Map<String,IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
<       
<       UpdateScan s = (UpdateScan) p.open();
<       int count = 0;
<       while(s.next()) {
<          // first, delete the record's RID from every index
<          RID rid = s.getRid();
<          for (String fldname : indexes.keySet()) {
<             Constant val = s.getVal(fldname);
<             Index idx = indexes.get(fldname).open();
<             idx.delete(val, rid);
<             idx.close();
<          }
<          // then delete the record
<          s.delete();
<          count++;
<       }
<       s.close();
<       return count;
<    }
<    
<    public int executeModify(ModifyData data, Transaction tx) {
<       String tblname = data.tableName();
<       String fldname = data.targetField();
<       Plan p = new TablePlan(tblname, tx);
<       p = new SelectPlan(p, data.pred());
<       
<       IndexInfo ii = SimpleDB.mdMgr().getIndexInfo(tblname, tx).get(fldname);
<       Index idx = (ii == null) ? null : ii.open();
<       
<       UpdateScan s = (UpdateScan) p.open();
<       int count = 0;
<       while(s.next()) {
<          // first, update the record
<          Constant newval = data.newValue().evaluate(s);
<          Constant oldval = s.getVal(fldname);
<          s.setVal(data.targetField(), newval);
<          
<          // then update the appropriate index, if it exists
<          if (idx != null) {
<             RID rid = s.getRid();
<             idx.delete(oldval, rid);
<             idx.insert(newval, rid);
<          }
<          count++;
<       }
<       if (idx != null) idx.close();
<       s.close();
<       return count;
<    }
<    
<    public int executeCreateTable(CreateTableData data, Transaction tx) {
<       SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
<       return 0;
<    }
<    
<    public int executeCreateView(CreateViewData data, Transaction tx) {
<       SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
<       return 0;
<    }
<    
<    public int executeCreateIndex(CreateIndexData data, Transaction tx) {
<       SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
<       return 0;
<    }
< }
---
> package simpledb.index.planner;
> 
> import java.util.Iterator;
> import java.util.Map;
> 
> import simpledb.index.Index;
> import simpledb.metadata.IndexInfo;
> import simpledb.parse.CreateIndexData;
> import simpledb.parse.CreateTableData;
> import simpledb.parse.CreateViewData;
> import simpledb.parse.DeleteData;
> import simpledb.parse.InsertData;
> import simpledb.parse.ModifyData;
> import simpledb.planner.UpdatePlanner;
> import simpledb.query.Constant;
> import simpledb.query.Plan;
> import simpledb.query.SelectPlan;
> import simpledb.query.TablePlan;
> import simpledb.query.UpdateScan;
> import simpledb.record.RID;
> import simpledb.server.SimpleDB;
> import simpledb.tx.Transaction;
> 
> /**
>  * A modification of the basic update planner. It dispatches each update
>  * statement to the corresponding index planner.
>  *
>  * @author Edward Sciore
>  */
> public class IndexUpdatePlanner implements UpdatePlanner {
> 
> 	@Override
> 	public int executeInsert(InsertData data, Transaction tx) {
> 		String tblname = data.tableName();
> 		Plan p = new TablePlan(tblname, tx);
> 
> 		// first, insert the record
> 		UpdateScan s = (UpdateScan) p.open();
> 		s.insert();
> 		RID rid = s.getRid();
> 
> 		// then modify each field, inserting an index record if appropriate
> 		Map<String, IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
> 		Iterator<Constant> valIter = data.vals().iterator();
> 		for (String fldname : data.fields()) {
> 			Constant val = valIter.next();
> 			s.setVal(fldname, val);
> 
> 			IndexInfo ii = indexes.get(fldname);
> 			if (ii != null) {
> 				Index idx = ii.open();
> 				idx.insert(val, rid);
> 				idx.close();
> 			}
> 		}
> 		s.close();
> 		return 1;
> 	}
> 
> 	@Override
> 	public int executeDelete(DeleteData data, Transaction tx) {
> 		String tblname = data.tableName();
> 		Plan p = new TablePlan(tblname, tx);
> 		p = new SelectPlan(p, data.pred());
> 		Map<String, IndexInfo> indexes = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
> 
> 		UpdateScan s = (UpdateScan) p.open();
> 		int count = 0;
> 		while (s.next()) {
> 			// first, delete the record's RID from every index
> 			RID rid = s.getRid();
> 			for (String fldname : indexes.keySet()) {
> 				Constant val = s.getVal(fldname);
> 				Index idx = indexes.get(fldname).open();
> 				idx.delete(val, rid);
> 				idx.close();
> 			}
> 			// then delete the record
> 			s.delete();
> 			count++;
> 		}
> 		s.close();
> 		return count;
> 	}
> 
> 	@Override
> 	public int executeModify(ModifyData data, Transaction tx) {
> 		String tblname = data.tableName();
> 		String fldname = data.targetField();
> 		Plan p = new TablePlan(tblname, tx);
> 		p = new SelectPlan(p, data.pred());
> 
> 		IndexInfo ii = SimpleDB.mdMgr().getIndexInfo(tblname, tx).get(fldname);
> 		Index idx = (ii == null) ? null : ii.open();
> 
> 		UpdateScan s = (UpdateScan) p.open();
> 		int count = 0;
> 		while (s.next()) {
> 			// first, update the record
> 			Constant newval = data.newValue().evaluate(s);
> 			Constant oldval = s.getVal(fldname);
> 			s.setVal(data.targetField(), newval);
> 
> 			// then update the appropriate index, if it exists
> 			if (idx != null) {
> 				RID rid = s.getRid();
> 				idx.delete(oldval, rid);
> 				idx.insert(newval, rid);
> 			}
> 			count++;
> 		}
> 		if (idx != null)
> 			idx.close();
> 		s.close();
> 		return count;
> 	}
> 
> 	@Override
> 	public int executeCreateTable(CreateTableData data, Transaction tx) {
> 		SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
> 		return 0;
> 	}
> 
> 	@Override
> 	public int executeCreateView(CreateViewData data, Transaction tx) {
> 		SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
> 		return 0;
> 	}
> 
> 	/**
> 	 * CS 4432 Project 2
> 	 * 
> 	 * We modified the arguments passed to createIndex() to pass the index type.
> 	 *
> 	 * (non-Javadoc)
> 	 * 
> 	 * @see simpledb.planner.UpdatePlanner#executeCreateIndex(simpledb.parse.CreateIndexData,
> 	 *      simpledb.tx.Transaction)
> 	 */
> 	@Override
> 	public int executeCreateIndex(CreateIndexData data, Transaction tx) {
> 		SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx, data.indexType());
> 		return 0;
> 	}
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/query/IndexJoinPlan.java ../cs4432-proj2/src/simpledb/index/query/IndexJoinPlan.java
1,91c1,91
< package simpledb.index.query;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.Schema;
< import simpledb.metadata.IndexInfo;
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /** The Plan class corresponding to the <i>indexjoin</i>
<   * relational algebra operator.
<   * @author Edward Sciore
<   */
< public class IndexJoinPlan implements Plan {
<    private Plan p1, p2;
<    private IndexInfo ii;
<    private String joinfield;
<    private Schema sch = new Schema();
<    
<    /**
<     * Implements the join operator,
<     * using the specified LHS and RHS plans.
<     * @param p1 the left-hand plan
<     * @param p2 the right-hand plan
<     * @param ii information about the right-hand index
<     * @param joinfield the left-hand field used for joining
<     * @param tx the calling transaction
<     */
<    public IndexJoinPlan(Plan p1, Plan p2, IndexInfo ii, String joinfield, Transaction tx) {
<       this.p1 = p1;
<       this.p2 = p2;
<       this.ii = ii;
<       this.joinfield = joinfield;
<       sch.addAll(p1.schema());
<       sch.addAll(p2.schema());
<    }
<    
<    /**
<     * Opens an indexjoin scan for this query
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Scan s = p1.open();
<       // throws an exception if p2 is not a tableplan
<       TableScan ts = (TableScan) p2.open();
<       Index idx = ii.open();
<       return new IndexJoinScan(s, idx, joinfield, ts);
<    }
<    
<    /**
<     * Estimates the number of block accesses to compute the join.
<     * The formula is:
<     * <pre> B(indexjoin(p1,p2,idx)) = B(p1) + R(p1)*B(idx)
<     *       + R(indexjoin(p1,p2,idx) </pre>
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return p1.blocksAccessed() 
<          + (p1.recordsOutput() * ii.blocksAccessed())
<          + recordsOutput();
<    }
<    
<    /**
<     * Estimates the number of output records in the join.
<     * The formula is:
<     * <pre> R(indexjoin(p1,p2,idx)) = R(p1)*R(idx) </pre>
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return p1.recordsOutput() * ii.recordsOutput();
<    }
<    
<    /**
<     * Estimates the number of distinct values for the 
<     * specified field.  
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       if (p1.schema().hasField(fldname))
<          return p1.distinctValues(fldname);
<       else
<          return p2.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the index join.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return sch;
<    }
< }
---
> package simpledb.index.query;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.Schema;
> import simpledb.metadata.IndexInfo;
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /** The Plan class corresponding to the <i>indexjoin</i>
>   * relational algebra operator.
>   * @author Edward Sciore
>   */
> public class IndexJoinPlan implements Plan {
>    private Plan p1, p2;
>    private IndexInfo ii;
>    private String joinfield;
>    private Schema sch = new Schema();
>    
>    /**
>     * Implements the join operator,
>     * using the specified LHS and RHS plans.
>     * @param p1 the left-hand plan
>     * @param p2 the right-hand plan
>     * @param ii information about the right-hand index
>     * @param joinfield the left-hand field used for joining
>     * @param tx the calling transaction
>     */
>    public IndexJoinPlan(Plan p1, Plan p2, IndexInfo ii, String joinfield, Transaction tx) {
>       this.p1 = p1;
>       this.p2 = p2;
>       this.ii = ii;
>       this.joinfield = joinfield;
>       sch.addAll(p1.schema());
>       sch.addAll(p2.schema());
>    }
>    
>    /**
>     * Opens an indexjoin scan for this query
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Scan s = p1.open();
>       // throws an exception if p2 is not a tableplan
>       TableScan ts = (TableScan) p2.open();
>       Index idx = ii.open();
>       return new IndexJoinScan(s, idx, joinfield, ts);
>    }
>    
>    /**
>     * Estimates the number of block accesses to compute the join.
>     * The formula is:
>     * <pre> B(indexjoin(p1,p2,idx)) = B(p1) + R(p1)*B(idx)
>     *       + R(indexjoin(p1,p2,idx) </pre>
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return p1.blocksAccessed() 
>          + (p1.recordsOutput() * ii.blocksAccessed())
>          + recordsOutput();
>    }
>    
>    /**
>     * Estimates the number of output records in the join.
>     * The formula is:
>     * <pre> R(indexjoin(p1,p2,idx)) = R(p1)*R(idx) </pre>
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return p1.recordsOutput() * ii.recordsOutput();
>    }
>    
>    /**
>     * Estimates the number of distinct values for the 
>     * specified field.  
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       if (p1.schema().hasField(fldname))
>          return p1.distinctValues(fldname);
>       else
>          return p2.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the index join.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return sch;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/query/IndexJoinScan.java ../cs4432-proj2/src/simpledb/index/query/IndexJoinScan.java
1,122c1,122
< package simpledb.index.query;
< 
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /**
<  * The scan class corresponding to the indexjoin relational
<  * algebra operator.
<  * The code is very similar to that of ProductScan, 
<  * which makes sense because an index join is essentially
<  * the product of each LHS record with the matching RHS index records.
<  * @author Edward Sciore
<  */
< public class IndexJoinScan implements Scan {
<    private Scan s;
<    private TableScan ts;  // the data table
<    private Index idx;
<    private String joinfield;
<    
<    /**
<     * Creates an index join scan for the specified LHS scan and 
<     * RHS index.
<     * @param s the LHS scan
<     * @param idx the RHS index
<     * @param joinfield the LHS field used for joining
<     */
<    public IndexJoinScan(Scan s, Index idx, String joinfield, TableScan ts) {
<       this.s = s;
<       this.idx  = idx;
<       this.joinfield = joinfield;
<       this.ts = ts;
<       beforeFirst();
<    }
<    
<    /**
<     * Positions the scan before the first record.
<     * That is, the LHS scan will be positioned at its
<     * first record, and the index will be positioned
<     * before the first record for the join value.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       s.beforeFirst();
<       s.next();
<       resetIndex();
<    }
<    
<    /**
<     * Moves the scan to the next record.
<     * The method moves to the next index record, if possible.
<     * Otherwise, it moves to the next LHS record and the
<     * first index record.
<     * If there are no more LHS records, the method returns false.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       while (true) {
<          if (idx.next()) {
<             ts.moveToRid(idx.getDataRid());
<             return true;
<          }
<          if (!s.next())
<             return false;
<          resetIndex();
<       }
<    }
<    
<    /**
<     * Closes the scan by closing its LHS scan and its RHS index.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       s.close();
<       idx.close();
<       ts.close();
<    }
<    
<    /**
<     * Returns the Constant value of the specified field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (ts.hasField(fldname))
<          return ts.getVal(fldname);
<       else
<          return s.getVal(fldname);
<    }
<    
<    /**
<     * Returns the integer value of the specified field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       if (ts.hasField(fldname))
<          return ts.getInt(fldname);
<       else  
<          return s.getInt(fldname);
<    }
<    
<    /**
<     * Returns the string value of the specified field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public String getString(String fldname) {
<       if (ts.hasField(fldname))
<          return ts.getString(fldname);
<       else
<          return s.getString(fldname);
<    }
<    
<    /** Returns true if the field is in the schema.
<      * @see simpledb.query.Scan#hasField(java.lang.String)
<      */
<    public boolean hasField(String fldname) {
<       return ts.hasField(fldname) || s.hasField(fldname);
<    }
<    
<    private void resetIndex() {
<       Constant searchkey = s.getVal(joinfield);
<       idx.beforeFirst(searchkey);
<    }
< }
---
> package simpledb.index.query;
> 
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /**
>  * The scan class corresponding to the indexjoin relational
>  * algebra operator.
>  * The code is very similar to that of ProductScan, 
>  * which makes sense because an index join is essentially
>  * the product of each LHS record with the matching RHS index records.
>  * @author Edward Sciore
>  */
> public class IndexJoinScan implements Scan {
>    private Scan s;
>    private TableScan ts;  // the data table
>    private Index idx;
>    private String joinfield;
>    
>    /**
>     * Creates an index join scan for the specified LHS scan and 
>     * RHS index.
>     * @param s the LHS scan
>     * @param idx the RHS index
>     * @param joinfield the LHS field used for joining
>     */
>    public IndexJoinScan(Scan s, Index idx, String joinfield, TableScan ts) {
>       this.s = s;
>       this.idx  = idx;
>       this.joinfield = joinfield;
>       this.ts = ts;
>       beforeFirst();
>    }
>    
>    /**
>     * Positions the scan before the first record.
>     * That is, the LHS scan will be positioned at its
>     * first record, and the index will be positioned
>     * before the first record for the join value.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       s.beforeFirst();
>       s.next();
>       resetIndex();
>    }
>    
>    /**
>     * Moves the scan to the next record.
>     * The method moves to the next index record, if possible.
>     * Otherwise, it moves to the next LHS record and the
>     * first index record.
>     * If there are no more LHS records, the method returns false.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       while (true) {
>          if (idx.next()) {
>             ts.moveToRid(idx.getDataRid());
>             return true;
>          }
>          if (!s.next())
>             return false;
>          resetIndex();
>       }
>    }
>    
>    /**
>     * Closes the scan by closing its LHS scan and its RHS index.
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       s.close();
>       idx.close();
>       ts.close();
>    }
>    
>    /**
>     * Returns the Constant value of the specified field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       if (ts.hasField(fldname))
>          return ts.getVal(fldname);
>       else
>          return s.getVal(fldname);
>    }
>    
>    /**
>     * Returns the integer value of the specified field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       if (ts.hasField(fldname))
>          return ts.getInt(fldname);
>       else  
>          return s.getInt(fldname);
>    }
>    
>    /**
>     * Returns the string value of the specified field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public String getString(String fldname) {
>       if (ts.hasField(fldname))
>          return ts.getString(fldname);
>       else
>          return s.getString(fldname);
>    }
>    
>    /** Returns true if the field is in the schema.
>      * @see simpledb.query.Scan#hasField(java.lang.String)
>      */
>    public boolean hasField(String fldname) {
>       return ts.hasField(fldname) || s.hasField(fldname);
>    }
>    
>    private void resetIndex() {
>       Constant searchkey = s.getVal(joinfield);
>       idx.beforeFirst(searchkey);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/query/IndexSelectPlan.java ../cs4432-proj2/src/simpledb/index/query/IndexSelectPlan.java
1,78c1,78
< package simpledb.index.query;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.Schema;
< import simpledb.metadata.IndexInfo;
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /** The Plan class corresponding to the <i>indexselect</i>
<   * relational algebra operator.
<   * @author Edward Sciore
<   */
< public class IndexSelectPlan implements Plan {
<    private Plan p;
<    private IndexInfo ii;
<    private Constant val;
<    
<    /**
<     * Creates a new indexselect node in the query tree
<     * for the specified index and selection constant.
<     * @param p the input table
<     * @param ii information about the index
<     * @param val the selection constant
<     * @param tx the calling transaction 
<     */
<    public IndexSelectPlan(Plan p, IndexInfo ii, Constant val, Transaction tx) {
<       this.p = p;
<       this.ii = ii;
<       this.val = val;
<    }
<    
<    /** 
<     * Creates a new indexselect scan for this query
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       // throws an exception if p is not a tableplan.
<       TableScan ts = (TableScan) p.open();
<       Index idx = ii.open();
<       return new IndexSelectScan(idx, val, ts);
<    }
<    
<    /**
<     * Estimates the number of block accesses to compute the 
<     * index selection, which is the same as the 
<     * index traversal cost plus the number of matching data records.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return ii.blocksAccessed() + recordsOutput();
<    }
<    
<    /**
<     * Estimates the number of output records in the index selection,
<     * which is the same as the number of search key values
<     * for the index.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return ii.recordsOutput();
<    }
<    
<    /** 
<     * Returns the distinct values as defined by the index.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       return ii.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the data table.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return p.schema(); 
<    }
< }
---
> package simpledb.index.query;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.Schema;
> import simpledb.metadata.IndexInfo;
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /** The Plan class corresponding to the <i>indexselect</i>
>   * relational algebra operator.
>   * @author Edward Sciore
>   */
> public class IndexSelectPlan implements Plan {
>    private Plan p;
>    private IndexInfo ii;
>    private Constant val;
>    
>    /**
>     * Creates a new indexselect node in the query tree
>     * for the specified index and selection constant.
>     * @param p the input table
>     * @param ii information about the index
>     * @param val the selection constant
>     * @param tx the calling transaction 
>     */
>    public IndexSelectPlan(Plan p, IndexInfo ii, Constant val, Transaction tx) {
>       this.p = p;
>       this.ii = ii;
>       this.val = val;
>    }
>    
>    /** 
>     * Creates a new indexselect scan for this query
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       // throws an exception if p is not a tableplan.
>       TableScan ts = (TableScan) p.open();
>       Index idx = ii.open();
>       return new IndexSelectScan(idx, val, ts);
>    }
>    
>    /**
>     * Estimates the number of block accesses to compute the 
>     * index selection, which is the same as the 
>     * index traversal cost plus the number of matching data records.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return ii.blocksAccessed() + recordsOutput();
>    }
>    
>    /**
>     * Estimates the number of output records in the index selection,
>     * which is the same as the number of search key values
>     * for the index.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return ii.recordsOutput();
>    }
>    
>    /** 
>     * Returns the distinct values as defined by the index.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       return ii.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the data table.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return p.schema(); 
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/index/query/IndexSelectScan.java ../cs4432-proj2/src/simpledb/index/query/IndexSelectScan.java
1,98c1,98
< package simpledb.index.query;
< 
< import simpledb.record.RID;
< import simpledb.query.*;
< import simpledb.index.Index;
< 
< /**
<  * The scan class corresponding to the select relational
<  * algebra operator.
<  * @author Edward Sciore
<  */
< public class IndexSelectScan implements Scan {
<    private Index idx;
<    private Constant val;
<    private TableScan ts;
<    
<    /**
<     * Creates an index select scan for the specified
<     * index and selection constant.
<     * @param idx the index
<     * @param val the selection constant
<     */
<    public IndexSelectScan(Index idx, Constant val, TableScan ts) {
<       this.idx = idx;
<       this.val = val;
<       this.ts  = ts;
<       beforeFirst();
<    }
<    
<    /**
<     * Positions the scan before the first record,
<     * which in this case means positioning the index
<     * before the first instance of the selection constant.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       idx.beforeFirst(val);
<    }
<    
<    /**
<     * Moves to the next record, which in this case means
<     * moving the index to the next record satisfying the
<     * selection constant, and returning false if there are
<     * no more such index records.
<     * If there is a next record, the method moves the 
<     * tablescan to the corresponding data record.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       boolean ok = idx.next();
<       if (ok) {
<          RID rid = idx.getDataRid();
<          ts.moveToRid(rid);
<       }
<       return ok;
<    }
<    
<    /**
<     * Closes the scan by closing the index and the tablescan.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       idx.close();
<       ts.close();
<    }
<    
<    /**
<     * Returns the value of the field of the current data record.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       return ts.getVal(fldname);
<    }
<    
<    /**
<     * Returns the value of the field of the current data record.
<     * @see simpledb.query.Scan#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       return ts.getInt(fldname);
<    }
<    
<    /**
<     * Returns the value of the field of the current data record.
<     * @see simpledb.query.Scan#getString(java.lang.String)
<     */
<    public String getString(String fldname) {
<       return ts.getString(fldname);
<    }
<    
<    /**
<     * Returns whether the data record has the specified field.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return ts.hasField(fldname);
<    }
< }
---
> package simpledb.index.query;
> 
> import simpledb.record.RID;
> import simpledb.query.*;
> import simpledb.index.Index;
> 
> /**
>  * The scan class corresponding to the select relational
>  * algebra operator.
>  * @author Edward Sciore
>  */
> public class IndexSelectScan implements Scan {
>    private Index idx;
>    private Constant val;
>    private TableScan ts;
>    
>    /**
>     * Creates an index select scan for the specified
>     * index and selection constant.
>     * @param idx the index
>     * @param val the selection constant
>     */
>    public IndexSelectScan(Index idx, Constant val, TableScan ts) {
>       this.idx = idx;
>       this.val = val;
>       this.ts  = ts;
>       beforeFirst();
>    }
>    
>    /**
>     * Positions the scan before the first record,
>     * which in this case means positioning the index
>     * before the first instance of the selection constant.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       idx.beforeFirst(val);
>    }
>    
>    /**
>     * Moves to the next record, which in this case means
>     * moving the index to the next record satisfying the
>     * selection constant, and returning false if there are
>     * no more such index records.
>     * If there is a next record, the method moves the 
>     * tablescan to the corresponding data record.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       boolean ok = idx.next();
>       if (ok) {
>          RID rid = idx.getDataRid();
>          ts.moveToRid(rid);
>       }
>       return ok;
>    }
>    
>    /**
>     * Closes the scan by closing the index and the tablescan.
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       idx.close();
>       ts.close();
>    }
>    
>    /**
>     * Returns the value of the field of the current data record.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       return ts.getVal(fldname);
>    }
>    
>    /**
>     * Returns the value of the field of the current data record.
>     * @see simpledb.query.Scan#getInt(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       return ts.getInt(fldname);
>    }
>    
>    /**
>     * Returns the value of the field of the current data record.
>     * @see simpledb.query.Scan#getString(java.lang.String)
>     */
>    public String getString(String fldname) {
>       return ts.getString(fldname);
>    }
>    
>    /**
>     * Returns whether the data record has the specified field.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       return ts.hasField(fldname);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/log/BasicLogRecord.java ../cs4432-proj2/src/simpledb/log/BasicLogRecord.java
1,54c1,54
< package simpledb.log;
< 
< import static simpledb.file.Page.*;
< import simpledb.file.Page;
< 
< /**
<  * A class that provides the ability to read the values of
<  * a log record.
<  * The class has no idea what values are there.
<  * Instead, the methods {@link #nextInt() nextInt}
<  * and {@link #nextString() nextString} read the values 
<  * sequentially.
<  * Thus the client is responsible for knowing how many values
<  * are in the log record, and what their types are.
<  * @author Edward Sciore
<  */
< public class BasicLogRecord {
<    private Page pg;
<    private int pos;
<    
<    /**
<     * A log record located at the specified position of the specified page.
<     * This constructor is called exclusively by
<     * {@link LogIterator#next()}.
<     * @param pg the page containing the log record
<     * @param pos the position of the log record 
<     */
<    public BasicLogRecord(Page pg, int pos) {
<       this.pg = pg;
<       this.pos = pos;
<    }
<    
<    /**
<     * Returns the next value of the current log record, 
<     * assuming it is an integer.
<     * @return the next value of the current log record
<     */
<    public int nextInt() {
<       int result = pg.getInt(pos);
<       pos += INT_SIZE;
<       return result;
<    }
<    
<    /**
<     * Returns the next value of the current log record, 
<     * assuming it is a string.
<     * @return the next value of the current log record
<     */
<    public String nextString() {
<       String result = pg.getString(pos);
<       pos += STR_SIZE(result.length());
<       return result;
<    }
< }
---
> package simpledb.log;
> 
> import static simpledb.file.Page.*;
> import simpledb.file.Page;
> 
> /**
>  * A class that provides the ability to read the values of
>  * a log record.
>  * The class has no idea what values are there.
>  * Instead, the methods {@link #nextInt() nextInt}
>  * and {@link #nextString() nextString} read the values 
>  * sequentially.
>  * Thus the client is responsible for knowing how many values
>  * are in the log record, and what their types are.
>  * @author Edward Sciore
>  */
> public class BasicLogRecord {
>    private Page pg;
>    private int pos;
>    
>    /**
>     * A log record located at the specified position of the specified page.
>     * This constructor is called exclusively by
>     * {@link LogIterator#next()}.
>     * @param pg the page containing the log record
>     * @param pos the position of the log record 
>     */
>    public BasicLogRecord(Page pg, int pos) {
>       this.pg = pg;
>       this.pos = pos;
>    }
>    
>    /**
>     * Returns the next value of the current log record, 
>     * assuming it is an integer.
>     * @return the next value of the current log record
>     */
>    public int nextInt() {
>       int result = pg.getInt(pos);
>       pos += INT_SIZE;
>       return result;
>    }
>    
>    /**
>     * Returns the next value of the current log record, 
>     * assuming it is a string.
>     * @return the next value of the current log record
>     */
>    public String nextString() {
>       String result = pg.getString(pos);
>       pos += STR_SIZE(result.length());
>       return result;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/log/LogIterator.java ../cs4432-proj2/src/simpledb/log/LogIterator.java
1,66c1,66
< package simpledb.log;
< 
< import static simpledb.file.Page.INT_SIZE;
< import simpledb.file.*;
< import java.util.Iterator;
< 
< /**
<  * A class that provides the ability to move through the
<  * records of the log file in reverse order.
<  * 
<  * @author Edward Sciore
<  */
< class LogIterator implements Iterator<BasicLogRecord> {
<    private Block blk;
<    private Page pg = new Page();
<    private int currentrec;
<    
<    /**
<     * Creates an iterator for the records in the log file,
<     * positioned after the last log record.
<     * This constructor is called exclusively by
<     * {@link LogMgr#iterator()}.
<     */
<    LogIterator(Block blk) {
<       this.blk = blk;
<       pg.read(blk);
<       currentrec = pg.getInt(LogMgr.LAST_POS);
<    }
<    
<    /**
<     * Determines if the current log record
<     * is the earliest record in the log file.
<     * @return true if there is an earlier record
<     */
<    public boolean hasNext() {
<       return currentrec>0 || blk.number()>0;
<    }
<    
<    /**
<     * Moves to the next log record in reverse order.
<     * If the current log record is the earliest in its block,
<     * then the method moves to the next oldest block,
<     * and returns the log record from there.
<     * @return the next earliest log record
<     */
<    public BasicLogRecord next() {
<       if (currentrec == 0) 
<          moveToNextBlock();
<       currentrec = pg.getInt(currentrec);
<       return new BasicLogRecord(pg, currentrec+INT_SIZE);
<    }
<    
<    public void remove() {
<       throw new UnsupportedOperationException();
<    }
<    
<    /**
<     * Moves to the next log block in reverse order,
<     * and positions it after the last record in that block.
<     */
<    private void moveToNextBlock() {
<       blk = new Block(blk.fileName(), blk.number()-1);
<       pg.read(blk);
<       currentrec = pg.getInt(LogMgr.LAST_POS);
<    }
< }
---
> package simpledb.log;
> 
> import static simpledb.file.Page.INT_SIZE;
> import simpledb.file.*;
> import java.util.Iterator;
> 
> /**
>  * A class that provides the ability to move through the
>  * records of the log file in reverse order.
>  * 
>  * @author Edward Sciore
>  */
> class LogIterator implements Iterator<BasicLogRecord> {
>    private Block blk;
>    private Page pg = new Page();
>    private int currentrec;
>    
>    /**
>     * Creates an iterator for the records in the log file,
>     * positioned after the last log record.
>     * This constructor is called exclusively by
>     * {@link LogMgr#iterator()}.
>     */
>    LogIterator(Block blk) {
>       this.blk = blk;
>       pg.read(blk);
>       currentrec = pg.getInt(LogMgr.LAST_POS);
>    }
>    
>    /**
>     * Determines if the current log record
>     * is the earliest record in the log file.
>     * @return true if there is an earlier record
>     */
>    public boolean hasNext() {
>       return currentrec>0 || blk.number()>0;
>    }
>    
>    /**
>     * Moves to the next log record in reverse order.
>     * If the current log record is the earliest in its block,
>     * then the method moves to the next oldest block,
>     * and returns the log record from there.
>     * @return the next earliest log record
>     */
>    public BasicLogRecord next() {
>       if (currentrec == 0) 
>          moveToNextBlock();
>       currentrec = pg.getInt(currentrec);
>       return new BasicLogRecord(pg, currentrec+INT_SIZE);
>    }
>    
>    public void remove() {
>       throw new UnsupportedOperationException();
>    }
>    
>    /**
>     * Moves to the next log block in reverse order,
>     * and positions it after the last record in that block.
>     */
>    private void moveToNextBlock() {
>       blk = new Block(blk.fileName(), blk.number()-1);
>       pg.read(blk);
>       currentrec = pg.getInt(LogMgr.LAST_POS);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/log/LogMgr.java ../cs4432-proj2/src/simpledb/log/LogMgr.java
1,172c1,172
< package simpledb.log;
< 
< import simpledb.server.SimpleDB;
< import simpledb.file.*;
< import static simpledb.file.Page.*;
< import java.util.*;
< 
< /**
<  * The low-level log manager.
<  * This log manager is responsible for writing log records
<  * into a log file.
<  * A log record can be any sequence of integer and string values.
<  * The log manager does not understand the meaning of these
<  * values, which are written and read by the
<  * {@link simpledb.tx.recovery.RecoveryMgr recovery manager}.
<  * @author Edward Sciore
<  */
< public class LogMgr implements Iterable<BasicLogRecord> {
<    /**
<     * The location where the pointer to the last integer in the page is.
<     * A value of 0 means that the pointer is the first value in the page.
<     */
<    public static final int LAST_POS = 0;
< 
<    private String logfile;
<    private Page mypage = new Page();
<    private Block currentblk;
<    private int currentpos;
< 
<    /**
<     * Creates the manager for the specified log file.
<     * If the log file does not yet exist, it is created
<     * with an empty first block.
<     * This constructor depends on a {@link FileMgr} object
<     * that it gets from the method
<     * {@link simpledb.server.SimpleDB#fileMgr()}.
<     * That object is created during system initialization.
<     * Thus this constructor cannot be called until
<     * {@link simpledb.server.SimpleDB#initFileMgr(String)}
<     * is called first.
<     * @param logfile the name of the log file
<     */
<    public LogMgr(String logfile) {
<       this.logfile = logfile;
<       int logsize = SimpleDB.fileMgr().size(logfile);
<       if (logsize == 0)
<          appendNewBlock();
<       else {
<          currentblk = new Block(logfile, logsize-1);
<          mypage.read(currentblk);
<          currentpos = getLastRecordPosition() + INT_SIZE;
<       }
<    }
< 
<    /**
<     * Ensures that the log records corresponding to the
<     * specified LSN has been written to disk.
<     * All earlier log records will also be written to disk.
<     * @param lsn the LSN of a log record
<     */
<    public void flush(int lsn) {
<       if (lsn >= currentLSN())
<          flush();
<    }
< 
<    /**
<     * Returns an iterator for the log records,
<     * which will be returned in reverse order starting with the most recent.
<     * @see java.lang.Iterable#iterator()
<     */
<    public synchronized Iterator<BasicLogRecord> iterator() {
<       flush();
<       return new LogIterator(currentblk);
<    }
< 
<    /**
<     * Appends a log record to the file.
<     * The record contains an arbitrary array of strings and integers.
<     * The method also writes an integer to the end of each log record whose value
<     * is the offset of the corresponding integer for the previous log record.
<     * These integers allow log records to be read in reverse order.
<     * @param rec the list of values
<     * @return the LSN of the final value
<     */
<    public synchronized int append(Object[] rec) {
<       int recsize = INT_SIZE;  // 4 bytes for the integer that points to the previous log record
<       for (Object obj : rec)
<          recsize += size(obj);
<       if (currentpos + recsize >= BLOCK_SIZE){ // the log record doesn't fit,
<          flush();        // so move to the next block.
<          appendNewBlock();
<       }
<       for (Object obj : rec)
<          appendVal(obj);
<       finalizeRecord();
<       return currentLSN();
<    }
< 
<    /**
<     * Adds the specified value to the page at the position denoted by
<     * currentpos.  Then increments currentpos by the size of the value.
<     * @param val the integer or string to be added to the page
<     */
<    private void appendVal(Object val) {
<       if (val instanceof String)
<          mypage.setString(currentpos, (String)val);
<       else
<          mypage.setInt(currentpos, (Integer)val);
<       currentpos += size(val);
<    }
< 
<    /**
<     * Calculates the size of the specified integer or string.
<     * @param val the value
<     * @return the size of the value, in bytes
<     */
<    private int size(Object val) {
<       if (val instanceof String) {
<          String sval = (String) val;
<          return STR_SIZE(sval.length());
<       }
<       else
<          return INT_SIZE;
<    }
< 
<    /**
<     * Returns the LSN of the most recent log record.
<     * As implemented, the LSN is the block number where the record is stored.
<     * Thus every log record in a block has the same LSN.
<     * @return the LSN of the most recent log record
<     */
<    private int currentLSN() {
<       return currentblk.number();
<    }
< 
<    /**
<     * Writes the current page to the log file.
<     */
<    private void flush() {
<       mypage.write(currentblk);
<    }
< 
<    /**
<     * Clear the current page, and append it to the log file.
<     */
<    private void appendNewBlock() {
<       setLastRecordPosition(0);
<       currentpos = INT_SIZE;
<       currentblk = mypage.append(logfile);
<    }
< 
<    /**
<     * Sets up a circular chain of pointers to the records in the page.
<     * There is an integer added to the end of each log record
<     * whose value is the offset of the previous log record.
<     * The first four bytes of the page contain an integer whose value
<     * is the offset of the integer for the last log record in the page.
<     */
<    private void finalizeRecord() {
<       mypage.setInt(currentpos, getLastRecordPosition());
<       setLastRecordPosition(currentpos);
<       currentpos += INT_SIZE;
<    }
< 
<    private int getLastRecordPosition() {
<       return mypage.getInt(LAST_POS);
<    }
< 
<    private void setLastRecordPosition(int pos) {
<       mypage.setInt(LAST_POS, pos);
<    }
< }
---
> package simpledb.log;
> 
> import simpledb.server.SimpleDB;
> import simpledb.file.*;
> import static simpledb.file.Page.*;
> import java.util.*;
> 
> /**
>  * The low-level log manager.
>  * This log manager is responsible for writing log records
>  * into a log file.
>  * A log record can be any sequence of integer and string values.
>  * The log manager does not understand the meaning of these
>  * values, which are written and read by the
>  * {@link simpledb.tx.recovery.RecoveryMgr recovery manager}.
>  * @author Edward Sciore
>  */
> public class LogMgr implements Iterable<BasicLogRecord> {
>    /**
>     * The location where the pointer to the last integer in the page is.
>     * A value of 0 means that the pointer is the first value in the page.
>     */
>    public static final int LAST_POS = 0;
> 
>    private String logfile;
>    private Page mypage = new Page();
>    private Block currentblk;
>    private int currentpos;
> 
>    /**
>     * Creates the manager for the specified log file.
>     * If the log file does not yet exist, it is created
>     * with an empty first block.
>     * This constructor depends on a {@link FileMgr} object
>     * that it gets from the method
>     * {@link simpledb.server.SimpleDB#fileMgr()}.
>     * That object is created during system initialization.
>     * Thus this constructor cannot be called until
>     * {@link simpledb.server.SimpleDB#initFileMgr(String)}
>     * is called first.
>     * @param logfile the name of the log file
>     */
>    public LogMgr(String logfile) {
>       this.logfile = logfile;
>       int logsize = SimpleDB.fileMgr().size(logfile);
>       if (logsize == 0)
>          appendNewBlock();
>       else {
>          currentblk = new Block(logfile, logsize-1);
>          mypage.read(currentblk);
>          currentpos = getLastRecordPosition() + INT_SIZE;
>       }
>    }
> 
>    /**
>     * Ensures that the log records corresponding to the
>     * specified LSN has been written to disk.
>     * All earlier log records will also be written to disk.
>     * @param lsn the LSN of a log record
>     */
>    public void flush(int lsn) {
>       if (lsn >= currentLSN())
>          flush();
>    }
> 
>    /**
>     * Returns an iterator for the log records,
>     * which will be returned in reverse order starting with the most recent.
>     * @see java.lang.Iterable#iterator()
>     */
>    public synchronized Iterator<BasicLogRecord> iterator() {
>       flush();
>       return new LogIterator(currentblk);
>    }
> 
>    /**
>     * Appends a log record to the file.
>     * The record contains an arbitrary array of strings and integers.
>     * The method also writes an integer to the end of each log record whose value
>     * is the offset of the corresponding integer for the previous log record.
>     * These integers allow log records to be read in reverse order.
>     * @param rec the list of values
>     * @return the LSN of the final value
>     */
>    public synchronized int append(Object[] rec) {
>       int recsize = INT_SIZE;  // 4 bytes for the integer that points to the previous log record
>       for (Object obj : rec)
>          recsize += size(obj);
>       if (currentpos + recsize >= BLOCK_SIZE){ // the log record doesn't fit,
>          flush();        // so move to the next block.
>          appendNewBlock();
>       }
>       for (Object obj : rec)
>          appendVal(obj);
>       finalizeRecord();
>       return currentLSN();
>    }
> 
>    /**
>     * Adds the specified value to the page at the position denoted by
>     * currentpos.  Then increments currentpos by the size of the value.
>     * @param val the integer or string to be added to the page
>     */
>    private void appendVal(Object val) {
>       if (val instanceof String)
>          mypage.setString(currentpos, (String)val);
>       else
>          mypage.setInt(currentpos, (Integer)val);
>       currentpos += size(val);
>    }
> 
>    /**
>     * Calculates the size of the specified integer or string.
>     * @param val the value
>     * @return the size of the value, in bytes
>     */
>    private int size(Object val) {
>       if (val instanceof String) {
>          String sval = (String) val;
>          return STR_SIZE(sval.length());
>       }
>       else
>          return INT_SIZE;
>    }
> 
>    /**
>     * Returns the LSN of the most recent log record.
>     * As implemented, the LSN is the block number where the record is stored.
>     * Thus every log record in a block has the same LSN.
>     * @return the LSN of the most recent log record
>     */
>    private int currentLSN() {
>       return currentblk.number();
>    }
> 
>    /**
>     * Writes the current page to the log file.
>     */
>    private void flush() {
>       mypage.write(currentblk);
>    }
> 
>    /**
>     * Clear the current page, and append it to the log file.
>     */
>    private void appendNewBlock() {
>       setLastRecordPosition(0);
>       currentpos = INT_SIZE;
>       currentblk = mypage.append(logfile);
>    }
> 
>    /**
>     * Sets up a circular chain of pointers to the records in the page.
>     * There is an integer added to the end of each log record
>     * whose value is the offset of the previous log record.
>     * The first four bytes of the page contain an integer whose value
>     * is the offset of the integer for the last log record in the page.
>     */
>    private void finalizeRecord() {
>       mypage.setInt(currentpos, getLastRecordPosition());
>       setLastRecordPosition(currentpos);
>       currentpos += INT_SIZE;
>    }
> 
>    private int getLastRecordPosition() {
>       return mypage.getInt(LAST_POS);
>    }
> 
>    private void setLastRecordPosition(int pos) {
>       mypage.setInt(LAST_POS, pos);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/AggregationFn.java ../cs4432-proj2/src/simpledb/materialize/AggregationFn.java
1,37c1,37
< package simpledb.materialize;
< 
< import simpledb.query.*;
< 
< /**
<  * The interface implemented by aggregation functions.
<  * Aggregation functions are used by the <i>groupby</i> operator.
<  * @author Edward Sciore
<  */
< public interface AggregationFn {
<    
<    /**
<     * Uses the current record of the specified scan
<     * to be the first record in the group.
<     * @param s the scan to aggregate over.
<     */
<    void processFirst(Scan s);
<    
<    /**
<     * Uses the current record of the specified scan
<     * to be the next record in the group.
<     * @param s the scan to aggregate over.
<     */
<    void processNext(Scan s);
<    
<    /**
<     * Returns the name of the new aggregation field.
<     * @return the name of the new aggregation field
<     */
<    String fieldName();
<    
<    /**
<     * Returns the computed aggregation value.
<     * @return the computed aggregation value
<     */
<    Constant value();
< }
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> 
> /**
>  * The interface implemented by aggregation functions.
>  * Aggregation functions are used by the <i>groupby</i> operator.
>  * @author Edward Sciore
>  */
> public interface AggregationFn {
>    
>    /**
>     * Uses the current record of the specified scan
>     * to be the first record in the group.
>     * @param s the scan to aggregate over.
>     */
>    void processFirst(Scan s);
>    
>    /**
>     * Uses the current record of the specified scan
>     * to be the next record in the group.
>     * @param s the scan to aggregate over.
>     */
>    void processNext(Scan s);
>    
>    /**
>     * Returns the name of the new aggregation field.
>     * @return the name of the new aggregation field
>     */
>    String fieldName();
>    
>    /**
>     * Returns the computed aggregation value.
>     * @return the computed aggregation value
>     */
>    Constant value();
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/CountFn.java ../cs4432-proj2/src/simpledb/materialize/CountFn.java
1,58c1,58
< package simpledb.materialize;
< 
< import simpledb.query.*;
< 
< /**
<  * The <i>count</i> aggregation function.
<  * @author Edward Sciore
<  */
< public class CountFn implements AggregationFn {
<    private String fldname;
<    private int count;
<    
<    /**
<     * Creates a count aggregation function for the specified field.
<     * @param fldname the name of the aggregated field
<     */
<    public CountFn(String fldname) {
<       this.fldname = fldname;
<    }
<    
<    /**
<     * Starts a new count.
<     * Since SimpleDB does not support null values,
<     * every record will be counted,
<     * regardless of the field.
<     * The current count is thus set to 1.
<     * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
<     */
<    public void processFirst(Scan s) {
<       count = 1;
<    }
<    
<    /**
<     * Since SimpleDB does not support null values,
<     * this method always increments the count,
<     * regardless of the field.
<     * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
<     */
<    public void processNext(Scan s) {
<       count++;
<    }
<    
<    /**
<     * Returns the field's name, prepended by "countof".
<     * @see simpledb.materialize.AggregationFn#fieldName()
<     */
<    public String fieldName() {
<       return "countof" + fldname;
<    }
<    
<    /**
<     * Returns the current count.
<     * @see simpledb.materialize.AggregationFn#value()
<     */
<    public Constant value() {
<       return new IntConstant(count);
<    }
< }
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> 
> /**
>  * The <i>count</i> aggregation function.
>  * @author Edward Sciore
>  */
> public class CountFn implements AggregationFn {
>    private String fldname;
>    private int count;
>    
>    /**
>     * Creates a count aggregation function for the specified field.
>     * @param fldname the name of the aggregated field
>     */
>    public CountFn(String fldname) {
>       this.fldname = fldname;
>    }
>    
>    /**
>     * Starts a new count.
>     * Since SimpleDB does not support null values,
>     * every record will be counted,
>     * regardless of the field.
>     * The current count is thus set to 1.
>     * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
>     */
>    public void processFirst(Scan s) {
>       count = 1;
>    }
>    
>    /**
>     * Since SimpleDB does not support null values,
>     * this method always increments the count,
>     * regardless of the field.
>     * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
>     */
>    public void processNext(Scan s) {
>       count++;
>    }
>    
>    /**
>     * Returns the field's name, prepended by "countof".
>     * @see simpledb.materialize.AggregationFn#fieldName()
>     */
>    public String fieldName() {
>       return "countof" + fldname;
>    }
>    
>    /**
>     * Returns the current count.
>     * @see simpledb.materialize.AggregationFn#value()
>     */
>    public Constant value() {
>       return new IntConstant(count);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/GroupByPlan.java ../cs4432-proj2/src/simpledb/materialize/GroupByPlan.java
1,102c1,102
< package simpledb.materialize;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.Schema;
< import simpledb.query.*;
< import java.util.*;
< 
< /**
<  * The Plan class for the <i>groupby</i> operator.
<  * @author Edward Sciore
<  */
< public class GroupByPlan implements Plan {
<    private Plan p;
<    private Collection<String> groupfields;
<    private Collection<AggregationFn> aggfns;
<    private Schema sch = new Schema();
<    
<    /**
<     * Creates a groupby plan for the underlying query.
<     * The grouping is determined by the specified
<     * collection of group fields,
<     * and the aggregation is computed by the
<     * specified collection of aggregation functions.
<     * @param p a plan for the underlying query
<     * @param groupfields the group fields
<     * @param aggfns the aggregation functions
<     * @param tx the calling transaction
<     */
<    public GroupByPlan(Plan p, Collection<String> groupfields, Collection<AggregationFn> aggfns, Transaction tx) {
<       List<String> grouplist = new ArrayList<String>();
<       grouplist.addAll(groupfields);
<       this.p = new SortPlan(p, grouplist, tx);
<       this.groupfields = groupfields;
<       this.aggfns = aggfns;
<       for (String fldname : groupfields)
<          sch.add(fldname, p.schema());
<       for (AggregationFn fn : aggfns)
<          sch.addIntField(fn.fieldName());
<    }
<    
<    /**
<     * This method opens a sort plan for the specified plan.
<     * The sort plan ensures that the underlying records
<     * will be appropriately grouped.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Scan s = p.open();
<       return new GroupByScan(s, groupfields, aggfns);
<    }
<    
<    /**
<     * Returns the number of blocks required to
<     * compute the aggregation,
<     * which is one pass through the sorted table.
<     * It does <i>not</i> include the one-time cost
<     * of materializing and sorting the records.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return p.blocksAccessed();
<    }
<    
<    /**
<     * Returns the number of groups.  Assuming equal distribution,
<     * this is the product of the distinct values
<     * for each grouping field.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       int numgroups = 1;
<       for (String fldname : groupfields)
<          numgroups *= p.distinctValues(fldname);
<       return numgroups;
<    }
<    
<    /**
<     * Returns the number of distinct values for the
<     * specified field.  If the field is a grouping field,
<     * then the number of distinct values is the same
<     * as in the underlying query.
<     * If the field is an aggregate field, then we
<     * assume that all values are distinct.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       if (p.schema().hasField(fldname))
<          return p.distinctValues(fldname);
<       else
<          return recordsOutput();
<    }
<    
<    /**
<     * Returns the schema of the output table.
<     * The schema consists of the group fields,
<     * plus one field for each aggregation function.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return sch;
<    }
< }
---
> package simpledb.materialize;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.Schema;
> import simpledb.query.*;
> import java.util.*;
> 
> /**
>  * The Plan class for the <i>groupby</i> operator.
>  * @author Edward Sciore
>  */
> public class GroupByPlan implements Plan {
>    private Plan p;
>    private Collection<String> groupfields;
>    private Collection<AggregationFn> aggfns;
>    private Schema sch = new Schema();
>    
>    /**
>     * Creates a groupby plan for the underlying query.
>     * The grouping is determined by the specified
>     * collection of group fields,
>     * and the aggregation is computed by the
>     * specified collection of aggregation functions.
>     * @param p a plan for the underlying query
>     * @param groupfields the group fields
>     * @param aggfns the aggregation functions
>     * @param tx the calling transaction
>     */
>    public GroupByPlan(Plan p, Collection<String> groupfields, Collection<AggregationFn> aggfns, Transaction tx) {
>       List<String> grouplist = new ArrayList<String>();
>       grouplist.addAll(groupfields);
>       this.p = new SortPlan(p, grouplist, tx);
>       this.groupfields = groupfields;
>       this.aggfns = aggfns;
>       for (String fldname : groupfields)
>          sch.add(fldname, p.schema());
>       for (AggregationFn fn : aggfns)
>          sch.addIntField(fn.fieldName());
>    }
>    
>    /**
>     * This method opens a sort plan for the specified plan.
>     * The sort plan ensures that the underlying records
>     * will be appropriately grouped.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Scan s = p.open();
>       return new GroupByScan(s, groupfields, aggfns);
>    }
>    
>    /**
>     * Returns the number of blocks required to
>     * compute the aggregation,
>     * which is one pass through the sorted table.
>     * It does <i>not</i> include the one-time cost
>     * of materializing and sorting the records.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return p.blocksAccessed();
>    }
>    
>    /**
>     * Returns the number of groups.  Assuming equal distribution,
>     * this is the product of the distinct values
>     * for each grouping field.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       int numgroups = 1;
>       for (String fldname : groupfields)
>          numgroups *= p.distinctValues(fldname);
>       return numgroups;
>    }
>    
>    /**
>     * Returns the number of distinct values for the
>     * specified field.  If the field is a grouping field,
>     * then the number of distinct values is the same
>     * as in the underlying query.
>     * If the field is an aggregate field, then we
>     * assume that all values are distinct.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       if (p.schema().hasField(fldname))
>          return p.distinctValues(fldname);
>       else
>          return recordsOutput();
>    }
>    
>    /**
>     * Returns the schema of the output table.
>     * The schema consists of the group fields,
>     * plus one field for each aggregation function.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return sch;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/GroupByScan.java ../cs4432-proj2/src/simpledb/materialize/GroupByScan.java
1,132c1,132
< package simpledb.materialize;
< 
< import simpledb.query.*;
< import java.util.*;
< 
< /**
<  * The Scan class for the <i>groupby</i> operator.
<  * @author Edward Sciore
<  */
< public class GroupByScan implements Scan {
<    private Scan s;
<    private Collection<String> groupfields;
<    private Collection<AggregationFn> aggfns;
<    private GroupValue groupval;
<    private boolean moregroups;
<    
<    /**
<     * Creates a groupby scan, given a grouped table scan.
<     * @param s the grouped scan
<     * @param groupfields the group fields
<     * @param aggfns the aggregation functions
<     */
<    public GroupByScan(Scan s, Collection<String> groupfields, Collection<AggregationFn> aggfns) {
<       this.s = s;
<       this.groupfields = groupfields;
<       this.aggfns = aggfns;
<       beforeFirst();
<    }
<    
<    /**
<     * Positions the scan before the first group.
<     * Internally, the underlying scan is always 
<     * positioned at the first record of a group, which 
<     * means that this method moves to the
<     * first underlying record.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       s.beforeFirst();
<       moregroups = s.next();
<    }
<    
<    /**
<     * Moves to the next group.
<     * The key of the group is determined by the 
<     * group values at the current record.
<     * The method repeatedly reads underlying records until
<     * it encounters a record having a different key.
<     * The aggregation functions are called for each record
<     * in the group. 
<     * The values of the grouping fields for the group are saved.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       if (!moregroups)
<          return false;
<       for (AggregationFn fn : aggfns)
<          fn.processFirst(s);
<       groupval = new GroupValue(s, groupfields);
<       while(moregroups = s.next()) {
<          GroupValue gv = new GroupValue(s, groupfields);
<          if (!groupval.equals(gv))
<             break;
<          for (AggregationFn fn : aggfns)
<             fn.processNext(s);
<       }
<       return true;
<    }
<    
<    /**
<     * Closes the scan by closing the underlying scan.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       s.close();
<    }
<    
<    /**
<     * Gets the Constant value of the specified field.
<     * If the field is a group field, then its value can
<     * be obtained from the saved group value.
<     * Otherwise, the value is obtained from the
<     * appropriate aggregation function.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (groupfields.contains(fldname))
<          return groupval.getVal(fldname);
<       for (AggregationFn fn : aggfns)
<          if (fn.fieldName().equals(fldname))
<          return fn.value();
<       throw new RuntimeException("field " + fldname + " not found.");
<    }
<    
<    /**
<     * Gets the integer value of the specified field.
<     * If the field is a group field, then its value can
<     * be obtained from the saved group value.
<     * Otherwise, the value is obtained from the
<     * appropriate aggregation function.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       return (Integer)getVal(fldname).asJavaVal();
<    }
<    
<    /**
<     * Gets the string value of the specified field.
<     * If the field is a group field, then its value can
<     * be obtained from the saved group value.
<     * Otherwise, the value is obtained from the
<     * appropriate aggregation function.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public String getString(String fldname) {
<       return (String)getVal(fldname).asJavaVal();
<    }
<    
<    /* Returns true if the specified field is either a 
<     * grouping field or created by an aggregation function.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       if (groupfields.contains(fldname))
<          return true;
<       for (AggregationFn fn : aggfns)
<          if (fn.fieldName().equals(fldname))
<          return true;
<       return false;
<    }
< }
< 
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> import java.util.*;
> 
> /**
>  * The Scan class for the <i>groupby</i> operator.
>  * @author Edward Sciore
>  */
> public class GroupByScan implements Scan {
>    private Scan s;
>    private Collection<String> groupfields;
>    private Collection<AggregationFn> aggfns;
>    private GroupValue groupval;
>    private boolean moregroups;
>    
>    /**
>     * Creates a groupby scan, given a grouped table scan.
>     * @param s the grouped scan
>     * @param groupfields the group fields
>     * @param aggfns the aggregation functions
>     */
>    public GroupByScan(Scan s, Collection<String> groupfields, Collection<AggregationFn> aggfns) {
>       this.s = s;
>       this.groupfields = groupfields;
>       this.aggfns = aggfns;
>       beforeFirst();
>    }
>    
>    /**
>     * Positions the scan before the first group.
>     * Internally, the underlying scan is always 
>     * positioned at the first record of a group, which 
>     * means that this method moves to the
>     * first underlying record.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       s.beforeFirst();
>       moregroups = s.next();
>    }
>    
>    /**
>     * Moves to the next group.
>     * The key of the group is determined by the 
>     * group values at the current record.
>     * The method repeatedly reads underlying records until
>     * it encounters a record having a different key.
>     * The aggregation functions are called for each record
>     * in the group. 
>     * The values of the grouping fields for the group are saved.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       if (!moregroups)
>          return false;
>       for (AggregationFn fn : aggfns)
>          fn.processFirst(s);
>       groupval = new GroupValue(s, groupfields);
>       while(moregroups = s.next()) {
>          GroupValue gv = new GroupValue(s, groupfields);
>          if (!groupval.equals(gv))
>             break;
>          for (AggregationFn fn : aggfns)
>             fn.processNext(s);
>       }
>       return true;
>    }
>    
>    /**
>     * Closes the scan by closing the underlying scan.
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       s.close();
>    }
>    
>    /**
>     * Gets the Constant value of the specified field.
>     * If the field is a group field, then its value can
>     * be obtained from the saved group value.
>     * Otherwise, the value is obtained from the
>     * appropriate aggregation function.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       if (groupfields.contains(fldname))
>          return groupval.getVal(fldname);
>       for (AggregationFn fn : aggfns)
>          if (fn.fieldName().equals(fldname))
>          return fn.value();
>       throw new RuntimeException("field " + fldname + " not found.");
>    }
>    
>    /**
>     * Gets the integer value of the specified field.
>     * If the field is a group field, then its value can
>     * be obtained from the saved group value.
>     * Otherwise, the value is obtained from the
>     * appropriate aggregation function.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       return (Integer)getVal(fldname).asJavaVal();
>    }
>    
>    /**
>     * Gets the string value of the specified field.
>     * If the field is a group field, then its value can
>     * be obtained from the saved group value.
>     * Otherwise, the value is obtained from the
>     * appropriate aggregation function.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public String getString(String fldname) {
>       return (String)getVal(fldname).asJavaVal();
>    }
>    
>    /* Returns true if the specified field is either a 
>     * grouping field or created by an aggregation function.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       if (groupfields.contains(fldname))
>          return true;
>       for (AggregationFn fn : aggfns)
>          if (fn.fieldName().equals(fldname))
>          return true;
>       return false;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/GroupValue.java ../cs4432-proj2/src/simpledb/materialize/GroupValue.java
1,64c1,64
< package simpledb.materialize;
< 
< import simpledb.query.*;
< 
< import java.util.*;
< 
< /**
<  * An object that holds the values of the grouping fields
<  * for the current record of a scan.
<  * @author Edward Sciore
<  */
< public class GroupValue {
<    private Map<String,Constant> vals;
<    
<    /**
<     * Creates a new group value, given the specified scan
<     * and list of fields.
<     * The values in the current record of each field are 
<     * stored.
<     * @param s a scan
<     * @param fields the list of fields
<     */
<    public GroupValue(Scan s, Collection<String> fields) {
<       vals = new HashMap<String,Constant>();
<       for (String fldname : fields)
<          vals.put(fldname, s.getVal(fldname));
<    }
<    
<    /**
<     * Returns the Constant value of the specified field in the group.
<     * @param fldname the name of a field
<     * @return the value of the field in the group
<     */
<    public Constant getVal(String fldname) {
<       return vals.get(fldname);
<    }
<    
<    /** 
<     * Two GroupValue objects are equal if they have the same values
<     * for their grouping fields. 
<     * @see java.lang.Object#equals(java.lang.Object)
<     */
<    public boolean equals(Object obj) {
<       GroupValue gv = (GroupValue) obj;
<       for (String fldname : vals.keySet()) {
<          Constant v1 = vals.get(fldname);
<          Constant v2 = gv.getVal(fldname);
<          if (!v1.equals(v2))
<             return false;
<       }
<       return true;
<    }
<    
<    /**
<     * The hashcode of a GroupValue object is the sum of the
<     * hashcodes of its field values. 
<     * @see java.lang.Object#hashCode()
<     */
<    public int hashCode() {
<       int hashval = 0;
<       for (Constant c: vals.values())
<          hashval += c.hashCode();
<       return hashval;
<    }
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> 
> import java.util.*;
> 
> /**
>  * An object that holds the values of the grouping fields
>  * for the current record of a scan.
>  * @author Edward Sciore
>  */
> public class GroupValue {
>    private Map<String,Constant> vals;
>    
>    /**
>     * Creates a new group value, given the specified scan
>     * and list of fields.
>     * The values in the current record of each field are 
>     * stored.
>     * @param s a scan
>     * @param fields the list of fields
>     */
>    public GroupValue(Scan s, Collection<String> fields) {
>       vals = new HashMap<String,Constant>();
>       for (String fldname : fields)
>          vals.put(fldname, s.getVal(fldname));
>    }
>    
>    /**
>     * Returns the Constant value of the specified field in the group.
>     * @param fldname the name of a field
>     * @return the value of the field in the group
>     */
>    public Constant getVal(String fldname) {
>       return vals.get(fldname);
>    }
>    
>    /** 
>     * Two GroupValue objects are equal if they have the same values
>     * for their grouping fields. 
>     * @see java.lang.Object#equals(java.lang.Object)
>     */
>    public boolean equals(Object obj) {
>       GroupValue gv = (GroupValue) obj;
>       for (String fldname : vals.keySet()) {
>          Constant v1 = vals.get(fldname);
>          Constant v2 = gv.getVal(fldname);
>          if (!v1.equals(v2))
>             return false;
>       }
>       return true;
>    }
>    
>    /**
>     * The hashcode of a GroupValue object is the sum of the
>     * hashcodes of its field values. 
>     * @see java.lang.Object#hashCode()
>     */
>    public int hashCode() {
>       int hashval = 0;
>       for (Constant c: vals.values())
>          hashval += c.hashCode();
>       return hashval;
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/MaterializePlan.java ../cs4432-proj2/src/simpledb/materialize/MaterializePlan.java
1,87c1,87
< package simpledb.materialize;
< 
< import static simpledb.file.Page.BLOCK_SIZE;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< 
< /**
<  * The Plan class for the <i>materialize</i> operator.
<  * @author Edward Sciore
<  */
< public class MaterializePlan implements Plan {
<    private Plan srcplan;
<    private Transaction tx;
<    
<    /**
<     * Creates a materialize plan for the specified query.
<     * @param srcplan the plan of the underlying query
<     * @param tx the calling transaction
<     */
<    public MaterializePlan(Plan srcplan, Transaction tx) {
<       this.srcplan = srcplan;
<       this.tx = tx;
<    }
<    
<    /**
<     * This method loops through the underlying query,
<     * copying its output records into a temporary table.
<     * It then returns a table scan for that table.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Schema sch = srcplan.schema();
<       TempTable temp = new TempTable(sch, tx);
<       Scan src = srcplan.open();
<       UpdateScan dest = temp.open();
<       while (src.next()) {
<          dest.insert();
<          for (String fldname : sch.fields())
<             dest.setVal(fldname, src.getVal(fldname));
<       }
<       src.close();
<       dest.beforeFirst();
<       return dest;
<    }
<    
<    /**
<     * Returns the estimated number of blocks in the 
<     * materialized table.
<     * It does <i>not</i> include the one-time cost
<     * of materializing the records.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       // create a dummy TableInfo object to calculate record length
<       TableInfo ti = new TableInfo("", srcplan.schema());
<       double rpb = (double) (BLOCK_SIZE / ti.recordLength());
<       return (int) Math.ceil(srcplan.recordsOutput() / rpb);
<    }
<    
<    /**
<     * Returns the number of records in the materialized table,
<     * which is the same as in the underlying plan.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return srcplan.recordsOutput();
<    }
<    
<    /**
<     * Returns the number of distinct field values,
<     * which is the same as in the underlying plan.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       return srcplan.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the materialized table,
<     * which is the same as in the underlying plan.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return srcplan.schema();
<    }
< }
---
> package simpledb.materialize;
> 
> import static simpledb.file.Page.BLOCK_SIZE;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> 
> /**
>  * The Plan class for the <i>materialize</i> operator.
>  * @author Edward Sciore
>  */
> public class MaterializePlan implements Plan {
>    private Plan srcplan;
>    private Transaction tx;
>    
>    /**
>     * Creates a materialize plan for the specified query.
>     * @param srcplan the plan of the underlying query
>     * @param tx the calling transaction
>     */
>    public MaterializePlan(Plan srcplan, Transaction tx) {
>       this.srcplan = srcplan;
>       this.tx = tx;
>    }
>    
>    /**
>     * This method loops through the underlying query,
>     * copying its output records into a temporary table.
>     * It then returns a table scan for that table.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Schema sch = srcplan.schema();
>       TempTable temp = new TempTable(sch, tx);
>       Scan src = srcplan.open();
>       UpdateScan dest = temp.open();
>       while (src.next()) {
>          dest.insert();
>          for (String fldname : sch.fields())
>             dest.setVal(fldname, src.getVal(fldname));
>       }
>       src.close();
>       dest.beforeFirst();
>       return dest;
>    }
>    
>    /**
>     * Returns the estimated number of blocks in the 
>     * materialized table.
>     * It does <i>not</i> include the one-time cost
>     * of materializing the records.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       // create a dummy TableInfo object to calculate record length
>       TableInfo ti = new TableInfo("", srcplan.schema());
>       double rpb = (double) (BLOCK_SIZE / ti.recordLength());
>       return (int) Math.ceil(srcplan.recordsOutput() / rpb);
>    }
>    
>    /**
>     * Returns the number of records in the materialized table,
>     * which is the same as in the underlying plan.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return srcplan.recordsOutput();
>    }
>    
>    /**
>     * Returns the number of distinct field values,
>     * which is the same as in the underlying plan.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       return srcplan.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the materialized table,
>     * which is the same as in the underlying plan.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return srcplan.schema();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/MaxFn.java ../cs4432-proj2/src/simpledb/materialize/MaxFn.java
1,56c1,56
< package simpledb.materialize;
< 
< import simpledb.query.*;
< 
< /**
<  * The <i>max</i> aggregation function.
<  * @author Edward Sciore
<  */
< public class MaxFn implements AggregationFn {
<    private String fldname;
<    private Constant val;
<    
<    /**
<     * Creates a max aggregation function for the specified field.
<     * @param fldname the name of the aggregated field
<     */
<    public MaxFn(String fldname) {
<       this.fldname = fldname;
<    }
<    
<    /**
<     * Starts a new maximum to be the 
<     * field value in the current record.
<     * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
<     */
<    public void processFirst(Scan s) {
<       val = s.getVal(fldname);
<    }
<    
<    /**
<     * Replaces the current maximum by the field value
<     * in the current record, if it is higher.
<     * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
<     */
<    public void processNext(Scan s) {
<       Constant newval = s.getVal(fldname);
<       if (newval.compareTo(val) > 0)
<          val = newval;
<    }
<    
<    /**
<     * Returns the field's name, prepended by "maxof".
<     * @see simpledb.materialize.AggregationFn#fieldName()
<     */
<    public String fieldName() {
<       return "maxof" + fldname;
<    }
<    
<    /**
<     * Returns the current maximum.
<     * @see simpledb.materialize.AggregationFn#value()
<     */
<    public Constant value() {
<       return val;
<    }
< }
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> 
> /**
>  * The <i>max</i> aggregation function.
>  * @author Edward Sciore
>  */
> public class MaxFn implements AggregationFn {
>    private String fldname;
>    private Constant val;
>    
>    /**
>     * Creates a max aggregation function for the specified field.
>     * @param fldname the name of the aggregated field
>     */
>    public MaxFn(String fldname) {
>       this.fldname = fldname;
>    }
>    
>    /**
>     * Starts a new maximum to be the 
>     * field value in the current record.
>     * @see simpledb.materialize.AggregationFn#processFirst(simpledb.query.Scan)
>     */
>    public void processFirst(Scan s) {
>       val = s.getVal(fldname);
>    }
>    
>    /**
>     * Replaces the current maximum by the field value
>     * in the current record, if it is higher.
>     * @see simpledb.materialize.AggregationFn#processNext(simpledb.query.Scan)
>     */
>    public void processNext(Scan s) {
>       Constant newval = s.getVal(fldname);
>       if (newval.compareTo(val) > 0)
>          val = newval;
>    }
>    
>    /**
>     * Returns the field's name, prepended by "maxof".
>     * @see simpledb.materialize.AggregationFn#fieldName()
>     */
>    public String fieldName() {
>       return "maxof" + fldname;
>    }
>    
>    /**
>     * Returns the current maximum.
>     * @see simpledb.materialize.AggregationFn#value()
>     */
>    public Constant value() {
>       return val;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/MergeJoinPlan.java ../cs4432-proj2/src/simpledb/materialize/MergeJoinPlan.java
1,100c1,100
< package simpledb.materialize;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< import java.util.*;
< 
< /**
<  * The Plan class for the <i>mergejoin</i> operator.
<  * @author Edward Sciore
<  */
< public class MergeJoinPlan implements Plan {
<    private Plan p1, p2;
<    private String fldname1, fldname2;
<    private Schema sch = new Schema();
<    
<    /**
<     * Creates a mergejoin plan for the two specified queries.
<     * The RHS must be materialized after it is sorted, 
<     * in order to deal with possible duplicates.
<     * @param p1 the LHS query plan
<     * @param p2 the RHS query plan
<     * @param fldname1 the LHS join field
<     * @param fldname2 the RHS join field
<     * @param tx the calling transaction
<     */
<    public MergeJoinPlan(Plan p1, Plan p2, String fldname1, String fldname2, Transaction tx) {
<       this.fldname1 = fldname1;
<       List<String> sortlist1 = Arrays.asList(fldname1);
<       this.p1 = new SortPlan(p1, sortlist1, tx);
<       
<       this.fldname2 = fldname2;
<       List<String> sortlist2 = Arrays.asList(fldname2);
<       this.p2 = new SortPlan(p2, sortlist2, tx);
<       
<       sch.addAll(p1.schema());
<       sch.addAll(p2.schema());
<    }
<    
<    /** The method first sorts its two underlying scans
<      * on their join field. It then returns a mergejoin scan
<      * of the two sorted table scans.
<      * @see simpledb.query.Plan#open()
<      */
<    public Scan open() {
<       Scan s1 = p1.open();
<       SortScan s2 = (SortScan) p2.open();
<       return new MergeJoinScan(s1, s2, fldname1, fldname2);
<    }
<    
<    /**
<     * Returns the number of block acceses required to
<     * mergejoin the sorted tables.
<     * Since a mergejoin can be preformed with a single
<     * pass through each table, the method returns
<     * the sum of the block accesses of the 
<     * materialized sorted tables.
<     * It does <i>not</i> include the one-time cost
<     * of materializing and sorting the records.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return p1.blocksAccessed() + p2.blocksAccessed();
<    }
<    
<    /**
<     * Returns the number of records in the join.
<     * Assuming uniform distribution, the formula is:
<     * <pre> R(join(p1,p2)) = R(p1)*R(p2)/max{V(p1,F1),V(p2,F2)}</pre>
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       int maxvals = Math.max(p1.distinctValues(fldname1),
<                              p2.distinctValues(fldname2));
<       return (p1.recordsOutput() * p2.recordsOutput()) / maxvals;
<    }
<    
<    /**
<     * Estimates the distinct number of field values in the join.
<     * Since the join does not increase or decrease field values,
<     * the estimate is the same as in the appropriate underlying query.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       if (p1.schema().hasField(fldname))
<          return p1.distinctValues(fldname);
<       else
<          return p2.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the join,
<     * which is the union of the schemas of the underlying queries.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return sch;
<    }
< }
< 
---
> package simpledb.materialize;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> import java.util.*;
> 
> /**
>  * The Plan class for the <i>mergejoin</i> operator.
>  * @author Edward Sciore
>  */
> public class MergeJoinPlan implements Plan {
>    private Plan p1, p2;
>    private String fldname1, fldname2;
>    private Schema sch = new Schema();
>    
>    /**
>     * Creates a mergejoin plan for the two specified queries.
>     * The RHS must be materialized after it is sorted, 
>     * in order to deal with possible duplicates.
>     * @param p1 the LHS query plan
>     * @param p2 the RHS query plan
>     * @param fldname1 the LHS join field
>     * @param fldname2 the RHS join field
>     * @param tx the calling transaction
>     */
>    public MergeJoinPlan(Plan p1, Plan p2, String fldname1, String fldname2, Transaction tx) {
>       this.fldname1 = fldname1;
>       List<String> sortlist1 = Arrays.asList(fldname1);
>       this.p1 = new SortPlan(p1, sortlist1, tx);
>       
>       this.fldname2 = fldname2;
>       List<String> sortlist2 = Arrays.asList(fldname2);
>       this.p2 = new SortPlan(p2, sortlist2, tx);
>       
>       sch.addAll(p1.schema());
>       sch.addAll(p2.schema());
>    }
>    
>    /** The method first sorts its two underlying scans
>      * on their join field. It then returns a mergejoin scan
>      * of the two sorted table scans.
>      * @see simpledb.query.Plan#open()
>      */
>    public Scan open() {
>       Scan s1 = p1.open();
>       SortScan s2 = (SortScan) p2.open();
>       return new MergeJoinScan(s1, s2, fldname1, fldname2);
>    }
>    
>    /**
>     * Returns the number of block acceses required to
>     * mergejoin the sorted tables.
>     * Since a mergejoin can be preformed with a single
>     * pass through each table, the method returns
>     * the sum of the block accesses of the 
>     * materialized sorted tables.
>     * It does <i>not</i> include the one-time cost
>     * of materializing and sorting the records.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return p1.blocksAccessed() + p2.blocksAccessed();
>    }
>    
>    /**
>     * Returns the number of records in the join.
>     * Assuming uniform distribution, the formula is:
>     * <pre> R(join(p1,p2)) = R(p1)*R(p2)/max{V(p1,F1),V(p2,F2)}</pre>
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       int maxvals = Math.max(p1.distinctValues(fldname1),
>                              p2.distinctValues(fldname2));
>       return (p1.recordsOutput() * p2.recordsOutput()) / maxvals;
>    }
>    
>    /**
>     * Estimates the distinct number of field values in the join.
>     * Since the join does not increase or decrease field values,
>     * the estimate is the same as in the appropriate underlying query.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       if (p1.schema().hasField(fldname))
>          return p1.distinctValues(fldname);
>       else
>          return p2.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the join,
>     * which is the union of the schemas of the underlying queries.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return sch;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/MergeJoinScan.java ../cs4432-proj2/src/simpledb/materialize/MergeJoinScan.java
1,138c1,145
< package simpledb.materialize;
< 
< import simpledb.query.*;
< 
< /**
<  * The Scan class for the <i>mergejoin</i> operator.
<  * @author Edward Sciore
<  */
< public class MergeJoinScan implements Scan {
<    private Scan s1;
<    private SortScan s2;
<    private String fldname1, fldname2;
<    private Constant joinval = null;
<    
<    /**
<     * Creates a mergejoin scan for the two underlying sorted scans.
<     * @param s1 the LHS sorted scan
<     * @param s2 the RHS sorted scan
<     * @param fldname1 the LHS join field
<     * @param fldname2 the RHS join field
<     */
<    public MergeJoinScan(Scan s1, SortScan s2, String fldname1, String fldname2) {
<       this.s1 = s1;
<       this.s2 = s2;
<       this.fldname1 = fldname1;
<       this.fldname2 = fldname2;
<       beforeFirst();
<    }
<    
<    /**
<     * Positions the scan before the first record,
<     * by positioning each underlying scan before
<     * their first records.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       s1.beforeFirst();
<       s2.beforeFirst();
<    }
<    
<    /**
<     * Closes the scan by closing the two underlying scans.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       s1.close();
<       s2.close();
<    }
<    
<    /**
<     * Moves to the next record.  This is where the action is.
<     * <P>
<     * If the next RHS record has the same join value,
<     * then move to it.
<     * Otherwise, if the next LHS record has the same join value,
<     * then reposition the RHS scan back to the first record
<     * having that join value.
<     * Otherwise, repeatedly move the scan having the smallest
<     * value until a common join value is found.
<     * When one of the scans runs out of records, return false.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       boolean hasmore2 = s2.next();
<       if (hasmore2 && s2.getVal(fldname2).equals(joinval))
<          return true;
<       
<       boolean hasmore1 = s1.next();
<       if (hasmore1 && s1.getVal(fldname1).equals(joinval)) {
<          s2.restorePosition();
<          return true;
<       }
<       
<       while (hasmore1 && hasmore2) {
<          Constant v1 = s1.getVal(fldname1);
<          Constant v2 = s2.getVal(fldname2);
<          if (v1.compareTo(v2) < 0)
<             hasmore1 = s1.next();
<          else if (v1.compareTo(v2) > 0)
<             hasmore2 = s2.next();
<          else {
<             s2.savePosition();
<             joinval  = s2.getVal(fldname2);
<             return true;
<          }
<       }
<       return false;
<    }
<    
<    /** 
<     * Returns the value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getVal(fldname);
<       else
<          return s2.getVal(fldname);
<    }
<    
<    /** 
<     * Returns the integer value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getInt(fldname);
<       else
<          return s2.getInt(fldname);
<    }
<    
<    /** 
<     * Returns the string value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getString(java.lang.String)
<     */
<    public String getString(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getString(fldname);
<       else
<          return s2.getString(fldname);
<    }
<    
<    /**
<     * Returns true if the specified field is in
<     * either of the underlying scans.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return s1.hasField(fldname) || s2.hasField(fldname);
<    }
< }
< 
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> 
> /**
>  * The Scan class for the <i>mergejoin</i> operator.
>  * @author Edward Sciore
>  */
> public class MergeJoinScan implements Scan {
>     private Scan s1;
>     private SortScan s2;
>     private String fldname1, fldname2;
>     private Constant joinval = null;
> 
>    /**
>     * Creates a mergejoin scan for the two underlying sorted scans.
>     * @param s1 the LHS sorted scan
>     * @param s2 the RHS sorted scan
>     * @param fldname1 the LHS join field
>     * @param fldname2 the RHS join field
>     */
>    public MergeJoinScan(Scan s1, SortScan s2, String fldname1, String fldname2) {
>       this.fldname1 = fldname1;
>       this.fldname2 = fldname2;
>       this.s1 = s1;
>       this.s2 = s2;
>       beforeFirst();
>    }
>    
>    /**
>     * Positions the scan before the first record,
>     * by positioning each underlying scan before
>     * their first records.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    @Override
>    public void beforeFirst() {
>       s1.beforeFirst();
>       s2.beforeFirst();
>    }
>    
>    /**
>     * Closes the scan by closing the two underlying scans.
>     * @see simpledb.query.Scan#close()
>     */
>    @Override
>    public void close() {
>       s1.close();
>       s2.close();
>    }
>    
>    /**
>     * Moves to the next record.  This is where the action is.
>     * <P>
>     * If the next RHS record has the same join value,
>     * then move to it.
>     * Otherwise, if the next LHS record has the same join value,
>     * then reposition the RHS scan back to the first record
>     * having that join value.
>     * Otherwise, repeatedly move the scan having the smallest
>     * value until a common join value is found.
>     * When one of the scans runs out of records, return false.
>     * @see simpledb.query.Scan#next()
>     */
>    @Override
>    public boolean next() {
>       boolean hasmore2 = s2.next();
>       if (hasmore2 && s2.getVal(fldname2).equals(joinval))
>          return true;
>       
>       boolean hasmore1 = s1.next();
>       if (hasmore1 && s1.getVal(fldname1).equals(joinval)) {
>          s2.restorePosition();
>          return true;
>       }
>       
>       while (hasmore1 && hasmore2) {
>          Constant v1 = s1.getVal(fldname1);
>          Constant v2 = s2.getVal(fldname2);
>          if (v1.compareTo(v2) < 0)
>             hasmore1 = s1.next();
>          else if (v1.compareTo(v2) > 0)
>             hasmore2 = s2.next();
>          else {
>             s2.savePosition();
>             joinval  = s2.getVal(fldname2);
>             return true;
>          }
>       }
>       return false;
>    }
>    
>    /** 
>     * Returns the value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    @Override
>    public Constant getVal(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getVal(fldname);
>       else
>          return s2.getVal(fldname);
>    }
>    
>    /** 
>     * Returns the integer value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getInt(java.lang.String)
>     */
>    @Override
>    public int getInt(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getInt(fldname);
>       else
>          return s2.getInt(fldname);
>    }
>    
>    /** 
>     * Returns the string value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getString(java.lang.String)
>     */
>    @Override
>    public String getString(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getString(fldname);
>       else
>          return s2.getString(fldname);
>    }
>    
>    /**
>     * Returns true if the specified field is in
>     * either of the underlying scans.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    @Override
>    public boolean hasField(String fldname) {
>       return s1.hasField(fldname) || s2.hasField(fldname);
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/RecordComparator.java ../cs4432-proj2/src/simpledb/materialize/RecordComparator.java
1,44c1,44
< package simpledb.materialize;
< 
< import simpledb.query.*;
< import java.util.*;
< 
< /**
<  * A comparator for scans.
<  * @author Edward Sciore
<  */
< public class RecordComparator implements Comparator<Scan> {
<    private List<String> fields;
<    
<    /**
<     * Creates a comparator using the specified fields,
<     * using the ordering implied by its iterator.
<     * @param fields a list of field names
<     */
<    public RecordComparator(List<String> fields) {
<       this.fields = fields;
<    }
<    
<    /**
<     * Compares the current records of the two specified scans.
<     * The sort fields are considered in turn.
<     * When a field is encountered for which the records have
<     * different values, those values are used as the result
<     * of the comparison.
<     * If the two records have the same values for all
<     * sort fields, then the method returns 0.
<     * @param s1 the first scan
<     * @param s2 the second scan
<     * @return the result of comparing each scan's current record according to the field list
<     */
<    public int compare(Scan s1, Scan s2) {
<       for (String fldname : fields) {
<          Constant val1 = s1.getVal(fldname);
<          Constant val2 = s2.getVal(fldname);
<          int result = val1.compareTo(val2);
<          if (result != 0)
<             return result;
<       }
<       return 0;
<    }
< }
---
> package simpledb.materialize;
> 
> import simpledb.query.*;
> import java.util.*;
> 
> /**
>  * A comparator for scans.
>  * @author Edward Sciore
>  */
> public class RecordComparator implements Comparator<Scan> {
>    private List<String> fields;
>    
>    /**
>     * Creates a comparator using the specified fields,
>     * using the ordering implied by its iterator.
>     * @param fields a list of field names
>     */
>    public RecordComparator(List<String> fields) {
>       this.fields = fields;
>    }
>    
>    /**
>     * Compares the current records of the two specified scans.
>     * The sort fields are considered in turn.
>     * When a field is encountered for which the records have
>     * different values, those values are used as the result
>     * of the comparison.
>     * If the two records have the same values for all
>     * sort fields, then the method returns 0.
>     * @param s1 the first scan
>     * @param s2 the second scan
>     * @return the result of comparing each scan's current record according to the field list
>     */
>    public int compare(Scan s1, Scan s2) {
>       for (String fldname : fields) {
>          Constant val1 = s1.getVal(fldname);
>          Constant val2 = s2.getVal(fldname);
>          int result = val1.compareTo(val2);
>          if (result != 0)
>             return result;
>       }
>       return 0;
>    }
> }
Only in ../cs4432-proj2/src/simpledb/materialize: SmartMergeJoinPlan.java
Only in ../cs4432-proj2/src/simpledb/materialize: SmartSortPlan.java
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/SortPlan.java ../cs4432-proj2/src/simpledb/materialize/SortPlan.java
1,153c1,161
< package simpledb.materialize;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< 
< import java.util.*;
< 
< /**
<  * The Plan class for the <i>sort</i> operator.
<  * @author Edward Sciore
<  */
< public class SortPlan implements Plan {
<    private Plan p;
<    private Transaction tx;
<    private Schema sch;
<    private RecordComparator comp;
<    
<    /**
<     * Creates a sort plan for the specified query.
<     * @param p the plan for the underlying query
<     * @param sortfields the fields to sort by
<     * @param tx the calling transaction
<     */
<    public SortPlan(Plan p, List<String> sortfields, Transaction tx) {
<       this.p = p;
<       this.tx = tx;
<       sch = p.schema();
<       comp = new RecordComparator(sortfields);
<    }
<    
<    /**
<     * This method is where most of the action is.
<     * Up to 2 sorted temporary tables are created,
<     * and are passed into SortScan for final merging.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Scan src = p.open();
<       List<TempTable> runs = splitIntoRuns(src);
<       src.close();
<       while (runs.size() > 2)
<          runs = doAMergeIteration(runs);
<       return new SortScan(runs, comp);
<    }
<    
<    /**
<     * Returns the number of blocks in the sorted table,
<     * which is the same as it would be in a
<     * materialized table.
<     * It does <i>not</i> include the one-time cost
<     * of materializing and sorting the records.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       // does not include the one-time cost of sorting
<       Plan mp = new MaterializePlan(p, tx); // not opened; just for analysis
<       return mp.blocksAccessed();
<    }
<    
<    /**
<     * Returns the number of records in the sorted table,
<     * which is the same as in the underlying query.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return p.recordsOutput();
<    }
<    
<    /**
<     * Returns the number of distinct field values in
<     * the sorted table, which is the same as in
<     * the underlying query.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       return p.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the sorted table, which
<     * is the same as in the underlying query.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return sch;
<    }
<    
<    private List<TempTable> splitIntoRuns(Scan src) {
<       List<TempTable> temps = new ArrayList<TempTable>();
<       src.beforeFirst();
<       if (!src.next())
<          return temps;
<       TempTable currenttemp = new TempTable(sch, tx);
<       temps.add(currenttemp);
<       UpdateScan currentscan = currenttemp.open();
<       while (copy(src, currentscan))
<          if (comp.compare(src, currentscan) < 0) {
<          // start a new run
<          currentscan.close();
<          currenttemp = new TempTable(sch, tx);
<          temps.add(currenttemp);
<          currentscan = (UpdateScan) currenttemp.open();
<       }
<       currentscan.close();
<       return temps;
<    }
<    
<    private List<TempTable> doAMergeIteration(List<TempTable> runs) {
<       List<TempTable> result = new ArrayList<TempTable>();
<       while (runs.size() > 1) {
<          TempTable p1 = runs.remove(0);
<          TempTable p2 = runs.remove(0);
<          result.add(mergeTwoRuns(p1, p2));
<       }
<       if (runs.size() == 1)
<          result.add(runs.get(0));
<       return result;
<    }
<    
<    private TempTable mergeTwoRuns(TempTable p1, TempTable p2) {
<       Scan src1 = p1.open();
<       Scan src2 = p2.open();
<       TempTable result = new TempTable(sch, tx);
<       UpdateScan dest = result.open();
<       
<       boolean hasmore1 = src1.next();
<       boolean hasmore2 = src2.next();
<       while (hasmore1 && hasmore2)
<          if (comp.compare(src1, src2) < 0)
<          hasmore1 = copy(src1, dest);
<       else
<          hasmore2 = copy(src2, dest);
<       
<       if (hasmore1)
<          while (hasmore1)
<          hasmore1 = copy(src1, dest);
<       else
<          while (hasmore2)
<          hasmore2 = copy(src2, dest);
<       src1.close();
<       src2.close();
<       dest.close();
<       return result;
<    }
<    
<    private boolean copy(Scan src, UpdateScan dest) {
<       dest.insert();
<       for (String fldname : sch.fields())
<          dest.setVal(fldname, src.getVal(fldname));
<       return src.next();
<    }
< }
---
> package simpledb.materialize;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> 
> import java.util.*;
> 
> /**
>  * The Plan class for the <i>sort</i> operator.
>  * @author Edward Sciore
>  */
> public class SortPlan implements Plan {
>    private Plan p;
>    private Transaction tx;
>    private Schema sch;
>    private RecordComparator comp;
>    
>    /**
>     * Creates a sort plan for the specified query.
>     * @param p the plan for the underlying query
>     * @param sortfields the fields to sort by
>     * @param tx the calling transaction
>     */
>    public SortPlan(Plan p, List<String> sortfields, Transaction tx) {
>       this.p = p;
>       this.tx = tx;
>       sch = p.schema();
>       comp = new RecordComparator(sortfields);
>    }
>    
>    /**
>     * This method is where most of the action is.
>     * Up to 2 sorted temporary tables are created,
>     * and are passed into SortScan for final merging.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Scan src = p.open();
>       List<TempTable> runs = splitIntoRuns(src);
>       src.close();
>         /*
>          * CS 4432 Project 2
>          * Logging information
>          */
>         int i = 0;
>         while (runs.size() > 2) {
>             i++;
>             System.out.println("Doing merge iteration #" + i + ", Merging " + runs.size() + " runs.");
>             runs = doAMergeIteration(runs);
>         }
>       return new SortScan(runs, comp);
>    }
>    
>    /**
>     * Returns the number of blocks in the sorted table,
>     * which is the same as it would be in a
>     * materialized table.
>     * It does <i>not</i> include the one-time cost
>     * of materializing and sorting the records.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       // does not include the one-time cost of sorting
>       Plan mp = new MaterializePlan(p, tx); // not opened; just for analysis
>       return mp.blocksAccessed();
>    }
>    
>    /**
>     * Returns the number of records in the sorted table,
>     * which is the same as in the underlying query.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return p.recordsOutput();
>    }
>    
>    /**
>     * Returns the number of distinct field values in
>     * the sorted table, which is the same as in
>     * the underlying query.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       return p.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the sorted table, which
>     * is the same as in the underlying query.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return sch;
>    }
>    
>    private List<TempTable> splitIntoRuns(Scan src) {
>       List<TempTable> temps = new ArrayList<TempTable>();
>       src.beforeFirst();
>       if (!src.next())
>          return temps;
>       TempTable currenttemp = new TempTable(sch, tx);
>       temps.add(currenttemp);
>       UpdateScan currentscan = currenttemp.open();
>       while (copy(src, currentscan))
>          if (comp.compare(src, currentscan) < 0) {
>          // start a new run
>          currentscan.close();
>          currenttemp = new TempTable(sch, tx);
>          temps.add(currenttemp);
>          currentscan = (UpdateScan) currenttemp.open();
>       }
>       currentscan.close();
>       return temps;
>    }
>    
>    private List<TempTable> doAMergeIteration(List<TempTable> runs) {
>       List<TempTable> result = new ArrayList<TempTable>();
>       while (runs.size() > 1) {
>          TempTable p1 = runs.remove(0);
>          TempTable p2 = runs.remove(0);
>          result.add(mergeTwoRuns(p1, p2));
>       }
>       if (runs.size() == 1)
>          result.add(runs.get(0));
>       return result;
>    }
>    
>    private TempTable mergeTwoRuns(TempTable p1, TempTable p2) {
>       Scan src1 = p1.open();
>       Scan src2 = p2.open();
>       TempTable result = new TempTable(sch, tx);
>       UpdateScan dest = result.open();
>       
>       boolean hasmore1 = src1.next();
>       boolean hasmore2 = src2.next();
>       while (hasmore1 && hasmore2)
>          if (comp.compare(src1, src2) < 0)
>          hasmore1 = copy(src1, dest);
>       else
>          hasmore2 = copy(src2, dest);
>       
>       if (hasmore1)
>          while (hasmore1)
>          hasmore1 = copy(src1, dest);
>       else
>          while (hasmore2)
>          hasmore2 = copy(src2, dest);
>       src1.close();
>       src2.close();
>       dest.close();
>       return result;
>    }
>    
>    private boolean copy(Scan src, UpdateScan dest) {
>       dest.insert();
>       for (String fldname : sch.fields())
>          dest.setVal(fldname, src.getVal(fldname));
>       return src.next();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/SortScan.java ../cs4432-proj2/src/simpledb/materialize/SortScan.java
16,19c16,19
<    private UpdateScan s1, s2=null, currentscan=null;
<    private RecordComparator comp;
<    private boolean hasmore1, hasmore2=false;
<    private List<RID> savedposition;
---
>    protected UpdateScan s1, s2=null, currentscan=null;
>    protected RecordComparator comp;
>    protected boolean hasmore1, hasmore2=false;
>    protected List<RID> savedposition;
37c37
<    
---
> 
diff -r simpledb/SimpleDB_2.10/simpledb/materialize/TempTable.java ../cs4432-proj2/src/simpledb/materialize/TempTable.java
1,49c1,49
< package simpledb.materialize;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.query.*;
< 
< /**
<  * A class that creates temporary tables.
<  * A temporary table is not registered in the catalog.
<  * The class therefore has a method getTableInfo to return the 
<  * table's metadata. 
<  * @author Edward Sciore
<  */
< public class TempTable {
<    private static int nextTableNum = 0;
<    private TableInfo ti;
<    private Transaction tx;
<    
<    /**
<     * Allocates a name for for a new temporary table
<     * having the specified schema.
<     * @param sch the new table's schema
<     * @param tx the calling transaction
<     */
<    public TempTable(Schema sch, Transaction tx) {
<       String tblname = nextTableName();
<       ti = new TableInfo(tblname, sch);
<       this.tx = tx;
<    }
<    
<    /**
<     * Opens a table scan for the temporary table.
<     */
<    public UpdateScan open() {
<       return new TableScan(ti, tx);
<    }
<    
<    /**
<     * Return the table's metadata.
<     * @return the table's metadata
<     */
<    public TableInfo getTableInfo() {
<       return ti;
<    }
<    
<    private static synchronized String nextTableName() {
<       nextTableNum++;
<       return "temp" + nextTableNum;
<    }
---
> package simpledb.materialize;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.query.*;
> 
> /**
>  * A class that creates temporary tables.
>  * A temporary table is not registered in the catalog.
>  * The class therefore has a method getTableInfo to return the 
>  * table's metadata. 
>  * @author Edward Sciore
>  */
> public class TempTable {
>     private static int nextTableNum = 0;
>     private TableInfo ti;
>     private Transaction tx;
>    
>     /**
>      * Allocates a name for for a new temporary table
>      * having the specified schema.
>      * @param sch the new table's schema
>      * @param tx the calling transaction
>      */
>     public TempTable(Schema sch, Transaction tx) {
>         String tblname = nextTableName();
>         ti = new TableInfo(tblname, sch);
>         this.tx = tx;
>     }
>    
>     /**
>      * Opens a table scan for the temporary table.
>      */
>     public UpdateScan open() {
>         return new TableScan(ti, tx);
>     }
>    
>     /**
>      * Return the table's metadata.
>      * @return the table's metadata
>      */
>     public TableInfo getTableInfo() {
>         return ti;
>     }
>    
>     private static synchronized String nextTableName() {
>         nextTableNum++;
>         return "temp" + nextTableNum;
>     }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/IndexInfo.java ../cs4432-proj2/src/simpledb/metadata/IndexInfo.java
4a5,12
> 
> import simpledb.index.Index;
> import simpledb.index.IndexType;
> import simpledb.index.btree.BTreeIndex;
> import simpledb.index.hash.ExtensibleHashIndex;
> import simpledb.index.hash.HashIndex;
> import simpledb.record.Schema;
> import simpledb.record.TableInfo;
7,11d14
< import simpledb.record.*;
< import simpledb.index.Index;
< import simpledb.index.hash.HashIndex; 
< import simpledb.index.btree.BTreeIndex; //in case we change to btree indexing
< 
14,18c17,20
<  * The information about an index.
<  * This information is used by the query planner in order to
<  * estimate the costs of using the index,
<  * and to obtain the schema of the index records.
<  * Its methods are essentially the same as those of Plan.
---
>  * The information about an index. This information is used by the query planner
>  * in order to estimate the costs of using the index, and to obtain the schema
>  * of the index records. Its methods are essentially the same as those of Plan.
>  *
22,115c24,151
<    private String idxname, fldname;
<    private Transaction tx;
<    private TableInfo ti;
<    private StatInfo si;
<    
<    /**
<     * Creates an IndexInfo object for the specified index.
<     * @param idxname the name of the index
<     * @param tblname the name of the table
<     * @param fldname the name of the indexed field
<     * @param tx the calling transaction
<     */
<    public IndexInfo(String idxname, String tblname, String fldname,
<                     Transaction tx) {
<       this.idxname = idxname;
<       this.fldname = fldname;
<       this.tx = tx;
<       ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
<       si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
<    }
<    
<    /**
<     * Opens the index described by this object.
<     * @return the Index object associated with this information
<     */
<    public Index open() {
<       Schema sch = schema();
<       // Create new HashIndex for hash indexing
<       return new HashIndex(idxname, sch, tx);
<    }
<    
<    /**
<     * Estimates the number of block accesses required to
<     * find all index records having a particular search key.
<     * The method uses the table's metadata to estimate the
<     * size of the index file and the number of index records
<     * per block.
<     * It then passes this information to the traversalCost
<     * method of the appropriate index type,
<     * which provides the estimate.
<     * @return the number of block accesses required to traverse the index
<     */
<    public int blocksAccessed() {
<       TableInfo idxti = new TableInfo("", schema());
<       int rpb = BLOCK_SIZE / idxti.recordLength();
<       int numblocks = si.recordsOutput() / rpb;
<       // Call HashIndex.searchCost for hash indexing
<       return HashIndex.searchCost(numblocks, rpb);
<    }
<    
<    /**
<     * Returns the estimated number of records having a
<     * search key.  This value is the same as doing a select
<     * query; that is, it is the number of records in the table
<     * divided by the number of distinct values of the indexed field.
<     * @return the estimated number of records having a search key
<     */
<    public int recordsOutput() {
<       return si.recordsOutput() / si.distinctValues(fldname);
<    }
<    
<    /** 
<     * Returns the distinct values for a specified field 
<     * in the underlying table, or 1 for the indexed field.
<     * @param fname the specified field
<     */
<    public int distinctValues(String fname) {
<       if (fldname.equals(fname))
<          return 1;
<       else 
<          return Math.min(si.distinctValues(fldname), recordsOutput());
<    }
<    
<    /**
<     * Returns the schema of the index records.
<     * The schema consists of the dataRID (which is
<     * represented as two integers, the block number and the
<     * record ID) and the dataval (which is the indexed field).
<     * Schema information about the indexed field is obtained
<     * via the table's metadata.
<     * @return the schema of the index records
<     */
<    private Schema schema() {
<       Schema sch = new Schema();
<       sch.addIntField("block");
<       sch.addIntField("id");
<       if (ti.schema().type(fldname) == INTEGER)
<          sch.addIntField("dataval");
<       else {
<          int fldlen = ti.schema().length(fldname);
<          sch.addStringField("dataval", fldlen);
<       }
<       return sch;
<    }
---
>     private String idxname, fldname;
>     private Transaction tx;
>     private TableInfo ti;
>     private StatInfo si;
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added the index type to store the index type.
>      */
>     protected IndexType type;
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added the index type to pass in the index type.
>      *
>      * Creates an IndexInfo object for the specified index.
>      *
>      * @param idxname
>      *            the name of the index
>      * @param tblname
>      *            the name of the table
>      * @param fldname
>      *            the name of the indexed field
>      * @param tx
>      *            the calling transaction
>      */
>     public IndexInfo(String idxname, String tblname, String fldname, Transaction tx, IndexType type) {
>         this.idxname = idxname;
>         this.fldname = fldname;
>         this.tx = tx;
>         this.type = type;
>         ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
>         si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added the check of index type to create or open the index of the
>      * specified type. If incorrect types are passed in, a default HashIndex is
>      * used.
>      *
>      * Opens the index described by this object.
>      *
>      * @return the Index object associated with this information
>      */
>     public Index open() {
>         Schema sch = schema();
> 
>         // Select index type based on type parameters
>         if (type.equals(IndexType.sh)) {
>             return new HashIndex(idxname, sch, tx);
>         } else if (type.equals(IndexType.bt)) {
>             return new BTreeIndex(idxname, sch, tx);
>         } else if (type.equals(IndexType.eh)) {
>             return new ExtensibleHashIndex(idxname, sch, tx);
>         } else {
>             // Return hash index if arguments are invalid
>             return new HashIndex(idxname, sch, tx);
>         }
>     }
> 
>     /**
>      * Estimates the number of block accesses required to find all index records
>      * having a particular search key. The method uses the table's metadata to
>      * estimate the size of the index file and the number of index records per
>      * block. It then passes this information to the traversalCost method of the
>      * appropriate index type, which provides the estimate.
>      *
>      * @return the number of block accesses required to traverse the index
>      */
>     public int blocksAccessed() {
>         // TODO Change estimation to be relative to the index type
>         TableInfo idxti = new TableInfo("", schema());
>         int rpb = BLOCK_SIZE / idxti.recordLength();
>         int numblocks = si.recordsOutput() / rpb;
>         // Call HashIndex.searchCost for hash indexing
>         return HashIndex.searchCost(numblocks, rpb);
>     }
> 
>     /**
>      * Returns the estimated number of records having a search key. This value
>      * is the same as doing a select query; that is, it is the number of records
>      * in the table divided by the number of distinct values of the indexed
>      * field.
>      *
>      * @return the estimated number of records having a search key
>      */
>     public int recordsOutput() {
>         return si.recordsOutput() / si.distinctValues(fldname);
>     }
> 
>     /**
>      * Returns the distinct values for a specified field in the underlying
>      * table, or 1 for the indexed field.
>      *
>      * @param fname
>      *            the specified field
>      */
>     public int distinctValues(String fname) {
>         if (fldname.equals(fname))
>             return 1;
>         else
>             return Math.min(si.distinctValues(fldname), recordsOutput());
>     }
> 
>     /**
>      * Returns the schema of the index records. The schema consists of the
>      * dataRID (which is represented as two integers, the block number and the
>      * record ID) and the dataval (which is the indexed field). Schema
>      * information about the indexed field is obtained via the table's metadata.
>      *
>      * @return the schema of the index records
>      */
>     private Schema schema() {
>         Schema sch = new Schema();
>         sch.addIntField("block");
>         sch.addIntField("id");
>         if (ti.schema().type(fldname) == INTEGER)
>             sch.addIntField("dataval");
>         else {
>             int fldlen = ti.schema().length(fldname);
>             sch.addStringField("dataval", fldlen);
>         }
>         return sch;
>     }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/IndexMgr.java ../cs4432-proj2/src/simpledb/metadata/IndexMgr.java
1,72c1,113
< package simpledb.metadata;
< 
< import static simpledb.metadata.TableMgr.MAX_NAME;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import java.util.*;
< 
< /**
<  * The index manager.
<  * The index manager has similar functionalty to the table manager.
<  * @author Edward Sciore
<  */
< public class IndexMgr {
<    private TableInfo ti;
<    
<    /**
<     * Creates the index manager.
<     * This constructor is called during system startup.
<     * If the database is new, then the <i>idxcat</i> table is created.
<     * @param isnew indicates whether this is a new database
<     * @param tx the system startup transaction
<     */
<    public IndexMgr(boolean isnew, TableMgr tblmgr, Transaction tx) {
<       if (isnew) {
<          Schema sch = new Schema();
<          sch.addStringField("indexname", MAX_NAME);
<          sch.addStringField("tablename", MAX_NAME);
<          sch.addStringField("fieldname", MAX_NAME);
<          tblmgr.createTable("idxcat", sch, tx);
<       }
<       ti = tblmgr.getTableInfo("idxcat", tx);
<    }
<    
<    /**
<     * Creates an index of the specified type for the specified field.
<     * A unique ID is assigned to this index, and its information
<     * is stored in the idxcat table.
<     * @param idxname the name of the index
<     * @param tblname the name of the indexed table
<     * @param fldname the name of the indexed field
<     * @param tx the calling transaction
<     */
<    public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
<       RecordFile rf = new RecordFile(ti, tx);
<       rf.insert();
<       rf.setString("indexname", idxname);
<       rf.setString("tablename", tblname);
<       rf.setString("fieldname", fldname);
<       rf.close();
<    }
<    
<    /**
<     * Returns a map containing the index info for all indexes
<     * on the specified table.
<     * @param tblname the name of the table
<     * @param tx the calling transaction
<     * @return a map of IndexInfo objects, keyed by their field names
<     */
<    public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
<       Map<String,IndexInfo> result = new HashMap<String,IndexInfo>();
<       RecordFile rf = new RecordFile(ti, tx);
<       while (rf.next())
<          if (rf.getString("tablename").equals(tblname)) {
<          String idxname = rf.getString("indexname");
<          String fldname = rf.getString("fieldname");
<          IndexInfo ii = new IndexInfo(idxname, tblname, fldname, tx);
<          result.put(fldname, ii);
<       }
<       rf.close();
<       return result;
<    }
< }
---
> package simpledb.metadata;
> 
> import static simpledb.metadata.TableMgr.MAX_NAME;
> 
> import java.util.HashMap;
> import java.util.Map;
> 
> import simpledb.index.IndexType;
> import simpledb.record.RecordFile;
> import simpledb.record.Schema;
> import simpledb.record.TableInfo;
> import simpledb.tx.Transaction;
> 
> /**
>  * The index manager. The index manager has similar functionality to the table
>  * manager.
>  *
>  * @author Edward Sciore
>  */
> public class IndexMgr {
>     private TableInfo ti;
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added another field to contain the index type.
>      *
>      * Creates the index manager. This constructor is called during system
>      * startup. If the database is new, then the <i>idxcat</i> table is created.
>      *
>      * @param isnew
>      *            indicates whether this is a new database
>      * @param tx
>      *            the system startup transaction
>      */
>     public IndexMgr(boolean isnew, TableMgr tblmgr, Transaction tx) {
>         if (isnew) {
>             Schema sch = new Schema();
>             sch.addStringField("indexname", MAX_NAME);
>             sch.addStringField("tablename", MAX_NAME);
>             sch.addStringField("fieldname", MAX_NAME);
> 
>             // Added this field for index type.
>             sch.addStringField("indextype", MAX_NAME);
>             tblmgr.createTable("idxcat", sch, tx);
>         }
>         ti = tblmgr.getTableInfo("idxcat", tx);
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added another parameter to pass in the index type.
>      *
>      * Creates an index of the specified type for the specified field. A unique
>      * ID is assigned to this index, and its information is stored in the idxcat
>      * table.
>      *
>      * @param idxname
>      *            the name of the index
>      * @param tblname
>      *            the name of the indexed table
>      * @param fldname
>      *            the name of the indexed field
>      * @param tx
>      *            the calling transaction
>      * @param type
>      *            The type of index to be created.
>      */
>     public void createIndex(String idxname, String tblname, String fldname, Transaction tx, IndexType type) {
>         RecordFile rf = new RecordFile(ti, tx);
>         rf.insert();
>         rf.setString("indexname", idxname);
>         rf.setString("tablename", tblname);
>         rf.setString("fieldname", fldname);
> 
>         // Sets the index type field to the input index type
>         rf.setString("indextype", type.toString());
>         rf.close();
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added the "indextype" field to the record file for index type
>      * information.
>      *
>      * Returns a map containing the index info for all indexes on the specified
>      * table.
>      *
>      * @param tblname
>      *            the name of the table
>      * @param tx
>      *            the calling transaction
>      * @return a map of IndexInfo objects, keyed by their field names
>      */
>     public Map<String, IndexInfo> getIndexInfo(String tblname, Transaction tx) {
>         Map<String, IndexInfo> result = new HashMap<String, IndexInfo>();
>         RecordFile rf = new RecordFile(ti, tx);
>         while (rf.next())
>             if (rf.getString("tablename").equals(tblname)) {
>                 String idxname = rf.getString("indexname");
>                 String fldname = rf.getString("fieldname");
> 
>                 // Gets the index type field information
>                 String indextype = rf.getString("indextype");
>                 IndexInfo ii = new IndexInfo(idxname, tblname, fldname, tx, IndexType.valueOf(indextype));
>                 result.put(fldname, ii);
>             }
>         rf.close();
>         return result;
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/MetadataMgr.java ../cs4432-proj2/src/simpledb/metadata/MetadataMgr.java
1,47c1,62
< package simpledb.metadata;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import java.util.Map;
< 
< public class MetadataMgr {
<    private static TableMgr  tblmgr;
<    private static ViewMgr   viewmgr;
<    private static StatMgr   statmgr;
<    private static IndexMgr  idxmgr;
<    
<    public MetadataMgr(boolean isnew, Transaction tx) {
<       tblmgr  = new TableMgr(isnew, tx);
<       viewmgr = new ViewMgr(isnew, tblmgr, tx);
<       statmgr = new StatMgr(tblmgr, tx);
<       idxmgr  = new IndexMgr(isnew, tblmgr, tx);
<    }
<    
<    public void createTable(String tblname, Schema sch, Transaction tx) {
<       tblmgr.createTable(tblname, sch, tx);
<    }
<    
<    public TableInfo getTableInfo(String tblname, Transaction tx) {
<       return tblmgr.getTableInfo(tblname, tx);
<    }
<    
<    public void createView(String viewname, String viewdef, Transaction tx) {
<       viewmgr.createView(viewname, viewdef, tx);
<    }
<    
<    public String getViewDef(String viewname, Transaction tx) {
<       return viewmgr.getViewDef(viewname, tx);
<    }
<    
<    public void createIndex(String idxname, String tblname, String fldname, Transaction tx) {
<       idxmgr.createIndex(idxname, tblname, fldname, tx);
<    }
<    
<    public Map<String,IndexInfo> getIndexInfo(String tblname, Transaction tx) {
<       return idxmgr.getIndexInfo(tblname, tx);
<    }
<    
<    public StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
<       return statmgr.getStatInfo(tblname, ti, tx);
<    }
< }
---
> package simpledb.metadata;
> 
> import java.util.Map;
> 
> import simpledb.index.IndexType;
> import simpledb.record.Schema;
> import simpledb.record.TableInfo;
> import simpledb.tx.Transaction;
> 
> public class MetadataMgr {
>     private static TableMgr tblmgr;
>     private static ViewMgr viewmgr;
>     private static StatMgr statmgr;
>     private static IndexMgr idxmgr;
> 
>     public MetadataMgr(boolean isnew, Transaction tx) {
>         tblmgr = new TableMgr(isnew, tx);
>         viewmgr = new ViewMgr(isnew, tblmgr, tx);
>         statmgr = new StatMgr(tblmgr, tx);
>         idxmgr = new IndexMgr(isnew, tblmgr, tx);
>     }
> 
>     public void createTable(String tblname, Schema sch, Transaction tx) {
>         tblmgr.createTable(tblname, sch, tx);
>     }
> 
>     public void createTable(String tblname, Schema sch, Transaction tx, String sortedField) {
>         tblmgr.createTable(tblname, sch, tx, sortedField);
>     }
> 
>     public TableInfo getTableInfo(String tblname, Transaction tx) {
>         return tblmgr.getTableInfo(tblname, tx);
>     }
> 
>     public void createView(String viewname, String viewdef, Transaction tx) {
>         viewmgr.createView(viewname, viewdef, tx);
>     }
> 
>     public String getViewDef(String viewname, Transaction tx) {
>         return viewmgr.getViewDef(viewname, tx);
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We modified the arguments passed to createIndex() to pass the index type.
>      * 
>      * @param type
>      *            The type of index to create on the table.
>      */
>     public void createIndex(String idxname, String tblname, String fldname, Transaction tx, IndexType type) {
>         idxmgr.createIndex(idxname, tblname, fldname, tx, type);
>     }
> 
>     public Map<String, IndexInfo> getIndexInfo(String tblname, Transaction tx) {
>         return idxmgr.getIndexInfo(tblname, tx);
>     }
> 
>     public StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
>         return statmgr.getStatInfo(tblname, ti, tx);
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/StatInfo.java ../cs4432-proj2/src/simpledb/metadata/StatInfo.java
1,52c1,52
< package simpledb.metadata;
< 
< /**
<  * Holds three pieces of statistical information about a table:
<  * the number of blocks, the number of records,
<  * and the number of distinct values for each field. 
<  * @author Edward Sciore
<  */
< public class StatInfo {
<    private int numBlocks;
<    private int numRecs;
<    
<    /**
<     * Creates a StatInfo object.
<     * Note that the number of distinct values is not
<     * passed into the constructor.
<     * The object fakes this value.
<     * @param numblocks the number of blocks in the table
<     * @param numrecs the number of records in the table
<     */
<    public StatInfo(int numblocks, int numrecs) {
<       this.numBlocks = numblocks;
<       this.numRecs   = numrecs;
<    }
<    
<    /**
<     * Returns the estimated number of blocks in the table.
<     * @return the estimated number of blocks in the table
<     */
<    public int blocksAccessed() {
<       return numBlocks;
<    }
<    
<    /**
<     * Returns the estimated number of records in the table.
<     * @return the estimated number of records in the table
<     */
<    public int recordsOutput() {
<       return numRecs;
<    }
<    
<    /**
<     * Returns the estimated number of distinct values
<     * for the specified field.
<     * In actuality, this estimate is a complete guess.
<     * @param fldname the name of the field
<     * @return a guess as to the number of distinct field values
<     */
<    public int distinctValues(String fldname) {
<       return 1 + (numRecs / 3);
<    }
< }
---
> package simpledb.metadata;
> 
> /**
>  * Holds three pieces of statistical information about a table:
>  * the number of blocks, the number of records,
>  * and the number of distinct values for each field. 
>  * @author Edward Sciore
>  */
> public class StatInfo {
>    private int numBlocks;
>    private int numRecs;
>    
>    /**
>     * Creates a StatInfo object.
>     * Note that the number of distinct values is not
>     * passed into the constructor.
>     * The object fakes this value.
>     * @param numblocks the number of blocks in the table
>     * @param numrecs the number of records in the table
>     */
>    public StatInfo(int numblocks, int numrecs) {
>       this.numBlocks = numblocks;
>       this.numRecs   = numrecs;
>    }
>    
>    /**
>     * Returns the estimated number of blocks in the table.
>     * @return the estimated number of blocks in the table
>     */
>    public int blocksAccessed() {
>       return numBlocks;
>    }
>    
>    /**
>     * Returns the estimated number of records in the table.
>     * @return the estimated number of records in the table
>     */
>    public int recordsOutput() {
>       return numRecs;
>    }
>    
>    /**
>     * Returns the estimated number of distinct values
>     * for the specified field.
>     * In actuality, this estimate is a complete guess.
>     * @param fldname the name of the field
>     * @return a guess as to the number of distinct field values
>     */
>    public int distinctValues(String fldname) {
>       return 1 + (numRecs / 3);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/StatMgr.java ../cs4432-proj2/src/simpledb/metadata/StatMgr.java
1,75c1,75
< package simpledb.metadata;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import java.util.*;
< 
< /**
<  * The statistics manager, which is responsible for
<  * keeping statistical information about each table.
<  * The manager does not store this information in the database.
<  * Instead, it calculates this information on system startup,
<  * and periodically refreshes it.
<  * @author Edward Sciore
<  */
< class StatMgr {
<    private TableMgr tblMgr;
<    private Map<String,StatInfo> tablestats;
<    private int numcalls;
<    
<    /**
<     * Creates the statistics manager.
<     * The initial statistics are calculated by
<     * traversing the entire database.
<     * @param tx the startup transaction
<     */
<    public StatMgr(TableMgr tblMgr, Transaction tx) {
<       this.tblMgr = tblMgr;
<       refreshStatistics(tx);
<    }
<    
<    /**
<     * Returns the statistical information about the specified table.
<     * @param tblname the name of the table
<     * @param ti the table's metadata
<     * @param tx the calling transaction
<     * @return the statistical information about the table
<     */
<    public synchronized StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
<       numcalls++;
<       if (numcalls > 100)
<          refreshStatistics(tx);
<       StatInfo si = tablestats.get(tblname);
<       if (si == null) {
<          si = calcTableStats(ti, tx);
<          tablestats.put(tblname, si);
<       }
<       return si;
<    }
<    
<    private synchronized void refreshStatistics(Transaction tx) {
<       tablestats = new HashMap<String,StatInfo>();
<       numcalls = 0;
<       TableInfo tcatmd = tblMgr.getTableInfo("tblcat", tx);
<       RecordFile tcatfile = new RecordFile(tcatmd, tx);
<       while(tcatfile.next()) {
<          String tblname = tcatfile.getString("tblname");
<          TableInfo md = tblMgr.getTableInfo(tblname, tx);
<          StatInfo si = calcTableStats(md, tx);
<          tablestats.put(tblname, si);
<       }
<       tcatfile.close();
<    }
<    
<    private synchronized StatInfo calcTableStats(TableInfo ti, Transaction tx) {
<       int numRecs = 0;
<       RecordFile rf = new RecordFile(ti, tx);
<       int numblocks = 0;
<       while (rf.next()) {
<          numRecs++;
<          numblocks = rf.currentRid().blockNumber() + 1;
<       }
<       rf.close();
<       return new StatInfo(numblocks, numRecs);
<    }
< }
---
> package simpledb.metadata;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import java.util.*;
> 
> /**
>  * The statistics manager, which is responsible for
>  * keeping statistical information about each table.
>  * The manager does not store this information in the database.
>  * Instead, it calculates this information on system startup,
>  * and periodically refreshes it.
>  * @author Edward Sciore
>  */
> class StatMgr {
>    private TableMgr tblMgr;
>    private Map<String,StatInfo> tablestats;
>    private int numcalls;
>    
>    /**
>     * Creates the statistics manager.
>     * The initial statistics are calculated by
>     * traversing the entire database.
>     * @param tx the startup transaction
>     */
>    public StatMgr(TableMgr tblMgr, Transaction tx) {
>       this.tblMgr = tblMgr;
>       refreshStatistics(tx);
>    }
>    
>    /**
>     * Returns the statistical information about the specified table.
>     * @param tblname the name of the table
>     * @param ti the table's metadata
>     * @param tx the calling transaction
>     * @return the statistical information about the table
>     */
>    public synchronized StatInfo getStatInfo(String tblname, TableInfo ti, Transaction tx) {
>       numcalls++;
>       if (numcalls > 100)
>          refreshStatistics(tx);
>       StatInfo si = tablestats.get(tblname);
>       if (si == null) {
>          si = calcTableStats(ti, tx);
>          tablestats.put(tblname, si);
>       }
>       return si;
>    }
>    
>    private synchronized void refreshStatistics(Transaction tx) {
>       tablestats = new HashMap<String,StatInfo>();
>       numcalls = 0;
>       TableInfo tcatmd = tblMgr.getTableInfo("tblcat", tx);
>       RecordFile tcatfile = new RecordFile(tcatmd, tx);
>       while(tcatfile.next()) {
>          String tblname = tcatfile.getString("tblname");
>          TableInfo md = tblMgr.getTableInfo(tblname, tx);
>          StatInfo si = calcTableStats(md, tx);
>          tablestats.put(tblname, si);
>       }
>       tcatfile.close();
>    }
>    
>    private synchronized StatInfo calcTableStats(TableInfo ti, Transaction tx) {
>       int numRecs = 0;
>       RecordFile rf = new RecordFile(ti, tx);
>       int numblocks = 0;
>       while (rf.next()) {
>          numRecs++;
>          numblocks = rf.currentRid().blockNumber() + 1;
>       }
>       rf.close();
>       return new StatInfo(numblocks, numRecs);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/TableMgr.java ../cs4432-proj2/src/simpledb/metadata/TableMgr.java
1,111c1,133
< package simpledb.metadata;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import java.util.*;
< 
< /**
<  * The table manager.
<  * There are methods to create a table, save the metadata
<  * in the catalog, and obtain the metadata of a
<  * previously-created table.
<  * @author Edward Sciore
<  *
<  */
< public class TableMgr {
<    /**
<     * The maximum number of characters in any
<     * tablename or fieldname.
<     * Currently, this value is 16.
<     */
<    public static final int MAX_NAME = 16;
<    
<    private TableInfo tcatInfo, fcatInfo;
<    
<    /**
<     * Creates a new catalog manager for the database system.
<     * If the database is new, then the two catalog tables
<     * are created.
<     * @param isNew has the value true if the database is new
<     * @param tx the startup transaction
<     */
<    public TableMgr(boolean isNew, Transaction tx) {
<       Schema tcatSchema = new Schema();
<       tcatSchema.addStringField("tblname", MAX_NAME);
<       tcatSchema.addIntField("reclength");
<       tcatInfo = new TableInfo("tblcat", tcatSchema);
<       
<       Schema fcatSchema = new Schema();
<       fcatSchema.addStringField("tblname", MAX_NAME);
<       fcatSchema.addStringField("fldname", MAX_NAME);
<       fcatSchema.addIntField("type");
<       fcatSchema.addIntField("length");
<       fcatSchema.addIntField("offset");
<       fcatInfo = new TableInfo("fldcat", fcatSchema);
<       
<       if (isNew) {
<          createTable("tblcat", tcatSchema, tx);
<          createTable("fldcat", fcatSchema, tx);
<       }
<    }
<    
<    /**
<     * Creates a new table having the specified name and schema.
<     * @param tblname the name of the new table
<     * @param sch the table's schema
<     * @param tx the transaction creating the table
<     */
<    public void createTable(String tblname, Schema sch, Transaction tx) {
<       TableInfo ti = new TableInfo(tblname, sch);
<       // insert one record into tblcat
<       RecordFile tcatfile = new RecordFile(tcatInfo, tx);
<       tcatfile.insert();
<       tcatfile.setString("tblname", tblname);
<       tcatfile.setInt("reclength", ti.recordLength());
<       tcatfile.close();
<       
<       // insert a record into fldcat for each field
<       RecordFile fcatfile = new RecordFile(fcatInfo, tx);
<       for (String fldname : sch.fields()) {
<          fcatfile.insert();
<          fcatfile.setString("tblname", tblname);
<          fcatfile.setString("fldname", fldname);
<          fcatfile.setInt   ("type",   sch.type(fldname));
<          fcatfile.setInt   ("length", sch.length(fldname));
<          fcatfile.setInt   ("offset", ti.offset(fldname));
<       }
<       fcatfile.close();
<    }
<    
<    /**
<     * Retrieves the metadata for the specified table
<     * out of the catalog.
<     * @param tblname the name of the table
<     * @param tx the transaction
<     * @return the table's stored metadata
<     */
<    public TableInfo getTableInfo(String tblname, Transaction tx) {
<       RecordFile tcatfile = new RecordFile(tcatInfo, tx);
<       int reclen = -1;
<       while (tcatfile.next())
<          if(tcatfile.getString("tblname").equals(tblname)) {
<          reclen = tcatfile.getInt("reclength");
<          break;
<       }
<       tcatfile.close();
<       
<       RecordFile fcatfile = new RecordFile(fcatInfo, tx);
<       Schema sch = new Schema();
<       Map<String,Integer> offsets = new HashMap<String,Integer>();
<       while (fcatfile.next())
<          if (fcatfile.getString("tblname").equals(tblname)) {
<          String fldname = fcatfile.getString("fldname");
<          int fldtype    = fcatfile.getInt("type");
<          int fldlen     = fcatfile.getInt("length");
<          int offset     = fcatfile.getInt("offset");
<          offsets.put(fldname, offset);
<          sch.addField(fldname, fldtype, fldlen);
<       }
<       fcatfile.close();
<       return new TableInfo(tblname, sch, offsets, reclen);
<    }
---
> package simpledb.metadata;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import java.util.*;
> 
> /**
>  * The table manager.
>  * There are methods to create a table, save the metadata
>  * in the catalog, and obtain the metadata of a
>  * previously-created table.
>  * @author Edward Sciore
>  *
>  * CS 4432 Project 2
>  *
>  *  File was modified to support storing the sorted table flag on disk
>  *
>  */
> public class TableMgr {
>    /**
>     * The maximum number of characters in any
>     * tablename or fieldname.
>     * Currently, this value is 16.
>     */
>    public static final int MAX_NAME = 16;
>    
>    private TableInfo tcatInfo, fcatInfo;
>    
>    /**
>     * Creates a new catalog manager for the database system.
>     * If the database is new, then the two catalog tables
>     * are created.
>     * @param isNew has the value true if the database is new
>     * @param tx the startup transaction
>     */
>    public TableMgr(boolean isNew, Transaction tx) {
>       Schema tcatSchema = new Schema();
>       tcatSchema.addStringField("tblname", MAX_NAME);
>       tcatSchema.addStringField("sortname", MAX_NAME);
>       tcatSchema.addIntField("reclength");
>       tcatInfo = new TableInfo("tblcat", tcatSchema);
>       
>       Schema fcatSchema = new Schema();
>       fcatSchema.addStringField("tblname", MAX_NAME);
>       fcatSchema.addStringField("fldname", MAX_NAME);
>       fcatSchema.addIntField("type");
>       fcatSchema.addIntField("length");
>       fcatSchema.addIntField("offset");
>       fcatInfo = new TableInfo("fldcat", fcatSchema);
>       
>       if (isNew) {
>          createTable("tblcat", tcatSchema, tx);
>          createTable("fldcat", fcatSchema, tx);
>       }
>    }
>    
>    /**
>     * Pass-through
>     * @param tblname the name of the new table
>     * @param sch the table's schema
>     * @param tx the transaction creating the table
>     */
>    public void createTable(String tblname, Schema sch, Transaction tx) {
>         createTable(tblname, sch, tx, "");
>    }
> 
>    /**
>     * Creates a new table having the specified name and schema.
>     * @param tblname the name of the new table
>     * @param sch the table's schema
>     * @param tx the transaction creating the table
>     */
>    public void createTable(String tblname, Schema sch, Transaction tx, String sortedField) {
>       TableInfo ti = new TableInfo(tblname, sch);
>       // insert one record into tblcat
>       RecordFile tcatfile = new RecordFile(tcatInfo, tx);
>       tcatfile.insert();
>       tcatfile.setString("tblname", tblname);
>       tcatfile.setString("sortname", sortedField);
>       tcatfile.setInt("reclength", ti.recordLength());
>       tcatfile.close();
>       
>       // insert a record into fldcat for each field
>       RecordFile fcatfile = new RecordFile(fcatInfo, tx);
>       for (String fldname : sch.fields()) {
>          fcatfile.insert();
>          fcatfile.setString("tblname", tblname);
>          fcatfile.setString("fldname", fldname);
>          fcatfile.setInt   ("type",   sch.type(fldname));
>          fcatfile.setInt   ("length", sch.length(fldname));
>          fcatfile.setInt   ("offset", ti.offset(fldname));
>       }
>       fcatfile.close();
>    }
>    
>    /**
>     * Retrieves the metadata for the specified table
>     * out of the catalog.
>     * @param tblname the name of the table
>     * @param tx the transaction
>     * @return the table's stored metadata
>     */
>    public TableInfo getTableInfo(String tblname, Transaction tx) {
>       RecordFile tcatfile = new RecordFile(tcatInfo, tx);
>       int reclen = -1;
>       String sortname = "";
>       while (tcatfile.next())
>          if(tcatfile.getString("tblname").equals(tblname)) {
>           sortname = tcatfile.getString("sortname");
>          reclen = tcatfile.getInt("reclength");
>          break;
>       }
>       tcatfile.close();
>       
>       RecordFile fcatfile = new RecordFile(fcatInfo, tx);
>       Schema sch = new Schema();
>       Map<String,Integer> offsets = new HashMap<String,Integer>();
>       while (fcatfile.next())
>          if (fcatfile.getString("tblname").equals(tblname)) {
>          String fldname = fcatfile.getString("fldname");
>          int fldtype    = fcatfile.getInt("type");
>          int fldlen     = fcatfile.getInt("length");
>          int offset     = fcatfile.getInt("offset");
>          offsets.put(fldname, offset);
>          sch.addField(fldname, fldtype, fldlen);
>       }
>       fcatfile.close();
>       if (sortname.equals("")) {
>           return new TableInfo(tblname, sch, offsets, reclen);
>       } else {
>           return new TableInfo(tblname, sch, offsets, reclen, true, Arrays.asList(sortname));
>       }
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/metadata/ViewMgr.java ../cs4432-proj2/src/simpledb/metadata/ViewMgr.java
1,41c1,41
< package simpledb.metadata;
< 
< import simpledb.record.*;
< import simpledb.tx.Transaction;
< 
< class ViewMgr {
<    private static final int MAX_VIEWDEF = 100;
<    TableMgr tblMgr;
<    
<    public ViewMgr(boolean isNew, TableMgr tblMgr, Transaction tx) {
<       this.tblMgr = tblMgr;
<       if (isNew) {
<          Schema sch = new Schema();
<          sch.addStringField("viewname", TableMgr.MAX_NAME);
<          sch.addStringField("viewdef", MAX_VIEWDEF);
<          tblMgr.createTable("viewcat", sch, tx);
<       }
<    }
<    
<    public void createView(String vname, String vdef, Transaction tx) {
<       TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
<       RecordFile rf = new RecordFile(ti, tx);
<       rf.insert();
<       rf.setString("viewname", vname);
<       rf.setString("viewdef", vdef);
<       rf.close();
<    }
<    
<    public String getViewDef(String vname, Transaction tx) {
<       String result = null;
<       TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
<       RecordFile rf = new RecordFile(ti, tx);
<       while (rf.next())
<          if (rf.getString("viewname").equals(vname)) {
<          result = rf.getString("viewdef");
<          break;
<       }
<       rf.close();
<       return result;
<    }
< }
---
> package simpledb.metadata;
> 
> import simpledb.record.*;
> import simpledb.tx.Transaction;
> 
> class ViewMgr {
>    private static final int MAX_VIEWDEF = 100;
>    TableMgr tblMgr;
>    
>    public ViewMgr(boolean isNew, TableMgr tblMgr, Transaction tx) {
>       this.tblMgr = tblMgr;
>       if (isNew) {
>          Schema sch = new Schema();
>          sch.addStringField("viewname", TableMgr.MAX_NAME);
>          sch.addStringField("viewdef", MAX_VIEWDEF);
>          tblMgr.createTable("viewcat", sch, tx);
>       }
>    }
>    
>    public void createView(String vname, String vdef, Transaction tx) {
>       TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
>       RecordFile rf = new RecordFile(ti, tx);
>       rf.insert();
>       rf.setString("viewname", vname);
>       rf.setString("viewdef", vdef);
>       rf.close();
>    }
>    
>    public String getViewDef(String vname, Transaction tx) {
>       String result = null;
>       TableInfo ti = tblMgr.getTableInfo("viewcat", tx);
>       RecordFile rf = new RecordFile(ti, tx);
>       while (rf.next())
>          if (rf.getString("viewname").equals(vname)) {
>          result = rf.getString("viewdef");
>          break;
>       }
>       rf.close();
>       return result;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/multibuffer/BufferNeeds.java ../cs4432-proj2/src/simpledb/multibuffer/BufferNeeds.java
1,54c1,54
< package simpledb.multibuffer;
< 
< import simpledb.server.SimpleDB;
< 
< /**
<  * A class containing static methods,
<  * which estimate the optimal number of buffers
<  * to allocate for a scan.
<  * @author Edward Sciore
<  */
< public class BufferNeeds {
<    
<    /**
<     * This method considers the various roots
<     * of the specified output size (in blocks),
<     * and returns the highest root that is less than
<     * the number of available buffers.
<     * @param size the size of the output file
<     * @return the highest number less than the number of available buffers, that is a root of the plan's output size
<     */
<    public static int bestRoot(int size) {
<       int avail = SimpleDB.bufferMgr().available();
<       if (avail <= 1)
<          return 1;
<       int k = Integer.MAX_VALUE;
<       double i = 1.0;
<       while (k > avail) {
<          i++;
<          k = (int)Math.ceil(Math.pow(size, 1/i));
<       }
<       return k;
<    }
<    
<    /**
<     * This method considers the various factors
<     * of the specified output size (in blocks),
<     * and returns the highest factor that is less than
<     * the number of available buffers.
<     * @param size the size of the output file
<     * @return the highest number less than the number of available buffers, that is a factor of the plan's output size
<     */
<    public static int bestFactor(int size) {
<       int avail = SimpleDB.bufferMgr().available();
<       if (avail <= 1)
<          return 1;
<       int k = size;
<       double i = 1.0;
<       while (k > avail) {
<          i++;
<          k = (int)Math.ceil(size / i);
<       }
<       return k;
<    }
< }
---
> package simpledb.multibuffer;
> 
> import simpledb.server.SimpleDB;
> 
> /**
>  * A class containing static methods,
>  * which estimate the optimal number of buffers
>  * to allocate for a scan.
>  * @author Edward Sciore
>  */
> public class BufferNeeds {
>    
>    /**
>     * This method considers the various roots
>     * of the specified output size (in blocks),
>     * and returns the highest root that is less than
>     * the number of available buffers.
>     * @param size the size of the output file
>     * @return the highest number less than the number of available buffers, that is a root of the plan's output size
>     */
>    public static int bestRoot(int size) {
>       int avail = SimpleDB.bufferMgr().available();
>       if (avail <= 1)
>          return 1;
>       int k = Integer.MAX_VALUE;
>       double i = 1.0;
>       while (k > avail) {
>          i++;
>          k = (int)Math.ceil(Math.pow(size, 1/i));
>       }
>       return k;
>    }
>    
>    /**
>     * This method considers the various factors
>     * of the specified output size (in blocks),
>     * and returns the highest factor that is less than
>     * the number of available buffers.
>     * @param size the size of the output file
>     * @return the highest number less than the number of available buffers, that is a factor of the plan's output size
>     */
>    public static int bestFactor(int size) {
>       int avail = SimpleDB.bufferMgr().available();
>       if (avail <= 1)
>          return 1;
>       int k = size;
>       double i = 1.0;
>       while (k > avail) {
>          i++;
>          k = (int)Math.ceil(size / i);
>       }
>       return k;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/multibuffer/ChunkScan.java ../cs4432-proj2/src/simpledb/multibuffer/ChunkScan.java
1,110c1,110
< package simpledb.multibuffer;
< 
< import static java.sql.Types.INTEGER;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.file.Block;
< import simpledb.query.*;
< 
< import java.util.ArrayList;
< import java.util.List;
< 
< /**
<  * The class for the <i>chunk</i> operator.
<  * @author Edward Sciore
<  */
< public class ChunkScan implements Scan {
<    private List<RecordPage> pages;
<    private int startbnum, endbnum, current;
<    private Schema sch;
<    private RecordPage rp;
<    
<    /**
<     * Creates a chunk consisting of the specified pages. 
<     * @param ti the metadata for the chunked table
<     * @param startbnum the starting block number
<     * @param endbnum  the ending block number
<     * @param tx the current transaction
<     */ 
<    public ChunkScan(TableInfo ti, int startbnum, int endbnum, Transaction tx) {
<       pages = new ArrayList<RecordPage>();
<       this.startbnum = startbnum;
<       this.endbnum   = endbnum;
<       this.sch = ti.schema();
<       String filename = ti.fileName();
<       for (int i=startbnum; i<=endbnum; i++) {
<          Block blk = new Block(filename, i);
<          pages.add(new RecordPage(blk, ti, tx));
<       }
<       beforeFirst();
<    }
<    
<    
<    /**
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       moveToBlock(startbnum);
<    }
<    
<    /**
<     * Moves to the next record in the current block of the chunk.
<     * If there are no more records, then make
<     * the next block be current.
<     * If there are no more blocks in the chunk, return false.
<     * @see simpledb.query.Scan#next()  
<     */
<    public boolean next() {
<       while (true) {
<          if (rp.next())
<             return true;
<          if (current == endbnum)
<             return false;
<          moveToBlock(current+1);
<       }
<    }
<    
<    /**
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       for (RecordPage r : pages)
<          r.close();
<    }
<    
<    /**
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (sch.type(fldname) == INTEGER)
<          return new IntConstant(rp.getInt(fldname));
<       else
<          return new StringConstant(rp.getString(fldname));
<    }
<    
<    /**
<     * @see simpledb.query.Scan#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       return rp.getInt(fldname);
<    }
<    
<    /**
<     * @see simpledb.query.Scan#getString(java.lang.String)
<     */
<    public String getString(String fldname) {
<       return rp.getString(fldname);
<    }
<    
<    /**
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return sch.hasField(fldname);
<    }
<    
<    private void moveToBlock(int blknum) {
<       current = blknum;
<       rp = pages.get(current - startbnum);
<       rp.moveToId(-1);
<    }
---
> package simpledb.multibuffer;
> 
> import static java.sql.Types.INTEGER;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.file.Block;
> import simpledb.query.*;
> 
> import java.util.ArrayList;
> import java.util.List;
> 
> /**
>  * The class for the <i>chunk</i> operator.
>  * @author Edward Sciore
>  */
> public class ChunkScan implements Scan {
>    private List<RecordPage> pages;
>    private int startbnum, endbnum, current;
>    private Schema sch;
>    private RecordPage rp;
>    
>    /**
>     * Creates a chunk consisting of the specified pages. 
>     * @param ti the metadata for the chunked table
>     * @param startbnum the starting block number
>     * @param endbnum  the ending block number
>     * @param tx the current transaction
>     */ 
>    public ChunkScan(TableInfo ti, int startbnum, int endbnum, Transaction tx) {
>       pages = new ArrayList<RecordPage>();
>       this.startbnum = startbnum;
>       this.endbnum   = endbnum;
>       this.sch = ti.schema();
>       String filename = ti.fileName();
>       for (int i=startbnum; i<=endbnum; i++) {
>          Block blk = new Block(filename, i);
>          pages.add(new RecordPage(blk, ti, tx));
>       }
>       beforeFirst();
>    }
>    
>    
>    /**
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       moveToBlock(startbnum);
>    }
>    
>    /**
>     * Moves to the next record in the current block of the chunk.
>     * If there are no more records, then make
>     * the next block be current.
>     * If there are no more blocks in the chunk, return false.
>     * @see simpledb.query.Scan#next()  
>     */
>    public boolean next() {
>       while (true) {
>          if (rp.next())
>             return true;
>          if (current == endbnum)
>             return false;
>          moveToBlock(current+1);
>       }
>    }
>    
>    /**
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       for (RecordPage r : pages)
>          r.close();
>    }
>    
>    /**
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       if (sch.type(fldname) == INTEGER)
>          return new IntConstant(rp.getInt(fldname));
>       else
>          return new StringConstant(rp.getString(fldname));
>    }
>    
>    /**
>     * @see simpledb.query.Scan#getInt(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       return rp.getInt(fldname);
>    }
>    
>    /**
>     * @see simpledb.query.Scan#getString(java.lang.String)
>     */
>    public String getString(String fldname) {
>       return rp.getString(fldname);
>    }
>    
>    /**
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       return sch.hasField(fldname);
>    }
>    
>    private void moveToBlock(int blknum) {
>       current = blknum;
>       rp = pages.get(current - startbnum);
>       rp.moveToId(-1);
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/multibuffer/MultiBufferProductPlan.java ../cs4432-proj2/src/simpledb/multibuffer/MultiBufferProductPlan.java
1,116c1,116
< package simpledb.multibuffer;
< 
< import simpledb.server.SimpleDB;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< import simpledb.materialize.*;
< import simpledb.query.*;
< 
< /**
<  * The Plan class for the muti-buffer version of the
<  * <i>product</i> operator.
<  * @author Edward Sciore
<  */
< public class MultiBufferProductPlan implements Plan {
<    private Plan lhs, rhs;
<    private Transaction tx;
<    private Schema schema = new Schema();
<    
<    /**
<     * Creates a product plan for the specified queries.
<     * @param lhs the plan for the LHS query
<     * @param rhs the plan for the RHS query
<     * @param tx the calling transaction
<     */
<    public MultiBufferProductPlan(Plan lhs, Plan rhs, Transaction tx) {
<       this.lhs = lhs;
<       this.rhs = rhs;
<       this.tx = tx;
<       schema.addAll(lhs.schema());
<       schema.addAll(rhs.schema());
<    }
<    
<    /**
<     * A scan for this query is created and returned, as follows.
<     * First, the method materializes its RHS query.
<     * It then determines the optimal chunk size,
<     * based on the size of the materialized file and the
<     * number of available buffers.
<     * It creates a chunk plan for each chunk, saving them in a list.
<     * Finally, it creates a multiscan for this list of plans,
<     * and returns that scan.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       TempTable tt = copyRecordsFrom(rhs);
<       TableInfo ti = tt.getTableInfo();
<       Scan leftscan = lhs.open();
<       return new MultiBufferProductScan(leftscan, ti, tx);
<    }
<    
<    /**
<     * Returns an estimate of the number of block accesses
<     * required to execute the query. The formula is:
<     * <pre> B(product(p1,p2)) = B(p2) + B(p1)*C(p2) </pre>
<     * where C(p2) is the number of chunks of p2.
<     * The method uses the current number of available buffers
<     * to calculate C(p2), and so this value may differ
<     * when the query scan is opened.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       // this guesses at the # of chunks
<       int avail = SimpleDB.bufferMgr().available();
<       int size = new MaterializePlan(rhs, tx).blocksAccessed();
<       int numchunks = size / avail;
<       return rhs.blocksAccessed() +
<          (lhs.blocksAccessed() * numchunks);
<    }
<    
<    /**
<     * Estimates the number of output records in the product.
<     * The formula is:
<     * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return lhs.recordsOutput() * rhs.recordsOutput();
<    }
<    
<    /**
<     * Estimates the distinct number of field values in the product.
<     * Since the product does not increase or decrease field values,
<     * the estimate is the same as in the appropriate underlying query.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       if (lhs.schema().hasField(fldname))
<          return lhs.distinctValues(fldname);
<       else
<          return rhs.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the product,
<     * which is the union of the schemas of the underlying queries.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return schema;
<    }
<    
<    private TempTable copyRecordsFrom(Plan p) {
<       Scan   src = p.open(); 
<       Schema sch = p.schema();
<       TempTable tt = new TempTable(sch, tx);
<       UpdateScan dest = (UpdateScan) tt.open();
<       while (src.next()) {
<          dest.insert();
<          for (String fldname : sch.fields())
<             dest.setVal(fldname, src.getVal(fldname));
<       }
<       src.close();
<       dest.close();
<       return tt;
<    }
< }
---
> package simpledb.multibuffer;
> 
> import simpledb.server.SimpleDB;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> import simpledb.materialize.*;
> import simpledb.query.*;
> 
> /**
>  * The Plan class for the muti-buffer version of the
>  * <i>product</i> operator.
>  * @author Edward Sciore
>  */
> public class MultiBufferProductPlan implements Plan {
>    private Plan lhs, rhs;
>    private Transaction tx;
>    private Schema schema = new Schema();
>    
>    /**
>     * Creates a product plan for the specified queries.
>     * @param lhs the plan for the LHS query
>     * @param rhs the plan for the RHS query
>     * @param tx the calling transaction
>     */
>    public MultiBufferProductPlan(Plan lhs, Plan rhs, Transaction tx) {
>       this.lhs = lhs;
>       this.rhs = rhs;
>       this.tx = tx;
>       schema.addAll(lhs.schema());
>       schema.addAll(rhs.schema());
>    }
>    
>    /**
>     * A scan for this query is created and returned, as follows.
>     * First, the method materializes its RHS query.
>     * It then determines the optimal chunk size,
>     * based on the size of the materialized file and the
>     * number of available buffers.
>     * It creates a chunk plan for each chunk, saving them in a list.
>     * Finally, it creates a multiscan for this list of plans,
>     * and returns that scan.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       TempTable tt = copyRecordsFrom(rhs);
>       TableInfo ti = tt.getTableInfo();
>       Scan leftscan = lhs.open();
>       return new MultiBufferProductScan(leftscan, ti, tx);
>    }
>    
>    /**
>     * Returns an estimate of the number of block accesses
>     * required to execute the query. The formula is:
>     * <pre> B(product(p1,p2)) = B(p2) + B(p1)*C(p2) </pre>
>     * where C(p2) is the number of chunks of p2.
>     * The method uses the current number of available buffers
>     * to calculate C(p2), and so this value may differ
>     * when the query scan is opened.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       // this guesses at the # of chunks
>       int avail = SimpleDB.bufferMgr().available();
>       int size = new MaterializePlan(rhs, tx).blocksAccessed();
>       int numchunks = size / avail;
>       return rhs.blocksAccessed() +
>          (lhs.blocksAccessed() * numchunks);
>    }
>    
>    /**
>     * Estimates the number of output records in the product.
>     * The formula is:
>     * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return lhs.recordsOutput() * rhs.recordsOutput();
>    }
>    
>    /**
>     * Estimates the distinct number of field values in the product.
>     * Since the product does not increase or decrease field values,
>     * the estimate is the same as in the appropriate underlying query.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       if (lhs.schema().hasField(fldname))
>          return lhs.distinctValues(fldname);
>       else
>          return rhs.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the product,
>     * which is the union of the schemas of the underlying queries.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return schema;
>    }
>    
>    private TempTable copyRecordsFrom(Plan p) {
>       Scan   src = p.open(); 
>       Schema sch = p.schema();
>       TempTable tt = new TempTable(sch, tx);
>       UpdateScan dest = (UpdateScan) tt.open();
>       while (src.next()) {
>          dest.insert();
>          for (String fldname : sch.fields())
>             dest.setVal(fldname, src.getVal(fldname));
>       }
>       src.close();
>       dest.close();
>       return tt;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/multibuffer/MultiBufferProductScan.java ../cs4432-proj2/src/simpledb/multibuffer/MultiBufferProductScan.java
1,122c1,122
< package simpledb.multibuffer;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.TableInfo;
< import simpledb.query.*;
< 
< /** 
<  * The Scan class for the muti-buffer version of the
<  * <i>product</i> operator.
<  * @author Edward Sciore
<  */
< public class MultiBufferProductScan implements Scan {
<    private Scan lhsscan, rhsscan=null, prodscan;
<    private TableInfo ti;
<    private Transaction tx;
<    private int chunksize, nextblknum, filesize;
<    
<    
<    /**
<     * Creates the scan class for the product of the LHS scan and a table.
<     * @param lhsscan the LHS scan
<     * @param ti the metadata for the RHS table
<     * @param tx the current transaction
<     */
<    public MultiBufferProductScan(Scan lhsscan, TableInfo ti, Transaction tx) {
<       this.lhsscan = lhsscan;
<       this.ti = ti;
<       this.tx = tx;
<       filesize = tx.size(ti.fileName());
<       chunksize = BufferNeeds.bestFactor(filesize);
<       beforeFirst();
<    }
<    
<    /**
<     * Positions the scan before the first record.
<     * That is, the LHS scan is positioned at its first record,
<     * and the RHS scan is positioned before the first record of the first chunk.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       nextblknum = 0;
<       useNextChunk();
<    }
<    
<    /**
<     * Moves to the next record in the current scan.
<     * If there are no more records in the current chunk,
<     * then move to the next LHS record and the beginning of that chunk.
<     * If there are no more LHS records, then move to the next chunk
<     * and begin again.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       while (!prodscan.next()) 
<          if (!useNextChunk())
<          return false;
<       return true;
<    }
<    
<    /**
<     * Closes the current scans.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       prodscan.close();
<    }
<    
<    /** 
<     * Returns the value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       return prodscan.getVal(fldname);
<    }
<    
<    /** 
<     * Returns the integer value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       return prodscan.getInt(fldname);
<    }
<    
<    /** 
<     * Returns the string value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getString(java.lang.String)
<     */
<    public String getString(String fldname) {
<       return prodscan.getString(fldname);
<    }
<    
<    /**
<     * Returns true if the specified field is in
<     * either of the underlying scans.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return prodscan.hasField(fldname);
<    }
<    
<    private boolean useNextChunk() {
<       if (rhsscan != null)
<          rhsscan.close();
<       if (nextblknum >= filesize)
<          return false;
<       int end = nextblknum + chunksize - 1;
<       if (end >= filesize)
<          end = filesize - 1;
<       rhsscan = new ChunkScan(ti, nextblknum, end, tx);
<       lhsscan.beforeFirst();
<       prodscan = new ProductScan(lhsscan, rhsscan);
<       nextblknum = end + 1;
<       return true;
<    }
< }
< 
---
> package simpledb.multibuffer;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.TableInfo;
> import simpledb.query.*;
> 
> /** 
>  * The Scan class for the muti-buffer version of the
>  * <i>product</i> operator.
>  * @author Edward Sciore
>  */
> public class MultiBufferProductScan implements Scan {
>    private Scan lhsscan, rhsscan=null, prodscan;
>    private TableInfo ti;
>    private Transaction tx;
>    private int chunksize, nextblknum, filesize;
>    
>    
>    /**
>     * Creates the scan class for the product of the LHS scan and a table.
>     * @param lhsscan the LHS scan
>     * @param ti the metadata for the RHS table
>     * @param tx the current transaction
>     */
>    public MultiBufferProductScan(Scan lhsscan, TableInfo ti, Transaction tx) {
>       this.lhsscan = lhsscan;
>       this.ti = ti;
>       this.tx = tx;
>       filesize = tx.size(ti.fileName());
>       chunksize = BufferNeeds.bestFactor(filesize);
>       beforeFirst();
>    }
>    
>    /**
>     * Positions the scan before the first record.
>     * That is, the LHS scan is positioned at its first record,
>     * and the RHS scan is positioned before the first record of the first chunk.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       nextblknum = 0;
>       useNextChunk();
>    }
>    
>    /**
>     * Moves to the next record in the current scan.
>     * If there are no more records in the current chunk,
>     * then move to the next LHS record and the beginning of that chunk.
>     * If there are no more LHS records, then move to the next chunk
>     * and begin again.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       while (!prodscan.next()) 
>          if (!useNextChunk())
>          return false;
>       return true;
>    }
>    
>    /**
>     * Closes the current scans.
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       prodscan.close();
>    }
>    
>    /** 
>     * Returns the value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       return prodscan.getVal(fldname);
>    }
>    
>    /** 
>     * Returns the integer value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getInt(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       return prodscan.getInt(fldname);
>    }
>    
>    /** 
>     * Returns the string value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getString(java.lang.String)
>     */
>    public String getString(String fldname) {
>       return prodscan.getString(fldname);
>    }
>    
>    /**
>     * Returns true if the specified field is in
>     * either of the underlying scans.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       return prodscan.hasField(fldname);
>    }
>    
>    private boolean useNextChunk() {
>       if (rhsscan != null)
>          rhsscan.close();
>       if (nextblknum >= filesize)
>          return false;
>       int end = nextblknum + chunksize - 1;
>       if (end >= filesize)
>          end = filesize - 1;
>       rhsscan = new ChunkScan(ti, nextblknum, end, tx);
>       lhsscan.beforeFirst();
>       prodscan = new ProductScan(lhsscan, rhsscan);
>       nextblknum = end + 1;
>       return true;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/opt/HeuristicQueryPlanner.java ../cs4432-proj2/src/simpledb/opt/HeuristicQueryPlanner.java
1,91c1,91
< package simpledb.opt;
< 
< import simpledb.tx.Transaction;
< import simpledb.query.*;
< import simpledb.opt.TablePlanner;
< import simpledb.parse.QueryData;
< import simpledb.planner.QueryPlanner;
< import java.util.*;
< 
< /**
<  * A query planner that optimizes using a heuristic-based algorithm.
<  * @author Edward Sciore
<  */
< public class HeuristicQueryPlanner implements QueryPlanner {
<    private Collection<TablePlanner> tableplanners = new ArrayList<TablePlanner>();
<    
<    /**
<     * Creates an optimized left-deep query plan using the following
<     * heuristics.
<     * H1. Choose the smallest table (considering selection predicates)
<     * to be first in the join order.
<     * H2. Add the table to the join order which
<     * results in the smallest output.
<     */
<    public Plan createPlan(QueryData data, Transaction tx) {
<       
<       // Step 1:  Create a TablePlanner object for each mentioned table
<       for (String tblname : data.tables()) {
<          TablePlanner tp = new TablePlanner(tblname, data.pred(), tx);
<          tableplanners.add(tp);
<       }
<       
<       // Step 2:  Choose the lowest-size plan to begin the join order
<       Plan currentplan = getLowestSelectPlan();
<       
<       // Step 3:  Repeatedly add a plan to the join order
<       while (!tableplanners.isEmpty()) {
<          Plan p = getLowestJoinPlan(currentplan);
<          if (p != null)
<             currentplan = p;
<          else  // no applicable join
<             currentplan = getLowestProductPlan(currentplan);
<       }
<       
<       // Step 4.  Project on the field names and return
<       return new ProjectPlan(currentplan, data.fields());
<    }
<    
<    private Plan getLowestSelectPlan() {
<       TablePlanner besttp = null;
<       Plan bestplan = null;
<       for (TablePlanner tp : tableplanners) {
<          Plan plan = tp.makeSelectPlan();
<          if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
<             besttp = tp;
<             bestplan = plan;
<          }
<       }
<       tableplanners.remove(besttp);
<       return bestplan;
<    }
<    
<    private Plan getLowestJoinPlan(Plan current) {
<       TablePlanner besttp = null;
<       Plan bestplan = null;
<       for (TablePlanner tp : tableplanners) {
<          Plan plan = tp.makeJoinPlan(current);
<          if (plan != null && (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput())) {
<             besttp = tp;
<             bestplan = plan;
<          }
<       }
<       if (bestplan != null)
<          tableplanners.remove(besttp);
<       return bestplan;
<    }
<    
<    private Plan getLowestProductPlan(Plan current) {
<       TablePlanner besttp = null;
<       Plan bestplan = null;
<       for (TablePlanner tp : tableplanners) {
<          Plan plan = tp.makeProductPlan(current);
<          if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
<             besttp = tp;
<             bestplan = plan;
<          }
<       }
<       tableplanners.remove(besttp);
<       return bestplan;
<    }
< }
---
> package simpledb.opt;
> 
> import simpledb.tx.Transaction;
> import simpledb.query.*;
> import simpledb.opt.TablePlanner;
> import simpledb.parse.QueryData;
> import simpledb.planner.QueryPlanner;
> import java.util.*;
> 
> /**
>  * A query planner that optimizes using a heuristic-based algorithm.
>  * @author Edward Sciore
>  */
> public class HeuristicQueryPlanner implements QueryPlanner {
>    private Collection<TablePlanner> tableplanners = new ArrayList<TablePlanner>();
>    
>    /**
>     * Creates an optimized left-deep query plan using the following
>     * heuristics.
>     * H1. Choose the smallest table (considering selection predicates)
>     * to be first in the join order.
>     * H2. Add the table to the join order which
>     * results in the smallest output.
>     */
>    public Plan createPlan(QueryData data, Transaction tx) {
>       
>       // Step 1:  Create a TablePlanner object for each mentioned table
>       for (String tblname : data.tables()) {
>          TablePlanner tp = new TablePlanner(tblname, data.pred(), tx);
>          tableplanners.add(tp);
>       }
>       
>       // Step 2:  Choose the lowest-size plan to begin the join order
>       Plan currentplan = getLowestSelectPlan();
>       
>       // Step 3:  Repeatedly add a plan to the join order
>       while (!tableplanners.isEmpty()) {
>          Plan p = getLowestJoinPlan(currentplan);
>          if (p != null)
>             currentplan = p;
>          else  // no applicable join
>             currentplan = getLowestProductPlan(currentplan);
>       }
>       
>       // Step 4.  Project on the field names and return
>       return new ProjectPlan(currentplan, data.fields());
>    }
>    
>    private Plan getLowestSelectPlan() {
>       TablePlanner besttp = null;
>       Plan bestplan = null;
>       for (TablePlanner tp : tableplanners) {
>          Plan plan = tp.makeSelectPlan();
>          if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
>             besttp = tp;
>             bestplan = plan;
>          }
>       }
>       tableplanners.remove(besttp);
>       return bestplan;
>    }
>    
>    private Plan getLowestJoinPlan(Plan current) {
>       TablePlanner besttp = null;
>       Plan bestplan = null;
>       for (TablePlanner tp : tableplanners) {
>          Plan plan = tp.makeJoinPlan(current);
>          if (plan != null && (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput())) {
>             besttp = tp;
>             bestplan = plan;
>          }
>       }
>       if (bestplan != null)
>          tableplanners.remove(besttp);
>       return bestplan;
>    }
>    
>    private Plan getLowestProductPlan(Plan current) {
>       TablePlanner besttp = null;
>       Plan bestplan = null;
>       for (TablePlanner tp : tableplanners) {
>          Plan plan = tp.makeProductPlan(current);
>          if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
>             besttp = tp;
>             bestplan = plan;
>          }
>       }
>       tableplanners.remove(besttp);
>       return bestplan;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/opt/TablePlanner.java ../cs4432-proj2/src/simpledb/opt/TablePlanner.java
1,128c1,128
< package simpledb.opt;
< 
< import simpledb.tx.Transaction;
< import simpledb.record.Schema;
< import simpledb.query.*;
< import simpledb.index.query.*;
< import simpledb.metadata.IndexInfo;
< import simpledb.multibuffer.MultiBufferProductPlan;
< import simpledb.server.SimpleDB;
< import java.util.Map;
< 
< /**
<  * This class contains methods for planning a single table.
<  * @author Edward Sciore
<  */
< class TablePlanner {
<    private TablePlan myplan;
<    private Predicate mypred;
<    private Schema myschema;
<    private Map<String,IndexInfo> indexes;
<    private Transaction tx;
<    
<    /**
<     * Creates a new table planner.
<     * The specified predicate applies to the entire query.
<     * The table planner is responsible for determining
<     * which portion of the predicate is useful to the table,
<     * and when indexes are useful.
<     * @param tblname the name of the table
<     * @param mypred the query predicate
<     * @param tx the calling transaction
<     */
<    public TablePlanner(String tblname, Predicate mypred, Transaction tx) {
<       this.mypred  = mypred;
<       this.tx  = tx;
<       myplan   = new TablePlan(tblname, tx);
<       myschema = myplan.schema();
<       indexes  = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
<    }
<    
<    /**
<     * Constructs a select plan for the table.
<     * The plan will use an indexselect, if possible.
<     * @return a select plan for the table.
<     */
<    public Plan makeSelectPlan() {
<       Plan p = makeIndexSelect();
<       if (p == null)
<          p = myplan;
<       return addSelectPred(p);
<    }
<    
<    /**
<     * Constructs a join plan of the specified plan
<     * and the table.  The plan will use an indexjoin, if possible.
<     * (Which means that if an indexselect is also possible,
<     * the indexjoin operator takes precedence.)
<     * The method returns null if no join is possible.
<     * @param current the specified plan
<     * @return a join plan of the plan and this table
<     */
<    public Plan makeJoinPlan(Plan current) {
<       Schema currsch = current.schema();
<       Predicate joinpred = mypred.joinPred(myschema, currsch);
<       if (joinpred == null)
<          return null;
<       Plan p = makeIndexJoin(current, currsch);
<       if (p == null)
<          p = makeProductJoin(current, currsch);
<       return p;
<    }
<    
<    /**
<     * Constructs a product plan of the specified plan and
<     * this table.
<     * @param current the specified plan
<     * @return a product plan of the specified plan and this table
<     */
<    public Plan makeProductPlan(Plan current) {
<       Plan p = addSelectPred(myplan);
<       return new MultiBufferProductPlan(current, p, tx);
<    }
<    
<    private Plan makeIndexSelect() {
<       for (String fldname : indexes.keySet()) {
<          Constant val = mypred.equatesWithConstant(fldname);
<          if (val != null) {
<             IndexInfo ii = indexes.get(fldname);
<             return new IndexSelectPlan(myplan, ii, val, tx);
<          }
<       }
<       return null;
<    }
<    
<    private Plan makeIndexJoin(Plan current, Schema currsch) {
<       for (String fldname : indexes.keySet()) {
<          String outerfield = mypred.equatesWithField(fldname);
<          if (outerfield != null && currsch.hasField(outerfield)) {
<             IndexInfo ii = indexes.get(fldname);
<             Plan p = new IndexJoinPlan(current, myplan, ii, outerfield, tx);
<             p = addSelectPred(p);
<             return addJoinPred(p, currsch);
<          }
<       }
<       return null;
<    }
<    
<    private Plan makeProductJoin(Plan current, Schema currsch) {
<       Plan p = makeProductPlan(current);
<       return addJoinPred(p, currsch);
<    }
<    
<    private Plan addSelectPred(Plan p) {
<       Predicate selectpred = mypred.selectPred(myschema);
<       if (selectpred != null)
<          return new SelectPlan(p, selectpred);
<       else
<          return p;
<    }
<    
<    private Plan addJoinPred(Plan p, Schema currsch) {
<       Predicate joinpred = mypred.joinPred(currsch, myschema);
<       if (joinpred != null)
<          return new SelectPlan(p, joinpred);
<       else
<          return p;
<    }
< }
---
> package simpledb.opt;
> 
> import simpledb.tx.Transaction;
> import simpledb.record.Schema;
> import simpledb.query.*;
> import simpledb.index.query.*;
> import simpledb.metadata.IndexInfo;
> import simpledb.multibuffer.MultiBufferProductPlan;
> import simpledb.server.SimpleDB;
> import java.util.Map;
> 
> /**
>  * This class contains methods for planning a single table.
>  * @author Edward Sciore
>  */
> class TablePlanner {
>    private TablePlan myplan;
>    private Predicate mypred;
>    private Schema myschema;
>    private Map<String,IndexInfo> indexes;
>    private Transaction tx;
>    
>    /**
>     * Creates a new table planner.
>     * The specified predicate applies to the entire query.
>     * The table planner is responsible for determining
>     * which portion of the predicate is useful to the table,
>     * and when indexes are useful.
>     * @param tblname the name of the table
>     * @param mypred the query predicate
>     * @param tx the calling transaction
>     */
>    public TablePlanner(String tblname, Predicate mypred, Transaction tx) {
>       this.mypred  = mypred;
>       this.tx  = tx;
>       myplan   = new TablePlan(tblname, tx);
>       myschema = myplan.schema();
>       indexes  = SimpleDB.mdMgr().getIndexInfo(tblname, tx);
>    }
>    
>    /**
>     * Constructs a select plan for the table.
>     * The plan will use an indexselect, if possible.
>     * @return a select plan for the table.
>     */
>    public Plan makeSelectPlan() {
>       Plan p = makeIndexSelect();
>       if (p == null)
>          p = myplan;
>       return addSelectPred(p);
>    }
>    
>    /**
>     * Constructs a join plan of the specified plan
>     * and the table.  The plan will use an indexjoin, if possible.
>     * (Which means that if an indexselect is also possible,
>     * the indexjoin operator takes precedence.)
>     * The method returns null if no join is possible.
>     * @param current the specified plan
>     * @return a join plan of the plan and this table
>     */
>    public Plan makeJoinPlan(Plan current) {
>       Schema currsch = current.schema();
>       Predicate joinpred = mypred.joinPred(myschema, currsch);
>       if (joinpred == null)
>          return null;
>       Plan p = makeIndexJoin(current, currsch);
>       if (p == null)
>          p = makeProductJoin(current, currsch);
>       return p;
>    }
>    
>    /**
>     * Constructs a product plan of the specified plan and
>     * this table.
>     * @param current the specified plan
>     * @return a product plan of the specified plan and this table
>     */
>    public Plan makeProductPlan(Plan current) {
>       Plan p = addSelectPred(myplan);
>       return new MultiBufferProductPlan(current, p, tx);
>    }
>    
>    private Plan makeIndexSelect() {
>       for (String fldname : indexes.keySet()) {
>          Constant val = mypred.equatesWithConstant(fldname);
>          if (val != null) {
>             IndexInfo ii = indexes.get(fldname);
>             return new IndexSelectPlan(myplan, ii, val, tx);
>          }
>       }
>       return null;
>    }
>    
>    private Plan makeIndexJoin(Plan current, Schema currsch) {
>       for (String fldname : indexes.keySet()) {
>          String outerfield = mypred.equatesWithField(fldname);
>          if (outerfield != null && currsch.hasField(outerfield)) {
>             IndexInfo ii = indexes.get(fldname);
>             Plan p = new IndexJoinPlan(current, myplan, ii, outerfield, tx);
>             p = addSelectPred(p);
>             return addJoinPred(p, currsch);
>          }
>       }
>       return null;
>    }
>    
>    private Plan makeProductJoin(Plan current, Schema currsch) {
>       Plan p = makeProductPlan(current);
>       return addJoinPred(p, currsch);
>    }
>    
>    private Plan addSelectPred(Plan p) {
>       Predicate selectpred = mypred.selectPred(myschema);
>       if (selectpred != null)
>          return new SelectPlan(p, selectpred);
>       else
>          return p;
>    }
>    
>    private Plan addJoinPred(Plan p, Schema currsch) {
>       Predicate joinpred = mypred.joinPred(currsch, myschema);
>       if (joinpred != null)
>          return new SelectPlan(p, joinpred);
>       else
>          return p;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/BadSyntaxException.java ../cs4432-proj2/src/simpledb/parse/BadSyntaxException.java
1,12c1,12
< package simpledb.parse;
< 
< /**
<  * A runtime exception indicating that the submitted query
<  * has incorrect syntax.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< public class BadSyntaxException extends RuntimeException {
<    public BadSyntaxException() {
<    }
< }
---
> package simpledb.parse;
> 
> /**
>  * A runtime exception indicating that the submitted query
>  * has incorrect syntax.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> public class BadSyntaxException extends RuntimeException {
>    public BadSyntaxException() {
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/CreateIndexData.java ../cs4432-proj2/src/simpledb/parse/CreateIndexData.java
1,43c1,76
< package simpledb.parse;
< 
< /**
<  * The parser for the <i>create index</i> statement.
<  * @author Edward Sciore
<  */
< public class CreateIndexData {
<    private String idxname, tblname, fldname;
<    
<    /**
<     * Saves the table and field names of the specified index.
<     */
<    public CreateIndexData(String idxname, String tblname, String fldname) {
<       this.idxname = idxname;
<       this.tblname = tblname;
<       this.fldname = fldname;
<    }
<    
<    /**
<     * Returns the name of the index.
<     * @return the name of the index
<     */
<    public String indexName() {
<       return idxname;
<    }
<    
<    /**
<     * Returns the name of the indexed table.
<     * @return the name of the indexed table
<     */
<    public String tableName() {
<       return tblname;
<    }
<    
<    /**
<     * Returns the name of the indexed field.
<     * @return the name of the indexed field
<     */
<    public String fieldName() {
<       return fldname;
<    }
< }
< 
---
> package simpledb.parse;
> 
> import simpledb.index.IndexType;
> 
> /**
>  * CS 4432 Project 2
>  *
>  * We added the index type information to this class.
>  *
>  * The parser for the <i>create index</i> statement.
>  *
>  * @author Edward Sciore
>  */
> public class CreateIndexData {
>     protected String idxname, tblname, fldname;
> 
>     // The index type
>     protected IndexType type;
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added a parameter to pass in the index type.
>      *
>      * Saves the table and field names of the specified index.
>      *
>      * @param type
>      *            The index type to create.
>      */
>     public CreateIndexData(String idxname, String tblname, String fldname, IndexType type) {
>         this.idxname = idxname;
>         this.tblname = tblname;
>         this.fldname = fldname;
>         this.type = type;
>     }
> 
>     /**
>      * Returns the name of the indexed field.
>      *
>      * @return the name of the indexed field
>      */
>     public String fieldName() {
>         return fldname;
>     }
> 
>     /**
>      * Returns the name of the index.
>      *
>      * @return the name of the index
>      */
>     public String indexName() {
>         return idxname;
>     }
> 
>     /**
>      * Returns the name of the indexed table.
>      *
>      * @return the name of the indexed table
>      */
>     public String tableName() {
>         return tblname;
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added this method to get access to the index type.
>      *
>      * Returns the type of the indexed table.
>      *
>      * @return the type of the indexed table.
>      */
>     public IndexType indexType() {
>         return type;
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/CreateTableData.java ../cs4432-proj2/src/simpledb/parse/CreateTableData.java
1,37c1,37
< package simpledb.parse;
< 
< import simpledb.record.Schema;
< 
< /**
<  * Data for the SQL <i>create table</i> statement.
<  * @author Edward Sciore
<  */
< public class CreateTableData {
<    private String tblname;
<    private Schema sch;
<    
<    /**
<     * Saves the table name and schema.
<     */
<    public CreateTableData(String tblname, Schema sch) {
<       this.tblname = tblname;
<       this.sch = sch;
<    }
<    
<    /**
<     * Returns the name of the new table.
<     * @return the name of the new table
<     */
<    public String tableName() {
<       return tblname;
<    }
<    
<    /**
<     * Returns the schema of the new table.
<     * @return the schema of the new table
<     */
<    public Schema newSchema() {
<       return sch;
<    }
< }
< 
---
> package simpledb.parse;
> 
> import simpledb.record.Schema;
> 
> /**
>  * Data for the SQL <i>create table</i> statement.
>  * @author Edward Sciore
>  */
> public class CreateTableData {
>    private String tblname;
>    private Schema sch;
>    
>    /**
>     * Saves the table name and schema.
>     */
>    public CreateTableData(String tblname, Schema sch) {
>       this.tblname = tblname;
>       this.sch = sch;
>    }
>    
>    /**
>     * Returns the name of the new table.
>     * @return the name of the new table
>     */
>    public String tableName() {
>       return tblname;
>    }
>    
>    /**
>     * Returns the schema of the new table.
>     * @return the schema of the new table
>     */
>    public Schema newSchema() {
>       return sch;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/parse/CreateViewData.java ../cs4432-proj2/src/simpledb/parse/CreateViewData.java
1,34c1,34
< package simpledb.parse;
< 
< /**
<  * Data for the SQL <i>create view</i> statement.
<  * @author Edward Sciore
<  */
< public class CreateViewData {
<    private String viewname;
<    private QueryData qrydata;
<    
<    /**
<     * Saves the view name and its definition.
<     */
<    public CreateViewData(String viewname, QueryData qrydata) {
<       this.viewname = viewname;
<       this.qrydata = qrydata;
<    }
<    
<    /**
<     * Returns the name of the new view.
<     * @return the name of the new view
<     */
<    public String viewName() {
<       return viewname;
<    }
<    
<    /**
<     * Returns the definition of the new view.
<     * @return the definition of the new view
<     */
<    public String viewDef() {
<       return qrydata.toString();
<    }
< }
---
> package simpledb.parse;
> 
> /**
>  * Data for the SQL <i>create view</i> statement.
>  * @author Edward Sciore
>  */
> public class CreateViewData {
>    private String viewname;
>    private QueryData qrydata;
>    
>    /**
>     * Saves the view name and its definition.
>     */
>    public CreateViewData(String viewname, QueryData qrydata) {
>       this.viewname = viewname;
>       this.qrydata = qrydata;
>    }
>    
>    /**
>     * Returns the name of the new view.
>     * @return the name of the new view
>     */
>    public String viewName() {
>       return viewname;
>    }
>    
>    /**
>     * Returns the definition of the new view.
>     * @return the definition of the new view
>     */
>    public String viewDef() {
>       return qrydata.toString();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/DeleteData.java ../cs4432-proj2/src/simpledb/parse/DeleteData.java
1,38c1,38
< package simpledb.parse;
< 
< import simpledb.query.*;
< 
< /**
<  * Data for the SQL <i>delete</i> statement.
<  * @author Edward Sciore
<  */
< public class DeleteData {
<    private String tblname;
<    private Predicate pred;
<    
<    /**
<     * Saves the table name and predicate.
<     */
<    public DeleteData(String tblname, Predicate pred) {
<       this.tblname = tblname;
<       this.pred = pred;
<    }
<    
<    /**
<     * Returns the name of the affected table.
<     * @return the name of the affected table
<     */
<    public String tableName() {
<       return tblname;
<    }
<    
<    /**
<     * Returns the predicate that describes which
<     * records should be deleted.
<     * @return the deletion predicate
<     */
<    public Predicate pred() {
<       return pred;
<    }
< }
< 
---
> package simpledb.parse;
> 
> import simpledb.query.*;
> 
> /**
>  * Data for the SQL <i>delete</i> statement.
>  * @author Edward Sciore
>  */
> public class DeleteData {
>    private String tblname;
>    private Predicate pred;
>    
>    /**
>     * Saves the table name and predicate.
>     */
>    public DeleteData(String tblname, Predicate pred) {
>       this.tblname = tblname;
>       this.pred = pred;
>    }
>    
>    /**
>     * Returns the name of the affected table.
>     * @return the name of the affected table
>     */
>    public String tableName() {
>       return tblname;
>    }
>    
>    /**
>     * Returns the predicate that describes which
>     * records should be deleted.
>     * @return the deletion predicate
>     */
>    public Predicate pred() {
>       return pred;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/parse/InsertData.java ../cs4432-proj2/src/simpledb/parse/InsertData.java
1,51c1,51
< package simpledb.parse;
< 
< import simpledb.query.Constant;
< import java.util.*;
< 
< /**
<  * Data for the SQL <i>insert</i> statement.
<  * @author Edward Sciore
<  */
< public class InsertData {
<    private String tblname;
<    private List<String> flds;
<    private List<Constant> vals;
<    
<    /**
<     * Saves the table name and the field and value lists.
<     */
<    public InsertData(String tblname, List<String> flds, List<Constant> vals) {
<       this.tblname = tblname;
<       this.flds = flds;
<       this.vals = vals;
<    }
<    
<    /**
<     * Returns the name of the affected table.
<     * @return the name of the affected table
<     */
<    public String tableName() {
<       return tblname;
<    }
<    
<    /**
<     * Returns a list of fields for which
<     * values will be specified in the new record.
<     * @return a list of field names
<     */
<    public List<String> fields() {
<       return flds;
<    }
<    
<    /**
<     * Returns a list of values for the specified fields.
<     * There is a one-one correspondence between this
<     * list of values and the list of fields.
<     * @return a list of Constant values.
<     */
<    public List<Constant> vals() {
<       return vals;
<    }
< }
< 
---
> package simpledb.parse;
> 
> import simpledb.query.Constant;
> import java.util.*;
> 
> /**
>  * Data for the SQL <i>insert</i> statement.
>  * @author Edward Sciore
>  */
> public class InsertData {
>    private String tblname;
>    private List<String> flds;
>    private List<Constant> vals;
>    
>    /**
>     * Saves the table name and the field and value lists.
>     */
>    public InsertData(String tblname, List<String> flds, List<Constant> vals) {
>       this.tblname = tblname;
>       this.flds = flds;
>       this.vals = vals;
>    }
>    
>    /**
>     * Returns the name of the affected table.
>     * @return the name of the affected table
>     */
>    public String tableName() {
>       return tblname;
>    }
>    
>    /**
>     * Returns a list of fields for which
>     * values will be specified in the new record.
>     * @return a list of field names
>     */
>    public List<String> fields() {
>       return flds;
>    }
>    
>    /**
>     * Returns a list of values for the specified fields.
>     * There is a one-one correspondence between this
>     * list of values and the list of fields.
>     * @return a list of Constant values.
>     */
>    public List<Constant> vals() {
>       return vals;
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/parse/Lexer.java ../cs4432-proj2/src/simpledb/parse/Lexer.java
1,153c1,153
< package simpledb.parse;
< 
< import java.util.*;
< import java.io.*;
< 
< /**
<  * The lexical analyzer.
<  * @author Edward Sciore
<  */
< public class Lexer {
<    private Collection<String> keywords;
<    private StreamTokenizer tok;
<    
<    /**
<     * Creates a new lexical analyzer for SQL statement s.
<     * @param s the SQL statement
<     */
<    public Lexer(String s) {
<       initKeywords();
<       tok = new StreamTokenizer(new StringReader(s));
<       tok.ordinaryChar('.');
<       tok.lowerCaseMode(true); //ids and keywords are converted
<       nextToken();
<    }
<    
< //Methods to check the status of the current token
<    
<    /**
<     * Returns true if the current token is
<     * the specified delimiter character.
<     * @param d a character denoting the delimiter
<     * @return true if the delimiter is the current token
<     */
<    public boolean matchDelim(char d) {
<       return d == (char)tok.ttype;
<    }
<    
<    /**
<     * Returns true if the current token is an integer.
<     * @return true if the current token is an integer
<     */
<    public boolean matchIntConstant() {
<       return tok.ttype == StreamTokenizer.TT_NUMBER;
<    }
<    
<    /**
<     * Returns true if the current token is a string.
<     * @return true if the current token is a string
<     */
<    public boolean matchStringConstant() {
<       return '\'' == (char)tok.ttype;
<    }
<    
<    /**
<     * Returns true if the current token is the specified keyword.
<     * @param w the keyword string
<     * @return true if that keyword is the current token
<     */
<    public boolean matchKeyword(String w) {
<       return tok.ttype == StreamTokenizer.TT_WORD && tok.sval.equals(w);
<    }
<    
<    /**
<     * Returns true if the current token is a legal identifier.
<     * @return true if the current token is an identifier
<     */
<    public boolean matchId() {
<       return  tok.ttype==StreamTokenizer.TT_WORD && !keywords.contains(tok.sval);
<    }
<    
< //Methods to "eat" the current token
<    
<    /**
<     * Throws an exception if the current token is not the
<     * specified delimiter. 
<     * Otherwise, moves to the next token.
<     * @param d a character denoting the delimiter
<     */
<    public void eatDelim(char d) {
<       if (!matchDelim(d))
<          throw new BadSyntaxException();
<       nextToken();
<    }
<    
<    /**
<     * Throws an exception if the current token is not 
<     * an integer. 
<     * Otherwise, returns that integer and moves to the next token.
<     * @return the integer value of the current token
<     */
<    public int eatIntConstant() {
<       if (!matchIntConstant())
<          throw new BadSyntaxException();
<       int i = (int) tok.nval;
<       nextToken();
<       return i;
<    }
<    
<    /**
<     * Throws an exception if the current token is not 
<     * a string. 
<     * Otherwise, returns that string and moves to the next token.
<     * @return the string value of the current token
<     */
<    public String eatStringConstant() {
<       if (!matchStringConstant())
<          throw new BadSyntaxException();
<       String s = tok.sval; //constants are not converted to lower case
<       nextToken();
<       return s;
<    }
<    
<    /**
<     * Throws an exception if the current token is not the
<     * specified keyword. 
<     * Otherwise, moves to the next token.
<     * @param w the keyword string
<     */
<    public void eatKeyword(String w) {
<       if (!matchKeyword(w))
<          throw new BadSyntaxException();
<       nextToken();
<    }
<    
<    /**
<     * Throws an exception if the current token is not 
<     * an identifier. 
<     * Otherwise, returns the identifier string 
<     * and moves to the next token.
<     * @return the string value of the current token
<     */
<    public String eatId() {
<       if (!matchId())
<          throw new BadSyntaxException();
<       String s = tok.sval;
<       nextToken();
<       return s;
<    }
<    
<    private void nextToken() {
<       try {
<          tok.nextToken();
<       }
<       catch(IOException e) {
<          throw new BadSyntaxException();
<       }
<    }
<    
<    private void initKeywords() {
<       keywords = Arrays.asList("select", "from", "where", "and",
<                                "insert", "into", "values", "delete", "update", "set", 
<                                "create", "table", "int", "varchar", "view", "as", "index", "on");
<    }
---
> package simpledb.parse;
> 
> import java.util.*;
> import java.io.*;
> 
> /**
>  * The lexical analyzer.
>  * @author Edward Sciore
>  */
> public class Lexer {
>    private Collection<String> keywords;
>    private StreamTokenizer tok;
>    
>    /**
>     * Creates a new lexical analyzer for SQL statement s.
>     * @param s the SQL statement
>     */
>    public Lexer(String s) {
>       initKeywords();
>       tok = new StreamTokenizer(new StringReader(s));
>       tok.ordinaryChar('.');
>       tok.lowerCaseMode(true); //ids and keywords are converted
>       nextToken();
>    }
>    
> //Methods to check the status of the current token
>    
>    /**
>     * Returns true if the current token is
>     * the specified delimiter character.
>     * @param d a character denoting the delimiter
>     * @return true if the delimiter is the current token
>     */
>    public boolean matchDelim(char d) {
>       return d == (char)tok.ttype;
>    }
>    
>    /**
>     * Returns true if the current token is an integer.
>     * @return true if the current token is an integer
>     */
>    public boolean matchIntConstant() {
>       return tok.ttype == StreamTokenizer.TT_NUMBER;
>    }
>    
>    /**
>     * Returns true if the current token is a string.
>     * @return true if the current token is a string
>     */
>    public boolean matchStringConstant() {
>       return '\'' == (char)tok.ttype;
>    }
>    
>    /**
>     * Returns true if the current token is the specified keyword.
>     * @param w the keyword string
>     * @return true if that keyword is the current token
>     */
>    public boolean matchKeyword(String w) {
>       return tok.ttype == StreamTokenizer.TT_WORD && tok.sval.equals(w);
>    }
>    
>    /**
>     * Returns true if the current token is a legal identifier.
>     * @return true if the current token is an identifier
>     */
>    public boolean matchId() {
>       return  tok.ttype==StreamTokenizer.TT_WORD && !keywords.contains(tok.sval);
>    }
>    
> //Methods to "eat" the current token
>    
>    /**
>     * Throws an exception if the current token is not the
>     * specified delimiter. 
>     * Otherwise, moves to the next token.
>     * @param d a character denoting the delimiter
>     */
>    public void eatDelim(char d) {
>       if (!matchDelim(d))
>          throw new BadSyntaxException();
>       nextToken();
>    }
>    
>    /**
>     * Throws an exception if the current token is not 
>     * an integer. 
>     * Otherwise, returns that integer and moves to the next token.
>     * @return the integer value of the current token
>     */
>    public int eatIntConstant() {
>       if (!matchIntConstant())
>          throw new BadSyntaxException();
>       int i = (int) tok.nval;
>       nextToken();
>       return i;
>    }
>    
>    /**
>     * Throws an exception if the current token is not 
>     * a string. 
>     * Otherwise, returns that string and moves to the next token.
>     * @return the string value of the current token
>     */
>    public String eatStringConstant() {
>       if (!matchStringConstant())
>          throw new BadSyntaxException();
>       String s = tok.sval; //constants are not converted to lower case
>       nextToken();
>       return s;
>    }
>    
>    /**
>     * Throws an exception if the current token is not the
>     * specified keyword. 
>     * Otherwise, moves to the next token.
>     * @param w the keyword string
>     */
>    public void eatKeyword(String w) {
>       if (!matchKeyword(w))
>          throw new BadSyntaxException();
>       nextToken();
>    }
>    
>    /**
>     * Throws an exception if the current token is not 
>     * an identifier. 
>     * Otherwise, returns the identifier string 
>     * and moves to the next token.
>     * @return the string value of the current token
>     */
>    public String eatId() {
>       if (!matchId())
>          throw new BadSyntaxException();
>       String s = tok.sval;
>       nextToken();
>       return s;
>    }
>    
>    private void nextToken() {
>       try {
>          tok.nextToken();
>       }
>       catch(IOException e) {
>          throw new BadSyntaxException();
>       }
>    }
>    
>    private void initKeywords() {
>       keywords = Arrays.asList("select", "from", "where", "and",
>                                "insert", "into", "values", "delete", "update", "set", 
>                                "create", "table", "int", "varchar", "view", "as", "index", "on");
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/ModifyData.java ../cs4432-proj2/src/simpledb/parse/ModifyData.java
1,58c1,58
< package simpledb.parse;
< 
< import simpledb.query.*;
< 
< /**
<  * Data for the SQL <i>update</i> statement.
<  * @author Edward Sciore
<  */
< public class ModifyData {
<    private String tblname;
<    private String fldname;
<    private Expression newval;
<    private Predicate pred;
<    
<    /**
<     * Saves the table name, the modified field and its new value, and the predicate.
<     */
<    public ModifyData(String tblname, String fldname, Expression newval, Predicate pred) {
<       this.tblname = tblname;
<       this.fldname = fldname;
<       this.newval = newval;
<       this.pred = pred;
<    }
<    
<    /**
<     * Returns the name of the affected table.
<     * @return the name of the affected table
<     */
<    public String tableName() {
<       return tblname;
<    }
<    
<    /**
<     * Returns the field whose values will be modified
<     * @return the name of the target field
<     */
<    public String targetField() {
<       return fldname;
<    }
<    
<    /**
<     * Returns an expression.
<     * Evaluating this expression for a record produces
<     * the value that will be stored in the record's target field.
<     * @return the target expression
<     */
<    public Expression newValue() {
<       return newval;
<    }
<    
<    /**
<     * Returns the predicate that describes which
<     * records should be modified.
<     * @return the modification predicate
<     */
<    public Predicate pred() {
<       return pred;
<    }
---
> package simpledb.parse;
> 
> import simpledb.query.*;
> 
> /**
>  * Data for the SQL <i>update</i> statement.
>  * @author Edward Sciore
>  */
> public class ModifyData {
>    private String tblname;
>    private String fldname;
>    private Expression newval;
>    private Predicate pred;
>    
>    /**
>     * Saves the table name, the modified field and its new value, and the predicate.
>     */
>    public ModifyData(String tblname, String fldname, Expression newval, Predicate pred) {
>       this.tblname = tblname;
>       this.fldname = fldname;
>       this.newval = newval;
>       this.pred = pred;
>    }
>    
>    /**
>     * Returns the name of the affected table.
>     * @return the name of the affected table
>     */
>    public String tableName() {
>       return tblname;
>    }
>    
>    /**
>     * Returns the field whose values will be modified
>     * @return the name of the target field
>     */
>    public String targetField() {
>       return fldname;
>    }
>    
>    /**
>     * Returns an expression.
>     * Evaluating this expression for a record produces
>     * the value that will be stored in the record's target field.
>     * @return the target expression
>     */
>    public Expression newValue() {
>       return newval;
>    }
>    
>    /**
>     * Returns the predicate that describes which
>     * records should be modified.
>     * @return the modification predicate
>     */
>    public Predicate pred() {
>       return pred;
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/Parser.java ../cs4432-proj2/src/simpledb/parse/Parser.java
1,245c1,266
< package simpledb.parse;
< 
< import java.util.*;
< import simpledb.query.*;
< import simpledb.record.Schema;
< 
< /**
<  * The SimpleDB parser.
<  * @author Edward Sciore
<  */
< public class Parser {
<    private Lexer lex;
<    
<    public Parser(String s) {
<       lex = new Lexer(s);
<    }
<    
< // Methods for parsing predicates, terms, expressions, constants, and fields
<    
<    public String field() {
<       return lex.eatId();
<    }
<    
<    public Constant constant() {
<       if (lex.matchStringConstant())
<          return new StringConstant(lex.eatStringConstant());
<       else
<          return new IntConstant(lex.eatIntConstant());
<    }
<    
<    public Expression expression() {
<       if (lex.matchId())
<          return new FieldNameExpression(field());
<       else
<          return new ConstantExpression(constant());
<    }
<    
<    public Term term() {
<       Expression lhs = expression();
<       lex.eatDelim('=');
<       Expression rhs = expression();
<       return new Term(lhs, rhs);
<    }
<    
<    public Predicate predicate() {
<       Predicate pred = new Predicate(term());
<       if (lex.matchKeyword("and")) {
<          lex.eatKeyword("and");
<          pred.conjoinWith(predicate());
<       }
<       return pred;
<    }
<    
< // Methods for parsing queries
<    
<    public QueryData query() {
<       lex.eatKeyword("select");
<       Collection<String> fields = selectList();
<       lex.eatKeyword("from");
<       Collection<String> tables = tableList();
<       Predicate pred = new Predicate();
<       if (lex.matchKeyword("where")) {
<          lex.eatKeyword("where");
<          pred = predicate();
<       }
<       return new QueryData(fields, tables, pred);
<    }
<    
<    private Collection<String> selectList() {
<       Collection<String> L = new ArrayList<String>();
<       L.add(field());
<       if (lex.matchDelim(',')) {
<          lex.eatDelim(',');
<          L.addAll(selectList());
<       }
<       return L;
<    }
<    
<    private Collection<String> tableList() {
<       Collection<String> L = new ArrayList<String>();
<       L.add(lex.eatId());
<       if (lex.matchDelim(',')) {
<          lex.eatDelim(',');
<          L.addAll(tableList());
<       }
<       return L;
<    }
<    
< // Methods for parsing the various update commands
<    
<    public Object updateCmd() {
<       if (lex.matchKeyword("insert"))
<          return insert();
<       else if (lex.matchKeyword("delete"))
<          return delete();
<       else if (lex.matchKeyword("update"))
<          return modify();
<       else
<          return create();
<    }
<    
<    private Object create() {
<       lex.eatKeyword("create");
<       if (lex.matchKeyword("table"))
<          return createTable();
<       else if (lex.matchKeyword("view"))
<          return createView();
<       else
<          return createIndex();
<    }
<    
< // Method for parsing delete commands
<    
<    public DeleteData delete() {
<       lex.eatKeyword("delete");
<       lex.eatKeyword("from");
<       String tblname = lex.eatId();
<       Predicate pred = new Predicate();
<       if (lex.matchKeyword("where")) {
<          lex.eatKeyword("where");
<          pred = predicate();
<       }
<       return new DeleteData(tblname, pred);
<    }
<    
< // Methods for parsing insert commands
<    
<    public InsertData insert() {
<       lex.eatKeyword("insert");
<       lex.eatKeyword("into");
<       String tblname = lex.eatId();
<       lex.eatDelim('(');
<       List<String> flds = fieldList();
<       lex.eatDelim(')');
<       lex.eatKeyword("values");
<       lex.eatDelim('(');
<       List<Constant> vals = constList();
<       lex.eatDelim(')');
<       return new InsertData(tblname, flds, vals);
<    }
<    
<    private List<String> fieldList() {
<       List<String> L = new ArrayList<String>();
<       L.add(field());
<       if (lex.matchDelim(',')) {
<          lex.eatDelim(',');
<          L.addAll(fieldList());
<       }
<       return L;
<    }
<    
<    private List<Constant> constList() {
<       List<Constant> L = new ArrayList<Constant>();
<       L.add(constant());
<       if (lex.matchDelim(',')) {
<          lex.eatDelim(',');
<          L.addAll(constList());
<       }
<       return L;
<    }
<    
< // Method for parsing modify commands
<    
<    public ModifyData modify() {
<       lex.eatKeyword("update");
<       String tblname = lex.eatId();
<       lex.eatKeyword("set");
<       String fldname = field();
<       lex.eatDelim('=');
<       Expression newval = expression();
<       Predicate pred = new Predicate();
<       if (lex.matchKeyword("where")) {
<          lex.eatKeyword("where");
<          pred = predicate();
<       }
<       return new ModifyData(tblname, fldname, newval, pred);
<    }
<    
< // Method for parsing create table commands
<    
<    public CreateTableData createTable() {
<       lex.eatKeyword("table");
<       String tblname = lex.eatId();
<       lex.eatDelim('(');
<       Schema sch = fieldDefs();
<       lex.eatDelim(')');
<       return new CreateTableData(tblname, sch);
<    }
<    
<    private Schema fieldDefs() {
<       Schema schema = fieldDef();
<       if (lex.matchDelim(',')) {
<          lex.eatDelim(',');
<          Schema schema2 = fieldDefs();
<          schema.addAll(schema2);
<       }
<       return schema;
<    }
<    
<    private Schema fieldDef() {
<       String fldname = field();
<       return fieldType(fldname);
<    }
<    
<    private Schema fieldType(String fldname) {
<       Schema schema = new Schema();
<       if (lex.matchKeyword("int")) {
<          lex.eatKeyword("int");
<          schema.addIntField(fldname);
<       }
<       else {
<          lex.eatKeyword("varchar");
<          lex.eatDelim('(');
<          int strLen = lex.eatIntConstant();
<          lex.eatDelim(')');
<          schema.addStringField(fldname, strLen);
<       }
<       return schema;
<    }
<    
< // Method for parsing create view commands
<    
<    public CreateViewData createView() {
<       lex.eatKeyword("view");
<       String viewname = lex.eatId();
<       lex.eatKeyword("as");
<       QueryData qd = query();
<       return new CreateViewData(viewname, qd);
<    }
<    
<    
< //  Method for parsing create index commands
<    
<    public CreateIndexData createIndex() {
<       lex.eatKeyword("index");
<       String idxname = lex.eatId();
<       lex.eatKeyword("on");
<       String tblname = lex.eatId();
<       lex.eatDelim('(');
<       String fldname = field();
<       lex.eatDelim(')');
<       return new CreateIndexData(idxname, tblname, fldname);
<    }
< }
< 
---
> package simpledb.parse;
> 
> import java.util.ArrayList;
> import java.util.Collection;
> import java.util.List;
> 
> import simpledb.index.IndexType;
> import simpledb.query.Constant;
> import simpledb.query.ConstantExpression;
> import simpledb.query.Expression;
> import simpledb.query.FieldNameExpression;
> import simpledb.query.IntConstant;
> import simpledb.query.Predicate;
> import simpledb.query.StringConstant;
> import simpledb.query.Term;
> import simpledb.record.Schema;
> 
> /**
>  * The SimpleDB parser.
>  *
>  * @author Edward Sciore
>  */
> public class Parser {
>     private Lexer lex;
> 
>     public Parser(String s) {
>         lex = new Lexer(s);
>     }
> 
>     // Methods for parsing predicates, terms, expressions, constants, and fields
> 
>     public String field() {
>         return lex.eatId();
>     }
> 
>     public Constant constant() {
>         if (lex.matchStringConstant())
>             return new StringConstant(lex.eatStringConstant());
>         else
>             return new IntConstant(lex.eatIntConstant());
>     }
> 
>     public Expression expression() {
>         if (lex.matchId())
>             return new FieldNameExpression(field());
>         else
>             return new ConstantExpression(constant());
>     }
> 
>     public Term term() {
>         Expression lhs = expression();
>         lex.eatDelim('=');
>         Expression rhs = expression();
>         return new Term(lhs, rhs);
>     }
> 
>     public Predicate predicate() {
>         Predicate pred = new Predicate(term());
>         if (lex.matchKeyword("and")) {
>             lex.eatKeyword("and");
>             pred.conjoinWith(predicate());
>         }
>         return pred;
>     }
> 
>     // Methods for parsing queries
> 
>     public QueryData query() {
>         lex.eatKeyword("select");
>         Collection<String> fields = selectList();
>         lex.eatKeyword("from");
>         Collection<String> tables = tableList();
>         Predicate pred = new Predicate();
>         if (lex.matchKeyword("where")) {
>             lex.eatKeyword("where");
>             pred = predicate();
>         }
>         return new QueryData(fields, tables, pred);
>     }
> 
>     private Collection<String> selectList() {
>         Collection<String> L = new ArrayList<String>();
>         L.add(field());
>         if (lex.matchDelim(',')) {
>             lex.eatDelim(',');
>             L.addAll(selectList());
>         }
>         return L;
>     }
> 
>     private Collection<String> tableList() {
>         Collection<String> L = new ArrayList<String>();
>         L.add(lex.eatId());
>         if (lex.matchDelim(',')) {
>             lex.eatDelim(',');
>             L.addAll(tableList());
>         }
>         return L;
>     }
> 
>     // Methods for parsing the various update commands
> 
>     public Object updateCmd() {
>         if (lex.matchKeyword("insert"))
>             return insert();
>         else if (lex.matchKeyword("delete"))
>             return delete();
>         else if (lex.matchKeyword("update"))
>             return modify();
>         else
>             return create();
>     }
> 
>     private Object create() {
>         lex.eatKeyword("create");
>         if (lex.matchKeyword("table"))
>             return createTable();
>         else if (lex.matchKeyword("view"))
>             return createView();
>         else
>             return createIndex();
>     }
> 
>     // Method for parsing delete commands
> 
>     public DeleteData delete() {
>         lex.eatKeyword("delete");
>         lex.eatKeyword("from");
>         String tblname = lex.eatId();
>         Predicate pred = new Predicate();
>         if (lex.matchKeyword("where")) {
>             lex.eatKeyword("where");
>             pred = predicate();
>         }
>         return new DeleteData(tblname, pred);
>     }
> 
>     // Methods for parsing insert commands
> 
>     public InsertData insert() {
>         lex.eatKeyword("insert");
>         lex.eatKeyword("into");
>         String tblname = lex.eatId();
>         lex.eatDelim('(');
>         List<String> flds = fieldList();
>         lex.eatDelim(')');
>         lex.eatKeyword("values");
>         lex.eatDelim('(');
>         List<Constant> vals = constList();
>         lex.eatDelim(')');
>         return new InsertData(tblname, flds, vals);
>     }
> 
>     private List<String> fieldList() {
>         List<String> L = new ArrayList<String>();
>         L.add(field());
>         if (lex.matchDelim(',')) {
>             lex.eatDelim(',');
>             L.addAll(fieldList());
>         }
>         return L;
>     }
> 
>     private List<Constant> constList() {
>         List<Constant> L = new ArrayList<Constant>();
>         L.add(constant());
>         if (lex.matchDelim(',')) {
>             lex.eatDelim(',');
>             L.addAll(constList());
>         }
>         return L;
>     }
> 
>     // Method for parsing modify commands
> 
>     public ModifyData modify() {
>         lex.eatKeyword("update");
>         String tblname = lex.eatId();
>         lex.eatKeyword("set");
>         String fldname = field();
>         lex.eatDelim('=');
>         Expression newval = expression();
>         Predicate pred = new Predicate();
>         if (lex.matchKeyword("where")) {
>             lex.eatKeyword("where");
>             pred = predicate();
>         }
>         return new ModifyData(tblname, fldname, newval, pred);
>     }
> 
>     // Method for parsing create table commands
> 
>     public CreateTableData createTable() {
>         lex.eatKeyword("table");
>         String tblname = lex.eatId();
>         lex.eatDelim('(');
>         Schema sch = fieldDefs();
>         lex.eatDelim(')');
>         return new CreateTableData(tblname, sch);
>     }
> 
>     private Schema fieldDefs() {
>         Schema schema = fieldDef();
>         if (lex.matchDelim(',')) {
>             lex.eatDelim(',');
>             Schema schema2 = fieldDefs();
>             schema.addAll(schema2);
>         }
>         return schema;
>     }
> 
>     private Schema fieldDef() {
>         String fldname = field();
>         return fieldType(fldname);
>     }
> 
>     private Schema fieldType(String fldname) {
>         Schema schema = new Schema();
>         if (lex.matchKeyword("int")) {
>             lex.eatKeyword("int");
>             schema.addIntField(fldname);
>         } else {
>             lex.eatKeyword("varchar");
>             lex.eatDelim('(');
>             int strLen = lex.eatIntConstant();
>             lex.eatDelim(')');
>             schema.addStringField(fldname, strLen);
>         }
>         return schema;
>     }
> 
>     // Method for parsing create view commands
> 
>     public CreateViewData createView() {
>         lex.eatKeyword("view");
>         String viewname = lex.eatId();
>         lex.eatKeyword("as");
>         QueryData qd = query();
>         return new CreateViewData(viewname, qd);
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We added parsing the index ID to get the index type.
>      *
>      * Method for parsing create index commands
>      *
>      * @return a CreateIndexData
>      */
>     public CreateIndexData createIndex() {
>         String type = lex.eatId();
> 
>         // Get the index type ID
>         lex.eatKeyword("index");
>         String idxname = lex.eatId();
>         lex.eatKeyword("on");
>         String tblname = lex.eatId();
>         lex.eatDelim('(');
>         String fldname = field();
>         lex.eatDelim(')');
> 
>         // Pass in the index type
>         return new CreateIndexData(idxname, tblname, fldname, IndexType.valueOf(type));
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/parse/QueryData.java ../cs4432-proj2/src/simpledb/parse/QueryData.java
1,63c1,63
< package simpledb.parse;
< 
< import simpledb.query.*;
< import java.util.*;
< 
< /**
<  * Data for the SQL <i>select</i> statement.
<  * @author Edward Sciore
<  */
< public class QueryData {
<    private Collection<String> fields;
<    private Collection<String> tables;
<    private Predicate pred;
<    
<    /**
<     * Saves the field and table list and predicate.
<     */
<    public QueryData(Collection<String> fields, Collection<String> tables, Predicate pred) {
<       this.fields = fields;
<       this.tables = tables;
<       this.pred = pred;
<    }
<    
<    /**
<     * Returns the fields mentioned in the select clause.
<     * @return a collection of field names
<     */
<    public Collection<String> fields() {
<       return fields;
<    }
<    
<    /**
<     * Returns the tables mentioned in the from clause.
<     * @return a collection of table names
<     */
<    public Collection<String> tables() {
<       return tables;
<    }
<    
<    /**
<     * Returns the predicate that describes which
<     * records should be in the output table.
<     * @return the query predicate
<     */
<    public Predicate pred() {
<       return pred;
<    }
<    
<    public String toString() {
<       String result = "select ";
<       for (String fldname : fields)
<          result += fldname + ", ";
<       result = result.substring(0, result.length()-2); //remove final comma
<       result += " from ";
<       for (String tblname : tables)
<          result += tblname + ", ";
<       result = result.substring(0, result.length()-2); //remove final comma
<       String predstring = pred.toString();
<       if (!predstring.equals(""))
<          result += " where " + predstring;
<       return result;
<    }
< }
---
> package simpledb.parse;
> 
> import simpledb.query.*;
> import java.util.*;
> 
> /**
>  * Data for the SQL <i>select</i> statement.
>  * @author Edward Sciore
>  */
> public class QueryData {
>    private Collection<String> fields;
>    private Collection<String> tables;
>    private Predicate pred;
>    
>    /**
>     * Saves the field and table list and predicate.
>     */
>    public QueryData(Collection<String> fields, Collection<String> tables, Predicate pred) {
>       this.fields = fields;
>       this.tables = tables;
>       this.pred = pred;
>    }
>    
>    /**
>     * Returns the fields mentioned in the select clause.
>     * @return a collection of field names
>     */
>    public Collection<String> fields() {
>       return fields;
>    }
>    
>    /**
>     * Returns the tables mentioned in the from clause.
>     * @return a collection of table names
>     */
>    public Collection<String> tables() {
>       return tables;
>    }
>    
>    /**
>     * Returns the predicate that describes which
>     * records should be in the output table.
>     * @return the query predicate
>     */
>    public Predicate pred() {
>       return pred;
>    }
>    
>    public String toString() {
>       String result = "select ";
>       for (String fldname : fields)
>          result += fldname + ", ";
>       result = result.substring(0, result.length()-2); //remove final comma
>       result += " from ";
>       for (String tblname : tables)
>          result += tblname + ", ";
>       result = result.substring(0, result.length()-2); //remove final comma
>       String predstring = pred.toString();
>       if (!predstring.equals(""))
>          result += " where " + predstring;
>       return result;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/planner/BasicQueryPlanner.java ../cs4432-proj2/src/simpledb/planner/BasicQueryPlanner.java
1,43c1,43
< package simpledb.planner;
< 
< import simpledb.tx.Transaction;
< import simpledb.query.*;
< import simpledb.parse.*;
< import simpledb.server.SimpleDB;
< import java.util.*;
< 
< /**
<  * The simplest, most naive query planner possible.
<  * @author Edward Sciore
<  */
< public class BasicQueryPlanner implements QueryPlanner {
<    
<    /**
<     * Creates a query plan as follows.  It first takes
<     * the product of all tables and views; it then selects on the predicate;
<     * and finally it projects on the field list. 
<     */
<    public Plan createPlan(QueryData data, Transaction tx) {
<       //Step 1: Create a plan for each mentioned table or view
<       List<Plan> plans = new ArrayList<Plan>();
<       for (String tblname : data.tables()) {
<          String viewdef = SimpleDB.mdMgr().getViewDef(tblname, tx);
<          if (viewdef != null)
<             plans.add(SimpleDB.planner().createQueryPlan(viewdef, tx));
<          else
<             plans.add(new TablePlan(tblname, tx));
<       }
<       
<       //Step 2: Create the product of all table plans
<       Plan p = plans.remove(0);
<       for (Plan nextplan : plans)
<          p = new ProductPlan(p, nextplan);
<       
<       //Step 3: Add a selection plan for the predicate
<       p = new SelectPlan(p, data.pred());
<       
<       //Step 4: Project on the field names
<       p = new ProjectPlan(p, data.fields());
<       return p;
<    }
< }
---
> package simpledb.planner;
> 
> import simpledb.tx.Transaction;
> import simpledb.query.*;
> import simpledb.parse.*;
> import simpledb.server.SimpleDB;
> import java.util.*;
> 
> /**
>  * The simplest, most naive query planner possible.
>  * @author Edward Sciore
>  */
> public class BasicQueryPlanner implements QueryPlanner {
>    
>    /**
>     * Creates a query plan as follows.  It first takes
>     * the product of all tables and views; it then selects on the predicate;
>     * and finally it projects on the field list. 
>     */
>    public Plan createPlan(QueryData data, Transaction tx) {
>       //Step 1: Create a plan for each mentioned table or view
>       List<Plan> plans = new ArrayList<Plan>();
>       for (String tblname : data.tables()) {
>          String viewdef = SimpleDB.mdMgr().getViewDef(tblname, tx);
>          if (viewdef != null)
>             plans.add(SimpleDB.planner().createQueryPlan(viewdef, tx));
>          else
>             plans.add(new TablePlan(tblname, tx));
>       }
>       
>       //Step 2: Create the product of all table plans
>       Plan p = plans.remove(0);
>       for (Plan nextplan : plans)
>          p = new ProductPlan(p, nextplan);
>       
>       //Step 3: Add a selection plan for the predicate
>       p = new SelectPlan(p, data.pred());
>       
>       //Step 4: Project on the field names
>       p = new ProjectPlan(p, data.fields());
>       return p;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/planner/BasicUpdatePlanner.java ../cs4432-proj2/src/simpledb/planner/BasicUpdatePlanner.java
1,68c1,120
< package simpledb.planner;
< 
< import java.util.Iterator;
< import simpledb.server.SimpleDB;
< import simpledb.tx.Transaction;
< import simpledb.parse.*;
< import simpledb.query.*;
< 
< /**
<  * The basic planner for SQL update statements.
<  * @author sciore
<  */
< public class BasicUpdatePlanner implements UpdatePlanner {
<    
<    public int executeDelete(DeleteData data, Transaction tx) {
<       Plan p = new TablePlan(data.tableName(), tx);
<       p = new SelectPlan(p, data.pred());
<       UpdateScan us = (UpdateScan) p.open();
<       int count = 0;
<       while(us.next()) {
<          us.delete();
<          count++;
<       }
<       us.close();
<       return count;
<    }
<    
<    public int executeModify(ModifyData data, Transaction tx) {
<       Plan p = new TablePlan(data.tableName(), tx);
<       p = new SelectPlan(p, data.pred());
<       UpdateScan us = (UpdateScan) p.open();
<       int count = 0;
<       while(us.next()) {
<          Constant val = data.newValue().evaluate(us);
<          us.setVal(data.targetField(), val);
<          count++;
<       }
<       us.close();
<       return count;
<    }
<    
<    public int executeInsert(InsertData data, Transaction tx) {
<       Plan p = new TablePlan(data.tableName(), tx);
<       UpdateScan us = (UpdateScan) p.open();
<       us.insert();
<       Iterator<Constant> iter = data.vals().iterator();
<       for (String fldname : data.fields()) {
<          Constant val = iter.next();
<          us.setVal(fldname, val);
<       }
<       us.close();
<       return 1;
<    }
<    
<    public int executeCreateTable(CreateTableData data, Transaction tx) {
<       SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
<       return 0;
<    }
<    
<    public int executeCreateView(CreateViewData data, Transaction tx) {
<       SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
<       return 0;
<    }
<    public int executeCreateIndex(CreateIndexData data, Transaction tx) {
<       SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx);
<       return 0;  
<    }
< }
---
> package simpledb.planner;
> 
> import java.util.Iterator;
> 
> import simpledb.parse.CreateIndexData;
> import simpledb.parse.CreateTableData;
> import simpledb.parse.CreateViewData;
> import simpledb.parse.DeleteData;
> import simpledb.parse.InsertData;
> import simpledb.parse.ModifyData;
> import simpledb.query.Constant;
> import simpledb.query.Plan;
> import simpledb.query.SelectPlan;
> import simpledb.query.TablePlan;
> import simpledb.query.UpdateScan;
> import simpledb.server.SimpleDB;
> import simpledb.tx.Transaction;
> 
> /**
>  * The basic planner for SQL update statements.
>  *
>  * @author sciore
>  */
> public class BasicUpdatePlanner implements UpdatePlanner {
> 
> 	@Override
> 	public int executeDelete(DeleteData data, Transaction tx) {
> 		Plan p = new TablePlan(data.tableName(), tx);
> 		p = new SelectPlan(p, data.pred());
> 		UpdateScan us = (UpdateScan) p.open();
> 		int count = 0;
> 		while (us.next()) {
> 			us.delete();
> 			count++;
> 		}
> 		us.close();
> 		return count;
> 	}
> 
> 	@Override
> 	public int executeModify(ModifyData data, Transaction tx) {
> 		Plan p = new TablePlan(data.tableName(), tx);
> 		p = new SelectPlan(p, data.pred());
> 		UpdateScan us = (UpdateScan) p.open();
> 		int count = 0;
> 		while (us.next()) {
> 			Constant val = data.newValue().evaluate(us);
> 			us.setVal(data.targetField(), val);
> 			count++;
> 		}
> 		us.close();
> 
>         // Modify table metadata
>         TablePlan mdplan = new TablePlan("tblcat", tx);
>         UpdateScan mdscan = (UpdateScan) mdplan.open();
>         mdscan.beforeFirst();
>         while (mdscan.next()) {
>             if (mdscan.getString("tblname").equals(data.tableName())) {
>                 mdscan.setString("sortname", "");
>             }
>         }
>         mdscan.close();
>         
> 		return count;
> 	}
> 
> 	@Override
> 	public int executeInsert(InsertData data, Transaction tx) {
> 		Plan p = new TablePlan(data.tableName(), tx);
> 		UpdateScan us = (UpdateScan) p.open();
> 		us.insert();
> 		Iterator<Constant> iter = data.vals().iterator();
> 		for (String fldname : data.fields()) {
> 			Constant val = iter.next();
> 			us.setVal(fldname, val);
> 		}
> 		us.close();
> 
>         // Modify table metadata
>         TablePlan mdplan = new TablePlan("tblcat", tx);
>         UpdateScan mdscan = (UpdateScan) mdplan.open();
>         mdscan.beforeFirst();
>         while (mdscan.next()) {
>             if (mdscan.getString("tblname").equals(data.tableName())) {
>                 mdscan.setString("sortname", "");
>             }
>         }
>         mdscan.close();
> 
> 		return 1;
> 	}
> 
> 	@Override
> 	public int executeCreateTable(CreateTableData data, Transaction tx) {
> 		SimpleDB.mdMgr().createTable(data.tableName(), data.newSchema(), tx);
> 		return 0;
> 	}
> 
> 	@Override
> 	public int executeCreateView(CreateViewData data, Transaction tx) {
> 		SimpleDB.mdMgr().createView(data.viewName(), data.viewDef(), tx);
> 		return 0;
> 	}
> 
> 	/**
> 	 * CS 4432 Project 2
> 	 *
> 	 * We modified the arguments passed to createIndex() to pass the index type.
> 	 *
> 	 * (non-Javadoc)
> 	 *
> 	 * @see simpledb.planner.UpdatePlanner#executeCreateIndex(simpledb.parse.CreateIndexData,
> 	 *      simpledb.tx.Transaction)
> 	 */
> 	@Override
> 	public int executeCreateIndex(CreateIndexData data, Transaction tx) {
> 		SimpleDB.mdMgr().createIndex(data.indexName(), data.tableName(), data.fieldName(), tx, data.indexType());
> 		return 0;
> 	}
> }
Only in ../cs4432-proj2/src/simpledb/planner: ExploitSortQueryPlanner.java
diff -r simpledb/SimpleDB_2.10/simpledb/planner/Planner.java ../cs4432-proj2/src/simpledb/planner/Planner.java
1,60c1,60
< package simpledb.planner;
< 
< import simpledb.tx.Transaction;
< import simpledb.parse.*;
< import simpledb.query.*;
< 
< /**
<  * The object that executes SQL statements.
<  * @author sciore
<  */
< public class Planner {
<    private QueryPlanner qplanner;
<    private UpdatePlanner uplanner;
<    
<    public Planner(QueryPlanner qplanner, UpdatePlanner uplanner) {
<       this.qplanner = qplanner;
<       this.uplanner = uplanner;
<    }
<    
<    /**
<     * Creates a plan for an SQL select statement, using the supplied planner.
<     * @param qry the SQL query string
<     * @param tx the transaction
<     * @return the scan corresponding to the query plan
<     */
<    public Plan createQueryPlan(String qry, Transaction tx) {
<       Parser parser = new Parser(qry);
<       QueryData data = parser.query();
<       return qplanner.createPlan(data, tx);
<    }
<    
<    /**
<     * Executes an SQL insert, delete, modify, or
<     * create statement.
<     * The method dispatches to the appropriate method of the
<     * supplied update planner,
<     * depending on what the parser returns.
<     * @param cmd the SQL update string
<     * @param tx the transaction
<     * @return an integer denoting the number of affected records
<     */
<    public int executeUpdate(String cmd, Transaction tx) {
<       Parser parser = new Parser(cmd);
<       Object obj = parser.updateCmd();
<       if (obj instanceof InsertData)
<          return uplanner.executeInsert((InsertData)obj, tx);
<       else if (obj instanceof DeleteData)
<          return uplanner.executeDelete((DeleteData)obj, tx);
<       else if (obj instanceof ModifyData)
<          return uplanner.executeModify((ModifyData)obj, tx);
<       else if (obj instanceof CreateTableData)
<          return uplanner.executeCreateTable((CreateTableData)obj, tx);
<       else if (obj instanceof CreateViewData)
<          return uplanner.executeCreateView((CreateViewData)obj, tx);
<       else if (obj instanceof CreateIndexData)
<          return uplanner.executeCreateIndex((CreateIndexData)obj, tx);
<       else
<          return 0;
<    }
< }
---
> package simpledb.planner;
> 
> import simpledb.tx.Transaction;
> import simpledb.parse.*;
> import simpledb.query.*;
> 
> /**
>  * The object that executes SQL statements.
>  * @author sciore
>  */
> public class Planner {
>    private QueryPlanner qplanner;
>    private UpdatePlanner uplanner;
>    
>    public Planner(QueryPlanner qplanner, UpdatePlanner uplanner) {
>       this.qplanner = qplanner;
>       this.uplanner = uplanner;
>    }
>    
>    /**
>     * Creates a plan for an SQL select statement, using the supplied planner.
>     * @param qry the SQL query string
>     * @param tx the transaction
>     * @return the scan corresponding to the query plan
>     */
>    public Plan createQueryPlan(String qry, Transaction tx) {
>       Parser parser = new Parser(qry);
>       QueryData data = parser.query();
>       return qplanner.createPlan(data, tx);
>    }
>    
>    /**
>     * Executes an SQL insert, delete, modify, or
>     * create statement.
>     * The method dispatches to the appropriate method of the
>     * supplied update planner,
>     * depending on what the parser returns.
>     * @param cmd the SQL update string
>     * @param tx the transaction
>     * @return an integer denoting the number of affected records
>     */
>    public int executeUpdate(String cmd, Transaction tx) {
>       Parser parser = new Parser(cmd);
>       Object obj = parser.updateCmd();
>       if (obj instanceof InsertData)
>          return uplanner.executeInsert((InsertData)obj, tx);
>       else if (obj instanceof DeleteData)
>          return uplanner.executeDelete((DeleteData)obj, tx);
>       else if (obj instanceof ModifyData)
>          return uplanner.executeModify((ModifyData)obj, tx);
>       else if (obj instanceof CreateTableData)
>          return uplanner.executeCreateTable((CreateTableData)obj, tx);
>       else if (obj instanceof CreateViewData)
>          return uplanner.executeCreateView((CreateViewData)obj, tx);
>       else if (obj instanceof CreateIndexData)
>          return uplanner.executeCreateIndex((CreateIndexData)obj, tx);
>       else
>          return 0;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/planner/QueryPlanner.java ../cs4432-proj2/src/simpledb/planner/QueryPlanner.java
1,22c1,22
< package simpledb.planner;
< 
< import simpledb.tx.Transaction;
< import simpledb.query.Plan;
< import simpledb.parse.QueryData;
< 
< /**
<  * The interface implemented by planners for 
<  * the SQL select statement.
<  * @author Edward Sciore
<  *
<  */
< public interface QueryPlanner {
<    
<    /**
<     * Creates a plan for the parsed query.
<     * @param data the parsed representation of the query
<     * @param tx the calling transaction
<     * @return a plan for that query
<     */
<    public Plan createPlan(QueryData data, Transaction tx);
< }
---
> package simpledb.planner;
> 
> import simpledb.tx.Transaction;
> import simpledb.query.Plan;
> import simpledb.parse.QueryData;
> 
> /**
>  * The interface implemented by planners for 
>  * the SQL select statement.
>  * @author Edward Sciore
>  *
>  */
> public interface QueryPlanner {
>    
>    /**
>     * Creates a plan for the parsed query.
>     * @param data the parsed representation of the query
>     * @param tx the calling transaction
>     * @return a plan for that query
>     */
>    public Plan createPlan(QueryData data, Transaction tx);
> }
Only in ../cs4432-proj2/src/simpledb/planner: SortQueryPlanner.java
diff -r simpledb/SimpleDB_2.10/simpledb/planner/UpdatePlanner.java ../cs4432-proj2/src/simpledb/planner/UpdatePlanner.java
1,66c1,66
< package simpledb.planner;
< 
< import simpledb.tx.Transaction;
< import simpledb.parse.*;
< 
< /**
<  * The interface implemented by the planners
<  * for SQL insert, delete, and modify statements.
<  * @author Edward Sciore
<  */
< public interface UpdatePlanner {
<    
<    /**
<     * Executes the specified insert statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the insert statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeInsert(InsertData data, Transaction tx);
<    
<    /**
<     * Executes the specified delete statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the delete statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeDelete(DeleteData data, Transaction tx);
<    
<    /**
<     * Executes the specified modify statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the modify statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeModify(ModifyData data, Transaction tx);
<    
<    /**
<     * Executes the specified create table statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the create table statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeCreateTable(CreateTableData data, Transaction tx);
<    
<    /**
<     * Executes the specified create view statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the create view statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeCreateView(CreateViewData data, Transaction tx);
<    
<    /**
<     * Executes the specified create index statement, and
<     * returns the number of affected records.
<     * @param data the parsed representation of the create index statement
<     * @param tx the calling transaction
<     * @return the number of affected records
<     */
<    public int executeCreateIndex(CreateIndexData data, Transaction tx);
< }
---
> package simpledb.planner;
> 
> import simpledb.tx.Transaction;
> import simpledb.parse.*;
> 
> /**
>  * The interface implemented by the planners
>  * for SQL insert, delete, and modify statements.
>  * @author Edward Sciore
>  */
> public interface UpdatePlanner {
>    
>    /**
>     * Executes the specified insert statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the insert statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeInsert(InsertData data, Transaction tx);
>    
>    /**
>     * Executes the specified delete statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the delete statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeDelete(DeleteData data, Transaction tx);
>    
>    /**
>     * Executes the specified modify statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the modify statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeModify(ModifyData data, Transaction tx);
>    
>    /**
>     * Executes the specified create table statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the create table statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeCreateTable(CreateTableData data, Transaction tx);
>    
>    /**
>     * Executes the specified create view statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the create view statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeCreateView(CreateViewData data, Transaction tx);
>    
>    /**
>     * Executes the specified create index statement, and
>     * returns the number of affected records.
>     * @param data the parsed representation of the create index statement
>     * @param tx the calling transaction
>     * @return the number of affected records
>     */
>    public int executeCreateIndex(CreateIndexData data, Transaction tx);
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Constant.java ../cs4432-proj2/src/simpledb/query/Constant.java
1,14c1,14
< package simpledb.query;
< 
< /**
<  * The interface that denotes values stored in the database.
<  * @author Edward Sciore
<  */
< public interface Constant extends Comparable<Constant> {
<    
<    /**
<     * Returns the Java object corresponding to this constant.
<     * @return the Java value of the constant
<     */
<    public Object  asJavaVal();
< }
---
> package simpledb.query;
> 
> /**
>  * The interface that denotes values stored in the database.
>  * @author Edward Sciore
>  */
> public interface Constant extends Comparable<Constant> {
>    
>    /**
>     * Returns the Java object corresponding to this constant.
>     * @return the Java value of the constant
>     */
>    public Object  asJavaVal();
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/ConstantExpression.java ../cs4432-proj2/src/simpledb/query/ConstantExpression.java
1,73c1,73
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /**
<  * An expression consisting entirely of a single constant.
<  * @author Edward Sciore
<  *
<  */
< public class ConstantExpression implements Expression {
<    private Constant val;
<    
<    /**
<     * Creates a new expression by wrapping a constant.
<     * @param c the constant
<     */
<    public ConstantExpression(Constant c) {
<       val = c;
<    }
<    
<    /**
<     * Returns true.
<     * @see simpledb.query.Expression#isConstant()
<     */
<    public boolean isConstant() {
<       return true;
<    }
<    
<    /**
<     * Returns false.
<     * @see simpledb.query.Expression#isFieldName()
<     */
<    public boolean isFieldName() {
<       return false;
<    }
<    
<    /**
<     * Unwraps the constant and returns it.
<     * @see simpledb.query.Expression#asConstant()
<     */
<    public Constant asConstant() {
<       return val;
<    }
<    
<    /**
<     * This method should never be called.
<     * Throws a ClassCastException.
<     * @see simpledb.query.Expression#asFieldName()
<     */
<    public String asFieldName() {
<       throw new ClassCastException();
<    }
<    
<    /**
<     * Returns the constant, regardless of the scan.
<     * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
<     */
<    public Constant evaluate(Scan s) {
<       return val;
<    }
<    
<    /**
<     * Returns true, because a constant applies to any schema.
<     * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
<     */
<    public boolean appliesTo(Schema sch) {
<       return true;
<    }
<    
<    public String toString() {
<       return val.toString();
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /**
>  * An expression consisting entirely of a single constant.
>  * @author Edward Sciore
>  *
>  */
> public class ConstantExpression implements Expression {
>    private Constant val;
>    
>    /**
>     * Creates a new expression by wrapping a constant.
>     * @param c the constant
>     */
>    public ConstantExpression(Constant c) {
>       val = c;
>    }
>    
>    /**
>     * Returns true.
>     * @see simpledb.query.Expression#isConstant()
>     */
>    public boolean isConstant() {
>       return true;
>    }
>    
>    /**
>     * Returns false.
>     * @see simpledb.query.Expression#isFieldName()
>     */
>    public boolean isFieldName() {
>       return false;
>    }
>    
>    /**
>     * Unwraps the constant and returns it.
>     * @see simpledb.query.Expression#asConstant()
>     */
>    public Constant asConstant() {
>       return val;
>    }
>    
>    /**
>     * This method should never be called.
>     * Throws a ClassCastException.
>     * @see simpledb.query.Expression#asFieldName()
>     */
>    public String asFieldName() {
>       throw new ClassCastException();
>    }
>    
>    /**
>     * Returns the constant, regardless of the scan.
>     * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
>     */
>    public Constant evaluate(Scan s) {
>       return val;
>    }
>    
>    /**
>     * Returns true, because a constant applies to any schema.
>     * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
>     */
>    public boolean appliesTo(Schema sch) {
>       return true;
>    }
>    
>    public String toString() {
>       return val.toString();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Expression.java ../cs4432-proj2/src/simpledb/query/Expression.java
1,55c1,55
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /**
<  * The interface corresponding to SQL expressions.
<  * @author Edward Sciore
<  *
<  */
< public interface Expression {
<    
<    /**
<     * Returns true if the expression is a constant.
<     * @return true if the expression is a constant
<     */
<    public boolean  isConstant();
<    
<    /**
<     * Returns true if the expression is a field reference.
<     * @return true if the expression denotes a field
<     */
<    public boolean  isFieldName();
<    
<    /**
<     * Returns the constant corresponding to a constant expression.
<     * Throws an exception if the expression does not
<     * denote a constant.
<     * @return the expression as a constant
<     */
<    public Constant asConstant();
<    
<    /**
<     * Returns the field name corresponding to a constant expression.
<     * Throws an exception if the expression does not
<     * denote a field.
<     * @return the expression as a field name
<     */
<    public String   asFieldName();
<    
<    /**
<     * Evaluates the expression with respect to the
<     * current record of the specified scan.
<     * @param s the scan
<     * @return the value of the expression, as a Constant
<     */
<    public Constant evaluate(Scan s);
<    
<    /**
<     * Determines if all of the fields mentioned in this expression
<     * are contained in the specified schema.
<     * @param sch the schema
<     * @return true if all fields in the expression are in the schema
<     */
<    public boolean  appliesTo(Schema sch);
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /**
>  * The interface corresponding to SQL expressions.
>  * @author Edward Sciore
>  *
>  */
> public interface Expression {
>    
>    /**
>     * Returns true if the expression is a constant.
>     * @return true if the expression is a constant
>     */
>    public boolean  isConstant();
>    
>    /**
>     * Returns true if the expression is a field reference.
>     * @return true if the expression denotes a field
>     */
>    public boolean  isFieldName();
>    
>    /**
>     * Returns the constant corresponding to a constant expression.
>     * Throws an exception if the expression does not
>     * denote a constant.
>     * @return the expression as a constant
>     */
>    public Constant asConstant();
>    
>    /**
>     * Returns the field name corresponding to a constant expression.
>     * Throws an exception if the expression does not
>     * denote a field.
>     * @return the expression as a field name
>     */
>    public String   asFieldName();
>    
>    /**
>     * Evaluates the expression with respect to the
>     * current record of the specified scan.
>     * @param s the scan
>     * @return the value of the expression, as a Constant
>     */
>    public Constant evaluate(Scan s);
>    
>    /**
>     * Determines if all of the fields mentioned in this expression
>     * are contained in the specified schema.
>     * @param sch the schema
>     * @return true if all fields in the expression are in the schema
>     */
>    public boolean  appliesTo(Schema sch);
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/FieldNameExpression.java ../cs4432-proj2/src/simpledb/query/FieldNameExpression.java
1,73c1,73
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /**
<  * An expression consisting entirely of a single field.
<  * @author Edward Sciore
<  *
<  */
< public class FieldNameExpression implements Expression {
<    private String fldname;
<    
<    /**
<     * Creates a new expression by wrapping a field.
<     * @param fldname the name of the wrapped field
<     */
<    public FieldNameExpression(String fldname) {
<       this.fldname = fldname;
<    }
<    
<    /**
<     * Returns false.
<     * @see simpledb.query.Expression#isConstant()
<     */
<    public boolean isConstant() {
<       return false;
<    }
<    
<    /**
<     * Returns true.
<     * @see simpledb.query.Expression#isFieldName()
<     */
<    public boolean isFieldName() {
<       return true;
<    }
<    
<    /**
<     * This method should never be called.
<     * Throws a ClassCastException.
<     * @see simpledb.query.Expression#asConstant()
<     */
<    public Constant asConstant() {
<       throw new ClassCastException();
<    }
<    
<    /**
<     * Unwraps the field name and returns it.
<     * @see simpledb.query.Expression#asFieldName()
<     */
<    public String asFieldName() {
<       return fldname;
<    }
<    
<    /**
<     * Evaluates the field by getting its value in the scan.
<     * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
<     */
<    public Constant evaluate(Scan s) {
<       return s.getVal(fldname);
<    }
<    
<    /** 
<     * Returns true if the field is in the specified schema.
<     * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
<     */
<    public boolean appliesTo(Schema sch) {
<       return sch.hasField(fldname);
<    }
<    
<    public String toString() {
<       return fldname;
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /**
>  * An expression consisting entirely of a single field.
>  * @author Edward Sciore
>  *
>  */
> public class FieldNameExpression implements Expression {
>    private String fldname;
>    
>    /**
>     * Creates a new expression by wrapping a field.
>     * @param fldname the name of the wrapped field
>     */
>    public FieldNameExpression(String fldname) {
>       this.fldname = fldname;
>    }
>    
>    /**
>     * Returns false.
>     * @see simpledb.query.Expression#isConstant()
>     */
>    public boolean isConstant() {
>       return false;
>    }
>    
>    /**
>     * Returns true.
>     * @see simpledb.query.Expression#isFieldName()
>     */
>    public boolean isFieldName() {
>       return true;
>    }
>    
>    /**
>     * This method should never be called.
>     * Throws a ClassCastException.
>     * @see simpledb.query.Expression#asConstant()
>     */
>    public Constant asConstant() {
>       throw new ClassCastException();
>    }
>    
>    /**
>     * Unwraps the field name and returns it.
>     * @see simpledb.query.Expression#asFieldName()
>     */
>    public String asFieldName() {
>       return fldname;
>    }
>    
>    /**
>     * Evaluates the field by getting its value in the scan.
>     * @see simpledb.query.Expression#evaluate(simpledb.query.Scan)
>     */
>    public Constant evaluate(Scan s) {
>       return s.getVal(fldname);
>    }
>    
>    /** 
>     * Returns true if the field is in the specified schema.
>     * @see simpledb.query.Expression#appliesTo(simpledb.record.Schema)
>     */
>    public boolean appliesTo(Schema sch) {
>       return sch.hasField(fldname);
>    }
>    
>    public String toString() {
>       return fldname;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/IntConstant.java ../cs4432-proj2/src/simpledb/query/IntConstant.java
1,43c1,43
< package simpledb.query;
< 
< /**
<  * The class that wraps Java ints as database constants.
<  * @author Edward Sciore
<  */
< public class IntConstant implements Constant {
<    private Integer val;
<    
<    /**
<     * Create a constant by wrapping the specified int.
<     * @param n the int value
<     */
<    public IntConstant(int n) {
<       val = new Integer(n);
<    }
<    
<    /**
<     * Unwraps the Integer and returns it.
<     * @see simpledb.query.Constant#asJavaVal()
<     */
<    public Object asJavaVal() {
<       return val;
<    }
<    
<    public boolean equals(Object obj) {
<       IntConstant ic = (IntConstant) obj;
<       return ic != null && val.equals(ic.val);
<    }
<    
<    public int compareTo(Constant c) {
<       IntConstant ic = (IntConstant) c;
<       return val.compareTo(ic.val);
<    }
<    
<    public int hashCode() {
<       return val.hashCode();
<    }
<    
<    public String toString() {
<       return val.toString();
<    }
< }
---
> package simpledb.query;
> 
> /**
>  * The class that wraps Java ints as database constants.
>  * @author Edward Sciore
>  */
> public class IntConstant implements Constant {
>    private Integer val;
>    
>    /**
>     * Create a constant by wrapping the specified int.
>     * @param n the int value
>     */
>    public IntConstant(int n) {
>       val = new Integer(n);
>    }
>    
>    /**
>     * Unwraps the Integer and returns it.
>     * @see simpledb.query.Constant#asJavaVal()
>     */
>    public Object asJavaVal() {
>       return val;
>    }
>    
>    public boolean equals(Object obj) {
>       IntConstant ic = (IntConstant) obj;
>       return ic != null && val.equals(ic.val);
>    }
>    
>    public int compareTo(Constant c) {
>       IntConstant ic = (IntConstant) c;
>       return val.compareTo(ic.val);
>    }
>    
>    public int hashCode() {
>       return val.hashCode();
>    }
>    
>    public String toString() {
>       return val.toString();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Plan.java ../cs4432-proj2/src/simpledb/query/Plan.java
1,47c1,47
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /**
<  * The interface implemented by each query plan.
<  * There is a Plan class for each relational algebra operator.
<  * @author Edward Sciore
<  *
<  */
< public interface Plan {
<    
<    /**
<     * Opens a scan corresponding to this plan.
<     * The scan will be positioned before its first record.
<     * @return a scan
<     */
<    public Scan   open();
<    
<    /**
<     * Returns an estimate of the number of block accesses
<     * that will occur when the scan is read to completion.
<     * @return the estimated number of block accesses
<     */
<    public int    blocksAccessed();
<    
<    /**
<     * Returns an estimate of the number of records
<     * in the query's output table.
<     * @return the estimated number of output records
<     */
<    public int    recordsOutput();
<    
<    /**
<     * Returns an estimate of the number of distinct values
<     * for the specified field in the query's output table.
<     * @param fldname the name of a field
<     * @return the estimated number of distinct field values in the output
<     */
<    public int    distinctValues(String fldname);
<    
<    /**
<     * Returns the schema of the query.
<     * @return the query's schema
<     */
<    public Schema schema();
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /**
>  * The interface implemented by each query plan.
>  * There is a Plan class for each relational algebra operator.
>  * @author Edward Sciore
>  *
>  */
> public interface Plan {
>    
>    /**
>     * Opens a scan corresponding to this plan.
>     * The scan will be positioned before its first record.
>     * @return a scan
>     */
>    public Scan   open();
>    
>    /**
>     * Returns an estimate of the number of block accesses
>     * that will occur when the scan is read to completion.
>     * @return the estimated number of block accesses
>     */
>    public int    blocksAccessed();
>    
>    /**
>     * Returns an estimate of the number of records
>     * in the query's output table.
>     * @return the estimated number of output records
>     */
>    public int    recordsOutput();
>    
>    /**
>     * Returns an estimate of the number of distinct values
>     * for the specified field in the query's output table.
>     * @param fldname the name of a field
>     * @return the estimated number of distinct field values in the output
>     */
>    public int    distinctValues(String fldname);
>    
>    /**
>     * Returns the schema of the query.
>     * @return the query's schema
>     */
>    public Schema schema();
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Predicate.java ../cs4432-proj2/src/simpledb/query/Predicate.java
1,146c1,146
< package simpledb.query;
< 
< import simpledb.record.Schema;
< import java.util.*;
< /**
<  * A predicate is a Boolean combination of terms.
<  * @author Edward Sciore
<  *
<  */
< public class Predicate {
<    private List<Term> terms = new ArrayList<Term>();
<    
<    /**
<     * Creates an empty predicate, corresponding to "true".
<     */
<    public Predicate() {}
<    
<    /**
<     * Creates a predicate containing a single term.
<     * @param t the term
<     */
<    public Predicate(Term t) {
<       terms.add(t);
<    }
<    
<    /**
<     * Modifies the predicate to be the conjunction of
<     * itself and the specified predicate.
<     * @param pred the other predicate
<     */
<    public void conjoinWith(Predicate pred) {
<       terms.addAll(pred.terms);
<    }
<    
<    /**
<     * Returns true if the predicate evaluates to true
<     * with respect to the specified scan.
<     * @param s the scan
<     * @return true if the predicate is true in the scan
<     */
<    public boolean isSatisfied(Scan s) {
<       for (Term t : terms)
<          if (!t.isSatisfied(s))
<          return false;
<       return true;
<    }
<    
<    /** 
<     * Calculates the extent to which selecting on the predicate 
<     * reduces the number of records output by a query.
<     * For example if the reduction factor is 2, then the
<     * predicate cuts the size of the output in half.
<     * @param p the query's plan
<     * @return the integer reduction factor.
<     */ 
<    public int reductionFactor(Plan p) {
<       int factor = 1;
<       for (Term t : terms)
<          factor *= t.reductionFactor(p);
<       return factor;
<    }
<    
<    /**
<     * Returns the subpredicate that applies to the specified schema.
<     * @param sch the schema
<     * @return the subpredicate applying to the schema
<     */
<    public Predicate selectPred(Schema sch) {
<       Predicate result = new Predicate();
<       for (Term t : terms)
<          if (t.appliesTo(sch))
<          result.terms.add(t);
<       if (result.terms.size() == 0)
<          return null;
<       else
<          return result;
<    }
<    
<    /**
<     * Returns the subpredicate consisting of terms that apply
<     * to the union of the two specified schemas, 
<     * but not to either schema separately.
<     * @param sch1 the first schema
<     * @param sch2 the second schema
<     * @return the subpredicate whose terms apply to the union of the two schemas but not either schema separately.
<     */
<    public Predicate joinPred(Schema sch1, Schema sch2) {
<       Predicate result = new Predicate();
<       Schema newsch = new Schema();
<       newsch.addAll(sch1);
<       newsch.addAll(sch2);
<       for (Term t : terms)
<          if (!t.appliesTo(sch1)  &&
<              !t.appliesTo(sch2) &&
<              t.appliesTo(newsch))
<          result.terms.add(t);
<       if (result.terms.size() == 0)
<          return null;
<       else
<          return result;
<    }
<    
<    /**
<     * Determines if there is a term of the form "F=c"
<     * where F is the specified field and c is some constant.
<     * If so, the method returns that constant.
<     * If not, the method returns null.
<     * @param fldname the name of the field
<     * @return either the constant or null
<     */
<    public Constant equatesWithConstant(String fldname) {
<       for (Term t : terms) {
<          Constant c = t.equatesWithConstant(fldname);
<          if (c != null)
<             return c;
<       }
<       return null;
<    }
<    
<    /**
<     * Determines if there is a term of the form "F1=F2"
<     * where F1 is the specified field and F2 is another field.
<     * If so, the method returns the name of that field.
<     * If not, the method returns null.
<     * @param fldname the name of the field
<     * @return the name of the other field, or null
<     */
<    public String equatesWithField(String fldname) {
<       for (Term t : terms) {
<          String s = t.equatesWithField(fldname);
<          if (s != null)
<             return s;
<       }
<       return null;
<    }
<    
<    public String toString() {
<       Iterator<Term> iter = terms.iterator();
<       if (!iter.hasNext()) 
<          return "";
<       String result = iter.next().toString();
<       while (iter.hasNext())
<          result += " and " + iter.next().toString();
<       return result;
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> import java.util.*;
> /**
>  * A predicate is a Boolean combination of terms.
>  * @author Edward Sciore
>  *
>  */
> public class Predicate {
>    private List<Term> terms = new ArrayList<Term>();
>    
>    /**
>     * Creates an empty predicate, corresponding to "true".
>     */
>    public Predicate() {}
>    
>    /**
>     * Creates a predicate containing a single term.
>     * @param t the term
>     */
>    public Predicate(Term t) {
>       terms.add(t);
>    }
>    
>    /**
>     * Modifies the predicate to be the conjunction of
>     * itself and the specified predicate.
>     * @param pred the other predicate
>     */
>    public void conjoinWith(Predicate pred) {
>       terms.addAll(pred.terms);
>    }
>    
>    /**
>     * Returns true if the predicate evaluates to true
>     * with respect to the specified scan.
>     * @param s the scan
>     * @return true if the predicate is true in the scan
>     */
>    public boolean isSatisfied(Scan s) {
>       for (Term t : terms)
>          if (!t.isSatisfied(s))
>          return false;
>       return true;
>    }
>    
>    /** 
>     * Calculates the extent to which selecting on the predicate 
>     * reduces the number of records output by a query.
>     * For example if the reduction factor is 2, then the
>     * predicate cuts the size of the output in half.
>     * @param p the query's plan
>     * @return the integer reduction factor.
>     */ 
>    public int reductionFactor(Plan p) {
>       int factor = 1;
>       for (Term t : terms)
>          factor *= t.reductionFactor(p);
>       return factor;
>    }
>    
>    /**
>     * Returns the subpredicate that applies to the specified schema.
>     * @param sch the schema
>     * @return the subpredicate applying to the schema
>     */
>    public Predicate selectPred(Schema sch) {
>       Predicate result = new Predicate();
>       for (Term t : terms)
>          if (t.appliesTo(sch))
>          result.terms.add(t);
>       if (result.terms.size() == 0)
>          return null;
>       else
>          return result;
>    }
>    
>    /**
>     * Returns the subpredicate consisting of terms that apply
>     * to the union of the two specified schemas, 
>     * but not to either schema separately.
>     * @param sch1 the first schema
>     * @param sch2 the second schema
>     * @return the subpredicate whose terms apply to the union of the two schemas but not either schema separately.
>     */
>    public Predicate joinPred(Schema sch1, Schema sch2) {
>       Predicate result = new Predicate();
>       Schema newsch = new Schema();
>       newsch.addAll(sch1);
>       newsch.addAll(sch2);
>       for (Term t : terms)
>          if (!t.appliesTo(sch1)  &&
>              !t.appliesTo(sch2) &&
>              t.appliesTo(newsch))
>          result.terms.add(t);
>       if (result.terms.size() == 0)
>          return null;
>       else
>          return result;
>    }
>    
>    /**
>     * Determines if there is a term of the form "F=c"
>     * where F is the specified field and c is some constant.
>     * If so, the method returns that constant.
>     * If not, the method returns null.
>     * @param fldname the name of the field
>     * @return either the constant or null
>     */
>    public Constant equatesWithConstant(String fldname) {
>       for (Term t : terms) {
>          Constant c = t.equatesWithConstant(fldname);
>          if (c != null)
>             return c;
>       }
>       return null;
>    }
>    
>    /**
>     * Determines if there is a term of the form "F1=F2"
>     * where F1 is the specified field and F2 is another field.
>     * If so, the method returns the name of that field.
>     * If not, the method returns null.
>     * @param fldname the name of the field
>     * @return the name of the other field, or null
>     */
>    public String equatesWithField(String fldname) {
>       for (Term t : terms) {
>          String s = t.equatesWithField(fldname);
>          if (s != null)
>             return s;
>       }
>       return null;
>    }
>    
>    public String toString() {
>       Iterator<Term> iter = terms.iterator();
>       if (!iter.hasNext()) 
>          return "";
>       String result = iter.next().toString();
>       while (iter.hasNext())
>          result += " and " + iter.next().toString();
>       return result;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/ProductPlan.java ../cs4432-proj2/src/simpledb/query/ProductPlan.java
1,77c1,77
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /** The Plan class corresponding to the <i>product</i>
<   * relational algebra operator.
<   * @author Edward Sciore
<   */
< public class ProductPlan implements Plan {
<    private Plan p1, p2;
<    private Schema schema = new Schema();
<    
<    /**
<     * Creates a new product node in the query tree,
<     * having the two specified subqueries.
<     * @param p1 the left-hand subquery
<     * @param p2 the right-hand subquery
<     */
<    public ProductPlan(Plan p1, Plan p2) {
<       this.p1 = p1;
<       this.p2 = p2;
<       schema.addAll(p1.schema());
<       schema.addAll(p2.schema());
<    }
<    
<    /**
<     * Creates a product scan for this query.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Scan s1 = p1.open();
<       Scan s2 = p2.open();
<       return new ProductScan(s1, s2);
<    }
<    
<    /**
<     * Estimates the number of block accesses in the product.
<     * The formula is:
<     * <pre> B(product(p1,p2)) = B(p1) + R(p1)*B(p2) </pre>
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return p1.blocksAccessed() + (p1.recordsOutput() * p2.blocksAccessed());
<    }
<    
<    /**
<     * Estimates the number of output records in the product.
<     * The formula is:
<     * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return p1.recordsOutput() * p2.recordsOutput();
<    }
<    
<    /**
<     * Estimates the distinct number of field values in the product.
<     * Since the product does not increase or decrease field values,
<     * the estimate is the same as in the appropriate underlying query.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       if (p1.schema().hasField(fldname))
<          return p1.distinctValues(fldname);
<       else
<          return p2.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the product,
<     * which is the union of the schemas of the underlying queries.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return schema;
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /** The Plan class corresponding to the <i>product</i>
>   * relational algebra operator.
>   * @author Edward Sciore
>   */
> public class ProductPlan implements Plan {
>    private Plan p1, p2;
>    private Schema schema = new Schema();
>    
>    /**
>     * Creates a new product node in the query tree,
>     * having the two specified subqueries.
>     * @param p1 the left-hand subquery
>     * @param p2 the right-hand subquery
>     */
>    public ProductPlan(Plan p1, Plan p2) {
>       this.p1 = p1;
>       this.p2 = p2;
>       schema.addAll(p1.schema());
>       schema.addAll(p2.schema());
>    }
>    
>    /**
>     * Creates a product scan for this query.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Scan s1 = p1.open();
>       Scan s2 = p2.open();
>       return new ProductScan(s1, s2);
>    }
>    
>    /**
>     * Estimates the number of block accesses in the product.
>     * The formula is:
>     * <pre> B(product(p1,p2)) = B(p1) + R(p1)*B(p2) </pre>
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return p1.blocksAccessed() + (p1.recordsOutput() * p2.blocksAccessed());
>    }
>    
>    /**
>     * Estimates the number of output records in the product.
>     * The formula is:
>     * <pre> R(product(p1,p2)) = R(p1)*R(p2) </pre>
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return p1.recordsOutput() * p2.recordsOutput();
>    }
>    
>    /**
>     * Estimates the distinct number of field values in the product.
>     * Since the product does not increase or decrease field values,
>     * the estimate is the same as in the appropriate underlying query.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       if (p1.schema().hasField(fldname))
>          return p1.distinctValues(fldname);
>       else
>          return p2.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the product,
>     * which is the union of the schemas of the underlying queries.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return schema;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/ProductScan.java ../cs4432-proj2/src/simpledb/query/ProductScan.java
1,108c1,108
< package simpledb.query;
< 
< /**
<  * The scan class corresponding to the <i>product</i> relational
<  * algebra operator.
<  * @author Edward Sciore
<  */
< public class ProductScan implements Scan {
<    private Scan s1, s2;
<    
<    /**
<     * Creates a product scan having the two underlying scans.
<     * @param s1 the LHS scan
<     * @param s2 the RHS scan
<     */
<    public ProductScan(Scan s1, Scan s2) {
<       this.s1 = s1;
<       this.s2 = s2;
<       s1.next();
<    }
<    
<    /**
<     * Positions the scan before its first record.
<     * In other words, the LHS scan is positioned at 
<     * its first record, and the RHS scan
<     * is positioned before its first record.
<     * @see simpledb.query.Scan#beforeFirst()
<     */
<    public void beforeFirst() {
<       s1.beforeFirst();
<       s1.next();
<       s2.beforeFirst();
<    }
<    
<    /**
<     * Moves the scan to the next record.
<     * The method moves to the next RHS record, if possible.
<     * Otherwise, it moves to the next LHS record and the
<     * first RHS record.
<     * If there are no more LHS records, the method returns false.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       if (s2.next())
<          return true;
<       else {
<          s2.beforeFirst();
<          return s2.next() && s1.next();
<       }
<    }
<    
<    /**
<     * Closes both underlying scans.
<     * @see simpledb.query.Scan#close()
<     */
<    public void close() {
<       s1.close();
<       s2.close();
<    }
<    
<    /** 
<     * Returns the value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getVal(fldname);
<       else
<          return s2.getVal(fldname);
<    }
<    
<    /** 
<     * Returns the integer value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getInt(fldname);
<       else
<          return s2.getInt(fldname);
<    }
<    
<    /** 
<     * Returns the string value of the specified field.
<     * The value is obtained from whichever scan
<     * contains the field.
<     * @see simpledb.query.Scan#getString(java.lang.String)
<     */
<    public String getString(String fldname) {
<       if (s1.hasField(fldname))
<          return s1.getString(fldname);
<       else
<          return s2.getString(fldname);
<    }
<    
<    /**
<     * Returns true if the specified field is in
<     * either of the underlying scans.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return s1.hasField(fldname) || s2.hasField(fldname);
<    }
< }
---
> package simpledb.query;
> 
> /**
>  * The scan class corresponding to the <i>product</i> relational
>  * algebra operator.
>  * @author Edward Sciore
>  */
> public class ProductScan implements Scan {
>    private Scan s1, s2;
>    
>    /**
>     * Creates a product scan having the two underlying scans.
>     * @param s1 the LHS scan
>     * @param s2 the RHS scan
>     */
>    public ProductScan(Scan s1, Scan s2) {
>       this.s1 = s1;
>       this.s2 = s2;
>       s1.next();
>    }
>    
>    /**
>     * Positions the scan before its first record.
>     * In other words, the LHS scan is positioned at 
>     * its first record, and the RHS scan
>     * is positioned before its first record.
>     * @see simpledb.query.Scan#beforeFirst()
>     */
>    public void beforeFirst() {
>       s1.beforeFirst();
>       s1.next();
>       s2.beforeFirst();
>    }
>    
>    /**
>     * Moves the scan to the next record.
>     * The method moves to the next RHS record, if possible.
>     * Otherwise, it moves to the next LHS record and the
>     * first RHS record.
>     * If there are no more LHS records, the method returns false.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       if (s2.next())
>          return true;
>       else {
>          s2.beforeFirst();
>          return s2.next() && s1.next();
>       }
>    }
>    
>    /**
>     * Closes both underlying scans.
>     * @see simpledb.query.Scan#close()
>     */
>    public void close() {
>       s1.close();
>       s2.close();
>    }
>    
>    /** 
>     * Returns the value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getVal(fldname);
>       else
>          return s2.getVal(fldname);
>    }
>    
>    /** 
>     * Returns the integer value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getInt(java.lang.String)
>     */
>    public int getInt(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getInt(fldname);
>       else
>          return s2.getInt(fldname);
>    }
>    
>    /** 
>     * Returns the string value of the specified field.
>     * The value is obtained from whichever scan
>     * contains the field.
>     * @see simpledb.query.Scan#getString(java.lang.String)
>     */
>    public String getString(String fldname) {
>       if (s1.hasField(fldname))
>          return s1.getString(fldname);
>       else
>          return s2.getString(fldname);
>    }
>    
>    /**
>     * Returns true if the specified field is in
>     * either of the underlying scans.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       return s1.hasField(fldname) || s2.hasField(fldname);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/ProjectPlan.java ../cs4432-proj2/src/simpledb/query/ProjectPlan.java
1,71c1,71
< package simpledb.query;
< 
< import simpledb.record.Schema;
< import java.util.Collection;
< 
< /** The Plan class corresponding to the <i>project</i>
<   * relational algebra operator.
<   * @author Edward Sciore
<   */
< public class ProjectPlan implements Plan {
<    private Plan p;
<    private Schema schema = new Schema();
<    
<    /**
<     * Creates a new project node in the query tree,
<     * having the specified subquery and field list.
<     * @param p the subquery
<     * @param fieldlist the list of fields
<     */
<    public ProjectPlan(Plan p, Collection<String> fieldlist) {
<       this.p = p;
<       for (String fldname : fieldlist)
<          schema.add(fldname, p.schema());
<    }
<    
<    /**
<     * Creates a project scan for this query.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       Scan s = p.open();
<       return new ProjectScan(s, schema.fields());
<    }
<    
<    /**
<     * Estimates the number of block accesses in the projection,
<     * which is the same as in the underlying query.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */
<    public int blocksAccessed() {
<       return p.blocksAccessed();
<    }
<    
<    /**
<     * Estimates the number of output records in the projection,
<     * which is the same as in the underlying query.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return p.recordsOutput();
<    }
<    
<    /**
<     * Estimates the number of distinct field values
<     * in the projection,
<     * which is the same as in the underlying query.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       return p.distinctValues(fldname);
<    }
<    
<    /**
<     * Returns the schema of the projection,
<     * which is taken from the field list.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return schema;
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> import java.util.Collection;
> 
> /** The Plan class corresponding to the <i>project</i>
>   * relational algebra operator.
>   * @author Edward Sciore
>   */
> public class ProjectPlan implements Plan {
>    private Plan p;
>    private Schema schema = new Schema();
>    
>    /**
>     * Creates a new project node in the query tree,
>     * having the specified subquery and field list.
>     * @param p the subquery
>     * @param fieldlist the list of fields
>     */
>    public ProjectPlan(Plan p, Collection<String> fieldlist) {
>       this.p = p;
>       for (String fldname : fieldlist)
>          schema.add(fldname, p.schema());
>    }
>    
>    /**
>     * Creates a project scan for this query.
>     * @see simpledb.query.Plan#open()
>     */
>    public Scan open() {
>       Scan s = p.open();
>       return new ProjectScan(s, schema.fields());
>    }
>    
>    /**
>     * Estimates the number of block accesses in the projection,
>     * which is the same as in the underlying query.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */
>    public int blocksAccessed() {
>       return p.blocksAccessed();
>    }
>    
>    /**
>     * Estimates the number of output records in the projection,
>     * which is the same as in the underlying query.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return p.recordsOutput();
>    }
>    
>    /**
>     * Estimates the number of distinct field values
>     * in the projection,
>     * which is the same as in the underlying query.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       return p.distinctValues(fldname);
>    }
>    
>    /**
>     * Returns the schema of the projection,
>     * which is taken from the field list.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return schema;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/ProjectScan.java ../cs4432-proj2/src/simpledb/query/ProjectScan.java
1,68c1,68
< package simpledb.query;
< 
< import java.util.*;
< 
< /**
<  * The scan class corresponding to the <i>project</i> relational
<  * algebra operator.
<  * All methods except hasField delegate their work to the
<  * underlying scan.
<  * @author Edward Sciore
<  */
< public class ProjectScan implements Scan {
<    private Scan s;
<    private Collection<String> fieldlist;
<    
<    /**
<     * Creates a project scan having the specified
<     * underlying scan and field list.
<     * @param s the underlying scan
<     * @param fieldlist the list of field names
<     */
<    public ProjectScan(Scan s, Collection<String> fieldlist) {
<       this.s = s;
<       this.fieldlist = fieldlist;
<    }
<    
<    public void beforeFirst() {
<       s.beforeFirst();
<    }
<    
<    public boolean next() {
<       return s.next();
<    }
<    
<    public void close() {
<       s.close();
<    }
<    
<    public Constant getVal(String fldname) {
<       if (hasField(fldname))
<          return s.getVal(fldname);
<       else
<          throw new RuntimeException("field " + fldname + " not found.");
<    }
<    
<    public int getInt(String fldname) {
<       if (hasField(fldname))
<          return s.getInt(fldname);
<       else
<          throw new RuntimeException("field " + fldname + " not found.");
<    }
<    
<    public String getString(String fldname) {
<       if (hasField(fldname))
<          return s.getString(fldname);
<       else
<          throw new RuntimeException("field " + fldname + " not found.");
<    }
<    
<    /**
<     * Returns true if the specified field
<     * is in the projection list.
<     * @see simpledb.query.Scan#hasField(java.lang.String)
<     */
<    public boolean hasField(String fldname) {
<       return fieldlist.contains(fldname);
<    }
< }
---
> package simpledb.query;
> 
> import java.util.*;
> 
> /**
>  * The scan class corresponding to the <i>project</i> relational
>  * algebra operator.
>  * All methods except hasField delegate their work to the
>  * underlying scan.
>  * @author Edward Sciore
>  */
> public class ProjectScan implements Scan {
>    private Scan s;
>    private Collection<String> fieldlist;
>    
>    /**
>     * Creates a project scan having the specified
>     * underlying scan and field list.
>     * @param s the underlying scan
>     * @param fieldlist the list of field names
>     */
>    public ProjectScan(Scan s, Collection<String> fieldlist) {
>       this.s = s;
>       this.fieldlist = fieldlist;
>    }
>    
>    public void beforeFirst() {
>       s.beforeFirst();
>    }
>    
>    public boolean next() {
>       return s.next();
>    }
>    
>    public void close() {
>       s.close();
>    }
>    
>    public Constant getVal(String fldname) {
>       if (hasField(fldname))
>          return s.getVal(fldname);
>       else
>          throw new RuntimeException("field " + fldname + " not found.");
>    }
>    
>    public int getInt(String fldname) {
>       if (hasField(fldname))
>          return s.getInt(fldname);
>       else
>          throw new RuntimeException("field " + fldname + " not found.");
>    }
>    
>    public String getString(String fldname) {
>       if (hasField(fldname))
>          return s.getString(fldname);
>       else
>          throw new RuntimeException("field " + fldname + " not found.");
>    }
>    
>    /**
>     * Returns true if the specified field
>     * is in the projection list.
>     * @see simpledb.query.Scan#hasField(java.lang.String)
>     */
>    public boolean hasField(String fldname) {
>       return fieldlist.contains(fldname);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Scan.java ../cs4432-proj2/src/simpledb/query/Scan.java
1,57c1,57
< package simpledb.query;
< 
< /**
<  * The interface will be implemented by each query scan.
<  * There is a Scan class for each relational
<  * algebra operator.
<  * @author Edward Sciore
<  */
< public interface Scan {
<    
<    /**
<     * Positions the scan before its first record.
<     */
<    public void     beforeFirst();
<    
<    /**
<     * Moves the scan to the next record.
<     * @return false if there is no next record
<     */
<    public boolean  next();
<    
<    /**
<     * Closes the scan and its subscans, if any. 
<     */
<    public void     close();
<    
<    /**
<     * Returns the value of the specified field in the current record.
<     * The value is expressed as a Constant.
<     * @param fldname the name of the field
<     * @return the value of that field, expressed as a Constant.
<     */
<    public Constant getVal(String fldname);
<    
<    /**
<     * Returns the value of the specified integer field 
<     * in the current record.
<     * @param fldname the name of the field
<     * @return the field's integer value in the current record
<     */
<    public int      getInt(String fldname);
<    
<    /**
<     * Returns the value of the specified string field 
<     * in the current record.
<     * @param fldname the name of the field
<     * @return the field's string value in the current record
<     */
<    public String   getString(String fldname);
<    
<    /**
<     * Returns true if the scan has the specified field.
<     * @param fldname the name of the field
<     * @return true if the scan has that field
<     */
<    public boolean  hasField(String fldname);
< }
---
> package simpledb.query;
> 
> /**
>  * The interface will be implemented by each query scan.
>  * There is a Scan class for each relational
>  * algebra operator.
>  * @author Edward Sciore
>  */
> public interface Scan {
>    
>    /**
>     * Positions the scan before its first record.
>     */
>    public void     beforeFirst();
>    
>    /**
>     * Moves the scan to the next record.
>     * @return false if there is no next record
>     */
>    public boolean  next();
>    
>    /**
>     * Closes the scan and its subscans, if any. 
>     */
>    public void     close();
>    
>    /**
>     * Returns the value of the specified field in the current record.
>     * The value is expressed as a Constant.
>     * @param fldname the name of the field
>     * @return the value of that field, expressed as a Constant.
>     */
>    public Constant getVal(String fldname);
>    
>    /**
>     * Returns the value of the specified integer field 
>     * in the current record.
>     * @param fldname the name of the field
>     * @return the field's integer value in the current record
>     */
>    public int      getInt(String fldname);
>    
>    /**
>     * Returns the value of the specified string field 
>     * in the current record.
>     * @param fldname the name of the field
>     * @return the field's string value in the current record
>     */
>    public String   getString(String fldname);
>    
>    /**
>     * Returns true if the scan has the specified field.
>     * @param fldname the name of the field
>     * @return true if the scan has that field
>     */
>    public boolean  hasField(String fldname);
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/SelectScan.java ../cs4432-proj2/src/simpledb/query/SelectScan.java
1,103c1,103
< package simpledb.query;
< 
< import simpledb.record.*;
< 
< /**
<  * The scan class corresponding to the <i>select</i> relational
<  * algebra operator.
<  * All methods except next delegate their work to the
<  * underlying scan.
<  * @author Edward Sciore
<  */
< public class SelectScan implements UpdateScan {
<    private Scan s;
<    private Predicate pred;
<    
<    /**
<     * Creates a select scan having the specified underlying
<     * scan and predicate.
<     * @param s the scan of the underlying query
<     * @param pred the selection predicate
<     */
<    public SelectScan(Scan s, Predicate pred) {
<       this.s = s;
<       this.pred = pred;
<    }
<    
<    // Scan methods
<    
<    public void beforeFirst() {
<       s.beforeFirst();
<    }
<    
<    /**
<     * Move to the next record satisfying the predicate.
<     * The method repeatedly calls next on the underlying scan
<     * until a suitable record is found, or the underlying scan
<     * contains no more records.
<     * @see simpledb.query.Scan#next()
<     */
<    public boolean next() {
<       while (s.next())
<          if (pred.isSatisfied(s))
<          return true;
<       return false;
<    }
<    
<    public void close() {
<       s.close();
<    }
<    
<    public Constant getVal(String fldname) {
<       return s.getVal(fldname);
<    }
<    
<    public int getInt(String fldname) {
<       return s.getInt(fldname);
<    }
<    
<    public String getString(String fldname) {
<       return s.getString(fldname);
<    }
<    
<    public boolean hasField(String fldname) {
<       return s.hasField(fldname);
<    }
<    
<    // UpdateScan methods
<    
<    public void setVal(String fldname, Constant val) {
<       UpdateScan us = (UpdateScan) s;
<       us.setVal(fldname, val);
<    }
<    
<    public void setInt(String fldname, int val) {
<       UpdateScan us = (UpdateScan) s;
<       us.setInt(fldname, val);
<    }
<    
<    public void setString(String fldname, String val) {
<       UpdateScan us = (UpdateScan) s;
<       us.setString(fldname, val);
<    }
<    
<    public void delete() {
<       UpdateScan us = (UpdateScan) s;
<       us.delete();
<    }
<    
<    public void insert() {
<       UpdateScan us = (UpdateScan) s;
<       us.insert();
<    }
<    
<    public RID getRid() {
<       UpdateScan us = (UpdateScan) s;
<       return us.getRid();
<    }
<    
<    public void moveToRid(RID rid) {
<       UpdateScan us = (UpdateScan) s;
<       us.moveToRid(rid);
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.*;
> 
> /**
>  * The scan class corresponding to the <i>select</i> relational
>  * algebra operator.
>  * All methods except next delegate their work to the
>  * underlying scan.
>  * @author Edward Sciore
>  */
> public class SelectScan implements UpdateScan {
>    private Scan s;
>    private Predicate pred;
>    
>    /**
>     * Creates a select scan having the specified underlying
>     * scan and predicate.
>     * @param s the scan of the underlying query
>     * @param pred the selection predicate
>     */
>    public SelectScan(Scan s, Predicate pred) {
>       this.s = s;
>       this.pred = pred;
>    }
>    
>    // Scan methods
>    
>    public void beforeFirst() {
>       s.beforeFirst();
>    }
>    
>    /**
>     * Move to the next record satisfying the predicate.
>     * The method repeatedly calls next on the underlying scan
>     * until a suitable record is found, or the underlying scan
>     * contains no more records.
>     * @see simpledb.query.Scan#next()
>     */
>    public boolean next() {
>       while (s.next())
>          if (pred.isSatisfied(s))
>          return true;
>       return false;
>    }
>    
>    public void close() {
>       s.close();
>    }
>    
>    public Constant getVal(String fldname) {
>       return s.getVal(fldname);
>    }
>    
>    public int getInt(String fldname) {
>       return s.getInt(fldname);
>    }
>    
>    public String getString(String fldname) {
>       return s.getString(fldname);
>    }
>    
>    public boolean hasField(String fldname) {
>       return s.hasField(fldname);
>    }
>    
>    // UpdateScan methods
>    
>    public void setVal(String fldname, Constant val) {
>       UpdateScan us = (UpdateScan) s;
>       us.setVal(fldname, val);
>    }
>    
>    public void setInt(String fldname, int val) {
>       UpdateScan us = (UpdateScan) s;
>       us.setInt(fldname, val);
>    }
>    
>    public void setString(String fldname, String val) {
>       UpdateScan us = (UpdateScan) s;
>       us.setString(fldname, val);
>    }
>    
>    public void delete() {
>       UpdateScan us = (UpdateScan) s;
>       us.delete();
>    }
>    
>    public void insert() {
>       UpdateScan us = (UpdateScan) s;
>       us.insert();
>    }
>    
>    public RID getRid() {
>       UpdateScan us = (UpdateScan) s;
>       return us.getRid();
>    }
>    
>    public void moveToRid(RID rid) {
>       UpdateScan us = (UpdateScan) s;
>       us.moveToRid(rid);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/StringConstant.java ../cs4432-proj2/src/simpledb/query/StringConstant.java
1,43c1,43
< package simpledb.query;
< 
< /**
<  * The class that wraps Java strings as database constants.
<  * @author Edward Sciore
<  */
< public class StringConstant implements Constant {
<    private String val;
<    
<    /**
<     * Create a constant by wrapping the specified string.
<     * @param s the string value
<     */
<    public StringConstant(String s) {
<       val = s;
<    }
<    
<    /**
<     * Unwraps the string and returns it.
<     * @see simpledb.query.Constant#asJavaVal()
<     */
<    public String asJavaVal() {
<       return val;
<    }
<    
<    public boolean equals(Object obj) {
<       StringConstant sc = (StringConstant) obj;
<       return sc != null && val.equals(sc.val);
<    }
<    
<    public int compareTo(Constant c) {
<       StringConstant sc = (StringConstant) c;
<       return val.compareTo(sc.val);
<    }
<    
<    public int hashCode() {
<       return val.hashCode();
<    }
<    
<    public String toString() {
<       return val;
<    }
< }
---
> package simpledb.query;
> 
> /**
>  * The class that wraps Java strings as database constants.
>  * @author Edward Sciore
>  */
> public class StringConstant implements Constant {
>    private String val;
>    
>    /**
>     * Create a constant by wrapping the specified string.
>     * @param s the string value
>     */
>    public StringConstant(String s) {
>       val = s;
>    }
>    
>    /**
>     * Unwraps the string and returns it.
>     * @see simpledb.query.Constant#asJavaVal()
>     */
>    public String asJavaVal() {
>       return val;
>    }
>    
>    public boolean equals(Object obj) {
>       StringConstant sc = (StringConstant) obj;
>       return sc != null && val.equals(sc.val);
>    }
>    
>    public int compareTo(Constant c) {
>       StringConstant sc = (StringConstant) c;
>       return val.compareTo(sc.val);
>    }
>    
>    public int hashCode() {
>       return val.hashCode();
>    }
>    
>    public String toString() {
>       return val;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/TablePlan.java ../cs4432-proj2/src/simpledb/query/TablePlan.java
1,71c1,82
< package simpledb.query;
< 
< import simpledb.server.SimpleDB;
< import simpledb.tx.Transaction;
< import simpledb.metadata.*;
< import simpledb.record.*;
< 
< /** The Plan class corresponding to a table.
<   * @author Edward Sciore
<   */
< public class TablePlan implements Plan {
<    private Transaction tx;
<    private TableInfo ti;
<    private StatInfo si;
<    
<    /**
<     * Creates a leaf node in the query tree corresponding
<     * to the specified table.
<     * @param tblname the name of the table
<     * @param tx the calling transaction
<     */
<    public TablePlan(String tblname, Transaction tx) {
<       this.tx = tx;
<       ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
<       si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
<    }
<    
<    /**
<     * Creates a table scan for this query.
<     * @see simpledb.query.Plan#open()
<     */
<    public Scan open() {
<       return new TableScan(ti, tx);
<    }
<    
<    /**
<     * Estimates the number of block accesses for the table,
<     * which is obtainable from the statistics manager.
<     * @see simpledb.query.Plan#blocksAccessed()
<     */ 
<    public int blocksAccessed() {
<       return si.blocksAccessed();
<    }
<    
<    /**
<     * Estimates the number of records in the table,
<     * which is obtainable from the statistics manager.
<     * @see simpledb.query.Plan#recordsOutput()
<     */
<    public int recordsOutput() {
<       return si.recordsOutput();
<    }
<    
<    /**
<     * Estimates the number of distinct field values in the table,
<     * which is obtainable from the statistics manager.
<     * @see simpledb.query.Plan#distinctValues(java.lang.String)
<     */
<    public int distinctValues(String fldname) {
<       return si.distinctValues(fldname);
<    }
<    
<    /**
<     * Determines the schema of the table,
<     * which is obtainable from the catalog manager.
<     * @see simpledb.query.Plan#schema()
<     */
<    public Schema schema() {
<       return ti.schema();
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.server.SimpleDB;
> import simpledb.tx.Transaction;
> import simpledb.metadata.*;
> import simpledb.query.*;
> import simpledb.record.*;
> 
> /** The Plan class corresponding to a table.
>   * @author Edward Sciore
>   */
> public class TablePlan implements Plan {
>    private Transaction tx;
>    private TableInfo ti;
>    private StatInfo si;
>    
>    /**
>     * Creates a leaf node in the query tree corresponding
>     * to the specified table.
>     * @param tblname the name of the table
>     * @param tx the calling transaction
>     */
>    public TablePlan(String tblname, Transaction tx) {
>       this.tx = tx;
>       ti = SimpleDB.mdMgr().getTableInfo(tblname, tx);
>       si = SimpleDB.mdMgr().getStatInfo(tblname, ti, tx);
>    }
>    
>     /**
>      * Creates a table scan for this query.
>      * @see simpledb.query.Plan#open()
>      */
>     public Scan open() {
>         return new TableScan(ti, tx);
>     }
>    
>    /**
>     * Estimates the number of block accesses for the table,
>     * which is obtainable from the statistics manager.
>     * @see simpledb.query.Plan#blocksAccessed()
>     */ 
>    public int blocksAccessed() {
>       return si.blocksAccessed();
>    }
>    
>    /**
>     * Estimates the number of records in the table,
>     * which is obtainable from the statistics manager.
>     * @see simpledb.query.Plan#recordsOutput()
>     */
>    public int recordsOutput() {
>       return si.recordsOutput();
>    }
>    
>    /**
>     * Estimates the number of distinct field values in the table,
>     * which is obtainable from the statistics manager.
>     * @see simpledb.query.Plan#distinctValues(java.lang.String)
>     */
>    public int distinctValues(String fldname) {
>       return si.distinctValues(fldname);
>    }
>    
>    /**
>     * Determines the schema of the table,
>     * which is obtainable from the catalog manager.
>     * @see simpledb.query.Plan#schema()
>     */
>    public Schema schema() {
>       return ti.schema();
>    }
> 
>     /**
>      * CS 4432 Project 2
>      * 
>      * @return The tableinfo of this table
>      */
>     public TableInfo getTableInfo() {
>         return ti;
>     }
> 
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/TableScan.java ../cs4432-proj2/src/simpledb/query/TableScan.java
1,109c1,109
< package simpledb.query;
< 
< import static java.sql.Types.INTEGER;
< import simpledb.tx.Transaction;
< import simpledb.record.*;
< 
< /**
<  * The Scan class corresponding to a table.
<  * A table scan is just a wrapper for a RecordFile object;
<  * most methods just delegate to the corresponding
<  * RecordFile methods.
<  * @author Edward Sciore
<  *
<  */
< public class TableScan implements UpdateScan {
<    private RecordFile rf;
<    private Schema sch;
<    
<    /**
<     * Creates a new table scan,
<     * and opens its corresponding record file. 
<     * @param ti the table's metadata
<     * @param tx the calling transaction
<     */
<    public TableScan(TableInfo ti, Transaction tx) {
<       rf  = new RecordFile(ti, tx);
<       sch = ti.schema();
<    }
<    
<    // Scan methods
<    
<    public void beforeFirst() {
<       rf.beforeFirst();
<    }
<    
<    public boolean next() {
<       return rf.next();
<    }
<    
<    public void close() {
<       rf.close();
<    }
<    
<    /**
<     * Returns the value of the specified field, as a Constant.
<     * The schema is examined to determine the field's type.
<     * If INTEGER, then the record file's getInt method is called;
<     * otherwise, the getString method is called.
<     * @see simpledb.query.Scan#getVal(java.lang.String)
<     */
<    public Constant getVal(String fldname) {
<       if (sch.type(fldname) == INTEGER)
<          return new IntConstant(rf.getInt(fldname));
<       else
<          return new StringConstant(rf.getString(fldname));
<    }
<    
<    public int getInt(String fldname) {
<       return rf.getInt(fldname);
<    }
<    
<    public String getString(String fldname) {
<       return rf.getString(fldname);
<    }
<    
<    public boolean hasField(String fldname) {
<       return sch.hasField(fldname);
<    }
<    
<    // UpdateScan methods
<    
<    /**
<     * Sets the value of the specified field, as a Constant.
<     * The schema is examined to determine the field's type.
<     * If INTEGER, then the record file's setInt method is called;
<     * otherwise, the setString method is called.
<     * @see simpledb.query.UpdateScan#setVal(java.lang.String, simpledb.query.Constant)
<     */ 
<    public void setVal(String fldname, Constant val) {
<       if (sch.type(fldname) == INTEGER)
<          rf.setInt(fldname, (Integer)val.asJavaVal());
<       else
<          rf.setString(fldname, (String)val.asJavaVal());
<    }
<    
<    public void setInt(String fldname, int val) {
<       rf.setInt(fldname, val);
<    }
<    
<    public void setString(String fldname, String val) {
<       rf.setString(fldname, val);
<    }
<    
<    public void delete() {
<       rf.delete();
<    }
<    
<    public void insert() {
<       rf.insert();
<    }
<    
<    public RID getRid() {
<       return rf.currentRid();
<    }
<    
<    public void moveToRid(RID rid) {
<       rf.moveToRid(rid);
<    }
< }
---
> package simpledb.query;
> 
> import static java.sql.Types.INTEGER;
> import simpledb.tx.Transaction;
> import simpledb.record.*;
> 
> /**
>  * The Scan class corresponding to a table.
>  * A table scan is just a wrapper for a RecordFile object;
>  * most methods just delegate to the corresponding
>  * RecordFile methods.
>  * @author Edward Sciore
>  *
>  */
> public class TableScan implements UpdateScan {
>     private RecordFile rf;
>     private Schema sch;
>    
>     /**
>      * Creates a new table scan,
>      * and opens its corresponding record file. 
>      * @param ti the table's metadata
>      * @param tx the calling transaction
>      */
>     public TableScan(TableInfo ti, Transaction tx) {
>         rf  = new RecordFile(ti, tx);
>         sch = ti.schema();
>     }
>    
>    // Scan methods
>    
>    public void beforeFirst() {
>       rf.beforeFirst();
>    }
>    
>    public boolean next() {
>       return rf.next();
>    }
>    
>    public void close() {
>       rf.close();
>    }
>    
>    /**
>     * Returns the value of the specified field, as a Constant.
>     * The schema is examined to determine the field's type.
>     * If INTEGER, then the record file's getInt method is called;
>     * otherwise, the getString method is called.
>     * @see simpledb.query.Scan#getVal(java.lang.String)
>     */
>    public Constant getVal(String fldname) {
>       if (sch.type(fldname) == INTEGER)
>          return new IntConstant(rf.getInt(fldname));
>       else
>          return new StringConstant(rf.getString(fldname));
>    }
>    
>    public int getInt(String fldname) {
>       return rf.getInt(fldname);
>    }
>    
>    public String getString(String fldname) {
>       return rf.getString(fldname);
>    }
>    
>    public boolean hasField(String fldname) {
>       return sch.hasField(fldname);
>    }
>    
>    // UpdateScan methods
>    
>    /**
>     * Sets the value of the specified field, as a Constant.
>     * The schema is examined to determine the field's type.
>     * If INTEGER, then the record file's setInt method is called;
>     * otherwise, the setString method is called.
>     * @see simpledb.query.UpdateScan#setVal(java.lang.String, simpledb.query.Constant)
>     */ 
>    public void setVal(String fldname, Constant val) {
>       if (sch.type(fldname) == INTEGER)
>          rf.setInt(fldname, (Integer)val.asJavaVal());
>       else
>          rf.setString(fldname, (String)val.asJavaVal());
>    }
>    
>    public void setInt(String fldname, int val) {
>       rf.setInt(fldname, val);
>    }
>    
>    public void setString(String fldname, String val) {
>       rf.setString(fldname, val);
>    }
>    
>    public void delete() {
>       rf.delete();
>    }
>    
>    public void insert() {
>       rf.insert();
>    }
>    
>    public RID getRid() {
>       return rf.currentRid();
>    }
>    
>    public void moveToRid(RID rid) {
>       rf.moveToRid(rid);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/Term.java ../cs4432-proj2/src/simpledb/query/Term.java
1,123c1,123
< package simpledb.query;
< 
< import simpledb.record.Schema;
< 
< /**
<  * A term is a comparison between two expressions.
<  * @author Edward Sciore
<  *
<  */
< public class Term {
<    private Expression lhs, rhs;
<    
<    /**
<     * Creates a new term that compares two expressions
<     * for equality.
<     * @param lhs  the LHS expression
<     * @param rhs  the RHS expression
<     */
<    public Term(Expression lhs, Expression rhs) {
<       this.lhs = lhs;
<       this.rhs = rhs;
<    }
<    
<    /**
<     * Calculates the extent to which selecting on the term reduces 
<     * the number of records output by a query.
<     * For example if the reduction factor is 2, then the
<     * term cuts the size of the output in half.
<     * @param p the query's plan
<     * @return the integer reduction factor.
<     */
<    public int reductionFactor(Plan p) {
<       String lhsName, rhsName;
<       if (lhs.isFieldName() && rhs.isFieldName()) {
<          lhsName = lhs.asFieldName();
<          rhsName = rhs.asFieldName();
<          return Math.max(p.distinctValues(lhsName),
<                          p.distinctValues(rhsName));
<       }
<       if (lhs.isFieldName()) {
<          lhsName = lhs.asFieldName();
<          return p.distinctValues(lhsName);
<       }
<       if (rhs.isFieldName()) {
<          rhsName = rhs.asFieldName();
<          return p.distinctValues(rhsName);
<       }
<       // otherwise, the term equates constants
<       if (lhs.asConstant().equals(rhs.asConstant()))
<          return 1;
<       else
<          return Integer.MAX_VALUE;
<    }
<    
<    /**
<     * Determines if this term is of the form "F=c"
<     * where F is the specified field and c is some constant.
<     * If so, the method returns that constant.
<     * If not, the method returns null.
<     * @param fldname the name of the field
<     * @return either the constant or null
<     */
<    public Constant equatesWithConstant(String fldname) {
<       if (lhs.isFieldName() &&
<           lhs.asFieldName().equals(fldname) &&
<           rhs.isConstant())
<          return rhs.asConstant();
<       else if (rhs.isFieldName() &&
<                rhs.asFieldName().equals(fldname) &&
<                lhs.isConstant())
<          return lhs.asConstant();
<       else
<          return null;
<    }
<    
<    /**
<     * Determines if this term is of the form "F1=F2"
<     * where F1 is the specified field and F2 is another field.
<     * If so, the method returns the name of that field.
<     * If not, the method returns null.
<     * @param fldname the name of the field
<     * @return either the name of the other field, or null
<     */
<    public String equatesWithField(String fldname) {
<       if (lhs.isFieldName() &&
<           lhs.asFieldName().equals(fldname) &&
<           rhs.isFieldName())
<          return rhs.asFieldName();
<       else if (rhs.isFieldName() &&
<                rhs.asFieldName().equals(fldname) &&
<                lhs.isFieldName())
<          return lhs.asFieldName();
<       else
<          return null;
<    }
<    
<    /**
<     * Returns true if both of the term's expressions
<     * apply to the specified schema.
<     * @param sch the schema
<     * @return true if both expressions apply to the schema
<     */
<    public boolean appliesTo(Schema sch) {
<       return lhs.appliesTo(sch) && rhs.appliesTo(sch);
<    }
<    
<    /**
<     * Returns true if both of the term's expressions
<     * evaluate to the same constant,
<     * with respect to the specified scan.
<     * @param s the scan
<     * @return true if both expressions have the same value in the scan
<     */
<    public boolean isSatisfied(Scan s) {
<       Constant lhsval = lhs.evaluate(s);
<       Constant rhsval = rhs.evaluate(s);
<       return rhsval.equals(lhsval);
<    }
<    
<    public String toString() {
<       return lhs.toString() + "=" + rhs.toString();
<    }
< }
---
> package simpledb.query;
> 
> import simpledb.record.Schema;
> 
> /**
>  * A term is a comparison between two expressions.
>  * @author Edward Sciore
>  *
>  */
> public class Term {
>    private Expression lhs, rhs;
>    
>    /**
>     * Creates a new term that compares two expressions
>     * for equality.
>     * @param lhs  the LHS expression
>     * @param rhs  the RHS expression
>     */
>    public Term(Expression lhs, Expression rhs) {
>       this.lhs = lhs;
>       this.rhs = rhs;
>    }
>    
>    /**
>     * Calculates the extent to which selecting on the term reduces 
>     * the number of records output by a query.
>     * For example if the reduction factor is 2, then the
>     * term cuts the size of the output in half.
>     * @param p the query's plan
>     * @return the integer reduction factor.
>     */
>    public int reductionFactor(Plan p) {
>       String lhsName, rhsName;
>       if (lhs.isFieldName() && rhs.isFieldName()) {
>          lhsName = lhs.asFieldName();
>          rhsName = rhs.asFieldName();
>          return Math.max(p.distinctValues(lhsName),
>                          p.distinctValues(rhsName));
>       }
>       if (lhs.isFieldName()) {
>          lhsName = lhs.asFieldName();
>          return p.distinctValues(lhsName);
>       }
>       if (rhs.isFieldName()) {
>          rhsName = rhs.asFieldName();
>          return p.distinctValues(rhsName);
>       }
>       // otherwise, the term equates constants
>       if (lhs.asConstant().equals(rhs.asConstant()))
>          return 1;
>       else
>          return Integer.MAX_VALUE;
>    }
>    
>    /**
>     * Determines if this term is of the form "F=c"
>     * where F is the specified field and c is some constant.
>     * If so, the method returns that constant.
>     * If not, the method returns null.
>     * @param fldname the name of the field
>     * @return either the constant or null
>     */
>    public Constant equatesWithConstant(String fldname) {
>       if (lhs.isFieldName() &&
>           lhs.asFieldName().equals(fldname) &&
>           rhs.isConstant())
>          return rhs.asConstant();
>       else if (rhs.isFieldName() &&
>                rhs.asFieldName().equals(fldname) &&
>                lhs.isConstant())
>          return lhs.asConstant();
>       else
>          return null;
>    }
>    
>    /**
>     * Determines if this term is of the form "F1=F2"
>     * where F1 is the specified field and F2 is another field.
>     * If so, the method returns the name of that field.
>     * If not, the method returns null.
>     * @param fldname the name of the field
>     * @return either the name of the other field, or null
>     */
>    public String equatesWithField(String fldname) {
>       if (lhs.isFieldName() &&
>           lhs.asFieldName().equals(fldname) &&
>           rhs.isFieldName())
>          return rhs.asFieldName();
>       else if (rhs.isFieldName() &&
>                rhs.asFieldName().equals(fldname) &&
>                lhs.isFieldName())
>          return lhs.asFieldName();
>       else
>          return null;
>    }
>    
>    /**
>     * Returns true if both of the term's expressions
>     * apply to the specified schema.
>     * @param sch the schema
>     * @return true if both expressions apply to the schema
>     */
>    public boolean appliesTo(Schema sch) {
>       return lhs.appliesTo(sch) && rhs.appliesTo(sch);
>    }
>    
>    /**
>     * Returns true if both of the term's expressions
>     * evaluate to the same constant,
>     * with respect to the specified scan.
>     * @param s the scan
>     * @return true if both expressions have the same value in the scan
>     */
>    public boolean isSatisfied(Scan s) {
>       Constant lhsval = lhs.evaluate(s);
>       Constant rhsval = rhs.evaluate(s);
>       return rhsval.equals(lhsval);
>    }
>    
>    public String toString() {
>       return lhs.toString() + "=" + rhs.toString();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/query/UpdateScan.java ../cs4432-proj2/src/simpledb/query/UpdateScan.java
1,53c1,53
< package simpledb.query;
< 
< import simpledb.record.RID;
< 
< /**
<  * The interface implemented by all updateable scans.
<  * @author Edward Sciore
<  */
< public interface UpdateScan extends Scan {
<    /**
<     * Modifies the field value of the current record.
<     * @param fldname the name of the field
<     * @param val the new value, expressed as a Constant
<     */
<    public void setVal(String fldname, Constant val);
<    
<    /**
<     * Modifies the field value of the current record.
<     * @param fldname the name of the field
<     * @param val the new integer value
<     */
<    public void setInt(String fldname, int val);
<    
<    /**
<     * Modifies the field value of the current record.
<     * @param fldname the name of the field
<     * @param val the new string value
<     */
<    public void setString(String fldname, String val);
<    
<    /**
<     * Inserts a new record somewhere in the scan.
<     */
<    public void insert();
<    
<    /**
<     * Deletes the current record from the scan.
<     */
<    public void delete();
<    
<    /**
<     * Returns the RID of the current record.
<     * @return the RID of the current record
<     */
<    public RID  getRid();
<    
<    /**
<     * Positions the scan so that the current record has
<     * the specified RID.
<     * @param rid the RID of the desired record
<     */
<    public void moveToRid(RID rid);
< }
---
> package simpledb.query;
> 
> import simpledb.record.RID;
> 
> /**
>  * The interface implemented by all updateable scans.
>  * @author Edward Sciore
>  */
> public interface UpdateScan extends Scan {
>    /**
>     * Modifies the field value of the current record.
>     * @param fldname the name of the field
>     * @param val the new value, expressed as a Constant
>     */
>    public void setVal(String fldname, Constant val);
>    
>    /**
>     * Modifies the field value of the current record.
>     * @param fldname the name of the field
>     * @param val the new integer value
>     */
>    public void setInt(String fldname, int val);
>    
>    /**
>     * Modifies the field value of the current record.
>     * @param fldname the name of the field
>     * @param val the new string value
>     */
>    public void setString(String fldname, String val);
>    
>    /**
>     * Inserts a new record somewhere in the scan.
>     */
>    public void insert();
>    
>    /**
>     * Deletes the current record from the scan.
>     */
>    public void delete();
>    
>    /**
>     * Returns the RID of the current record.
>     * @return the RID of the current record
>     */
>    public RID  getRid();
>    
>    /**
>     * Positions the scan so that the current record has
>     * the specified RID.
>     * @param rid the RID of the desired record
>     */
>    public void moveToRid(RID rid);
> }
diff -r simpledb/SimpleDB_2.10/simpledb/record/RID.java ../cs4432-proj2/src/simpledb/record/RID.java
1,48c1,48
< package simpledb.record;
< 
< /**
<  * An identifier for a record within a file.
<  * A RID consists of the block number in the file,
<  * and the ID of the record in that block.
<  * @author Edward Sciore
<  */
< public class RID {
< 	private int blknum;
< 	private int id;
< 
< 	/**
< 	 * Creates a RID for the record having the
< 	 * specified ID in the specified block.
< 	 * @param blknum the block number where the record lives
< 	 * @param id the record's ID
< 	 */
< 	public RID(int blknum, int id) {
< 		this.blknum = blknum;
< 		this.id     = id;
< 	}
< 
< 	/**
< 	 * Returns the block number associated with this RID.
< 	 * @return the block number
< 	 */
< 	public int blockNumber() {
< 		return blknum;
< 	}
< 
< 	/**
< 	 * Returns the ID associated with this RID.
< 	 * @return the ID
< 	 */
< 	public int id() {
< 		return id;
< 	}
< 
< 	public boolean equals(Object obj) {
< 		RID r = (RID) obj;
< 		return blknum == r.blknum && id==r.id;
< 	}
< 
< 	public String toString() {
< 		return "[" + blknum + ", " + id + "]";
< 	}
< }
---
> package simpledb.record;
> 
> /**
>  * An identifier for a record within a file.
>  * A RID consists of the block number in the file,
>  * and the ID of the record in that block.
>  * @author Edward Sciore
>  */
> public class RID {
> 	private int blknum;
> 	private int id;
> 
> 	/**
> 	 * Creates a RID for the record having the
> 	 * specified ID in the specified block.
> 	 * @param blknum the block number where the record lives
> 	 * @param id the record's ID
> 	 */
> 	public RID(int blknum, int id) {
> 		this.blknum = blknum;
> 		this.id     = id;
> 	}
> 
> 	/**
> 	 * Returns the block number associated with this RID.
> 	 * @return the block number
> 	 */
> 	public int blockNumber() {
> 		return blknum;
> 	}
> 
> 	/**
> 	 * Returns the ID associated with this RID.
> 	 * @return the ID
> 	 */
> 	public int id() {
> 		return id;
> 	}
> 
> 	public boolean equals(Object obj) {
> 		RID r = (RID) obj;
> 		return blknum == r.blknum && id==r.id;
> 	}
> 
> 	public String toString() {
> 		return "[" + blknum + ", " + id + "]";
> 	}
> }
diff -r simpledb/SimpleDB_2.10/simpledb/record/RecordFile.java ../cs4432-proj2/src/simpledb/record/RecordFile.java
1,163c1,164
< package simpledb.record;
< 
< import simpledb.file.Block;
< import simpledb.tx.Transaction;
< 
< /**
<  * Manages a file of records.
<  * There are methods for iterating through the records
<  * and accessing their contents.
<  * @author Edward Sciore
<  */
< public class RecordFile {
<    private TableInfo ti;
<    private Transaction tx;
<    private String filename;
<    private RecordPage rp;
<    private int currentblknum;
<    
<    /**
<     * Constructs an object to manage a file of records.
<     * If the file does not exist, it is created.
<     * @param ti the table metadata
<     * @param tx the transaction
<     */
<    public RecordFile(TableInfo ti, Transaction tx) {
<       this.ti = ti;
<       this.tx = tx;
<       filename = ti.fileName();
<       if (tx.size(filename) == 0)
<          appendBlock();
<       moveTo(0);
<    }
<    
<    /**
<     * Closes the record file.
<     */
<    public void close() {
<       rp.close();
<    }
<    
<    /**
<     * Positions the current record so that a call to method next
<     * will wind up at the first record. 
<     */
<    public void beforeFirst() {
<       moveTo(0);
<    }
<    
<    /**
<     * Moves to the next record. Returns false if there
<     * is no next record.
<     * @return false if there is no next record.
<     */
<    public boolean next() {
<       while (true) {
<          if (rp.next())
<             return true;
<          if (atLastBlock())
<             return false;
<          moveTo(currentblknum + 1);
<       }
<    }
<    
<    /**
<     * Returns the value of the specified field
<     * in the current record.
<     * @param fldname the name of the field
<     * @return the integer value at that field
<     */
<    public int getInt(String fldname) {
<       return rp.getInt(fldname);
<    }
<    
<    /**
<     * Returns the value of the specified field
<     * in the current record.
<     * @param fldname the name of the field
<     * @return the string value at that field
<     */
<    public String getString(String fldname) {
<       return rp.getString(fldname);
<    }
<    
<    /**
<     * Sets the value of the specified field 
<     * in the current record.
<     * @param fldname the name of the field
<     * @param val the new value for the field
<     */
<    public void setInt(String fldname, int val) {
<       rp.setInt(fldname, val);
<    }
<    
<    /**
<     * Sets the value of the specified field 
<     * in the current record.
<     * @param fldname the name of the field
<     * @param val the new value for the field
<     */
<    public void setString(String fldname, String val) {
<       rp.setString(fldname, val);
<    }
<    
<    /**
<     * Deletes the current record.
<     * The client must call next() to move to
<     * the next record.
<     * Calls to methods on a deleted record 
<     * have unspecified behavior.
<     */
<    public void delete() {
<       rp.delete();
<    }
<    
<    /**
<     * Inserts a new, blank record somewhere in the file
<     * beginning at the current record.
<     * If the new record does not fit into an existing block,
<     * then a new block is appended to the file.
<     */
<    public void insert() {
<       while (!rp.insert()) {
<          if (atLastBlock())
<             appendBlock();
<          moveTo(currentblknum + 1);
<       }
<    }
<    
<    /**
<     * Positions the current record as indicated by the
<     * specified RID. 
<     * @param rid a record identifier
<     */
<    public void moveToRid(RID rid) {
<       moveTo(rid.blockNumber());
<       rp.moveToId(rid.id());
<    }
<    
<    /**
<     * Returns the RID of the current record.
<     * @return a record identifier
<     */
<    public RID currentRid() {
<       int id = rp.currentId();
<       return new RID(currentblknum, id);
<    }
<    
<    private void moveTo(int b) {
<       if (rp != null)
<          rp.close();
<       currentblknum = b;
<       Block blk = new Block(filename, currentblknum);
<       rp = new RecordPage(blk, ti, tx);
<    }
<    
<    private boolean atLastBlock() {
<       return currentblknum == tx.size(filename) - 1;
<    }
<    
<    private void appendBlock() {
<       RecordFormatter fmtr = new RecordFormatter(ti);
<       tx.append(filename, fmtr);
<    }
---
> package simpledb.record;
> 
> import simpledb.file.Block;
> import simpledb.tx.Transaction;
> 
> /**
>  * Manages a file of records.
>  * There are methods for iterating through the records
>  * and accessing their contents.
>  * @author Edward Sciore
>  */
> public class RecordFile {
>    private TableInfo ti;
>    private Transaction tx;
>    private String filename;
>    private RecordPage rp;
>    private int currentblknum;
>    
>    /**
>     * Constructs an object to manage a file of records.
>     * If the file does not exist, it is created.
>     * @param ti the table metadata
>     * @param tx the transaction
>     */
>    public RecordFile(TableInfo ti, Transaction tx) {
>       this.ti = ti;
>       this.tx = tx;
>       filename = ti.fileName();
>       if (tx.size(filename) == 0)
>          appendBlock();
>       moveTo(0);
>    }
>    
>    /**
>     * Closes the record file.
>     */
>    public void close() {
>       rp.close();
>    }
>    
>    /**
>     * Positions the current record so that a call to method next
>     * will wind up at the first record. 
>     */
>    public void beforeFirst() {
>       moveTo(0);
>    }
>    
>    /**
>     * Moves to the next record. Returns false if there
>     * is no next record.
>     * @return false if there is no next record.
>     */
>    public boolean next() {
>       while (true) {
>          if (rp.next())
>             return true;
>          if (atLastBlock())
>             return false;
>          moveTo(currentblknum + 1);
>       }
>    }
>    
>    /**
>     * Returns the value of the specified field
>     * in the current record.
>     * @param fldname the name of the field
>     * @return the integer value at that field
>     */
>    public int getInt(String fldname) {
>       return rp.getInt(fldname);
>    }
>    
>    /**
>     * Returns the value of the specified field
>     * in the current record.
>     * @param fldname the name of the field
>     * @return the string value at that field
>     */
>    public String getString(String fldname) {
>       return rp.getString(fldname);
>    }
>    
>    /**
>     * Sets the value of the specified field 
>     * in the current record.
>     * @param fldname the name of the field
>     * @param val the new value for the field
>     */
>    public void setInt(String fldname, int val) {
>       rp.setInt(fldname, val);
>    }
>    
>    /**
>     * Sets the value of the specified field 
>     * in the current record.
>     * @param fldname the name of the field
>     * @param val the new value for the field
>     */
>    public void setString(String fldname, String val) {
>       rp.setString(fldname, val);
>    }
>    
>    /**
>     * Deletes the current record.
>     * The client must call next() to move to
>     * the next record.
>     * Calls to methods on a deleted record 
>     * have unspecified behavior.
>     */
>    public void delete() {
>       rp.delete();
>    }
>    
>    /**
>     * Inserts a new, blank record somewhere in the file
>     * beginning at the current record.
>     * If the new record does not fit into an existing block,
>     * then a new block is appended to the file.
>     */
>    public void insert() {
>       while (!rp.insert()) {
>          if (atLastBlock()) {
>             appendBlock();
>           }
>          moveTo(currentblknum + 1);
>       }
>    }
>    
>    /**
>     * Positions the current record as indicated by the
>     * specified RID. 
>     * @param rid a record identifier
>     */
>    public void moveToRid(RID rid) {
>       moveTo(rid.blockNumber());
>       rp.moveToId(rid.id());
>    }
>    
>    /**
>     * Returns the RID of the current record.
>     * @return a record identifier
>     */
>    public RID currentRid() {
>       int id = rp.currentId();
>       return new RID(currentblknum, id);
>    }
>    
>    private void moveTo(int b) {
>       if (rp != null)
>          rp.close();
>       currentblknum = b;
>       Block blk = new Block(filename, currentblknum);
>       rp = new RecordPage(blk, ti, tx);
>    }
>    
>    private boolean atLastBlock() {
>       return currentblknum == tx.size(filename) - 1;
>    }
>    
>    private void appendBlock() {
>         RecordFormatter fmtr = new RecordFormatter(ti);
>         tx.append(filename, fmtr);
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/record/RecordFormatter.java ../cs4432-proj2/src/simpledb/record/RecordFormatter.java
1,50c1,50
< package simpledb.record;
< 
< import static java.sql.Types.INTEGER;
< import static simpledb.file.Page.*;
< import static simpledb.record.RecordPage.EMPTY;
< import simpledb.file.Page;
< import simpledb.buffer.PageFormatter;
< 
< /**
<  * An object that can format a page to look like a block of 
<  * empty records.
<  * @author Edward Sciore
<  */
< class RecordFormatter implements PageFormatter {
<    private TableInfo ti;
<    
<    /**
<     * Creates a formatter for a new page of a table.
<     * @param ti the table's metadata
<     */
<    public RecordFormatter(TableInfo ti) {
<       this.ti = ti;
<    }
<    
<    /** 
<     * Formats the page by allocating as many record slots
<     * as possible, given the record length.
<     * Each record slot is assigned a flag of EMPTY.
<     * Each integer field is given a value of 0, and
<     * each string field is given a value of "".
<     * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
<     */
<    public void format(Page page) {
<       int recsize = ti.recordLength() + INT_SIZE;
<       for (int pos=0; pos+recsize<=BLOCK_SIZE; pos += recsize) {
<          page.setInt(pos, EMPTY);
<          makeDefaultRecord(page, pos);
<       }
<    }
<    
<    private void makeDefaultRecord(Page page, int pos) {
<       for (String fldname : ti.schema().fields()) {
<          int offset = ti.offset(fldname);
<          if (ti.schema().type(fldname) == INTEGER)
<             page.setInt(pos + INT_SIZE + offset, 0);
<          else
<             page.setString(pos + INT_SIZE + offset, "");
<       }
<    }
< }
---
> package simpledb.record;
> 
> import static java.sql.Types.INTEGER;
> import static simpledb.file.Page.*;
> import static simpledb.record.RecordPage.EMPTY;
> import simpledb.file.Page;
> import simpledb.buffer.PageFormatter;
> 
> /**
>  * An object that can format a page to look like a block of 
>  * empty records.
>  * @author Edward Sciore
>  */
> class RecordFormatter implements PageFormatter {
>    private TableInfo ti;
>    
>    /**
>     * Creates a formatter for a new page of a table.
>     * @param ti the table's metadata
>     */
>    public RecordFormatter(TableInfo ti) {
>       this.ti = ti;
>    }
>    
>    /** 
>     * Formats the page by allocating as many record slots
>     * as possible, given the record length.
>     * Each record slot is assigned a flag of EMPTY.
>     * Each integer field is given a value of 0, and
>     * each string field is given a value of "".
>     * @see simpledb.buffer.PageFormatter#format(simpledb.file.Page)
>     */
>    public void format(Page page) {
>       int recsize = ti.recordLength() + INT_SIZE;
>       for (int pos=0; pos+recsize<=BLOCK_SIZE; pos += recsize) {
>          page.setInt(pos, EMPTY);
>          makeDefaultRecord(page, pos);
>       }
>    }
>    
>    private void makeDefaultRecord(Page page, int pos) {
>       for (String fldname : ti.schema().fields()) {
>          int offset = ti.offset(fldname);
>          if (ti.schema().type(fldname) == INTEGER)
>             page.setInt(pos + INT_SIZE + offset, 0);
>          else
>             page.setString(pos + INT_SIZE + offset, "");
>       }
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/record/RecordPage.java ../cs4432-proj2/src/simpledb/record/RecordPage.java
1,162c1,162
< package simpledb.record;
< 
< import static simpledb.file.Page.*;
< import simpledb.file.Block;
< import simpledb.tx.Transaction;
< 
< /**
<  * Manages the placement and access of records in a block.
<  * @author Edward Sciore
<  */
< public class RecordPage {
<    public static final int EMPTY = 0, INUSE = 1;
<    
<    private Block blk;
<    private TableInfo ti;
<    private Transaction tx;
<    private int slotsize;
<    private int currentslot = -1;
<    
<    /** Creates the record manager for the specified block.
<      * The current record is set to be prior to the first one.
<      * @param blk a reference to the disk block
<      * @param ti the table's metadata
<      * @param tx the transaction performing the operations
<      */
<    public RecordPage(Block blk, TableInfo ti, Transaction tx) {
<       this.blk = blk;
<       this.ti = ti;
<       this.tx = tx;
<       slotsize = ti.recordLength() + INT_SIZE;
<       tx.pin(blk);
<   }
<    
<    /**
<     * Closes the manager, by unpinning the block.
<     */
<    public void close() {
<       if (blk != null) {
<     	  tx.unpin(blk);
<     	  blk = null;
<       }
<    }
<    
<    /**
<     * Moves to the next record in the block.
<     * @return false if there is no next record.
<     */
<    public boolean next() {
<       return searchFor(INUSE);
<    }
<    
<    /**
<     * Returns the integer value stored for the
<     * specified field of the current record.
<     * @param fldname the name of the field.
<     * @return the integer stored in that field
<     */
<    public int getInt(String fldname) {
<       int position = fieldpos(fldname);
<       return tx.getInt(blk, position);
<    }
<    
<    /**
<     * Returns the string value stored for the
<     * specified field of the current record.
<     * @param fldname the name of the field.
<     * @return the string stored in that field
<     */
<    public String getString(String fldname) {
<       int position = fieldpos(fldname);
<       return tx.getString(blk, position);
<    }
<    
<    /**
<     * Stores an integer at the specified field
<     * of the current record.
<     * @param fldname the name of the field
<     * @param val the integer value stored in that field
<     */
<    public void setInt(String fldname, int val) {
<       int position = fieldpos(fldname);
<       tx.setInt(blk, position, val);
<    }
<    
<    /**
<     * Stores a string at the specified field
<     * of the current record.
<     * @param fldname the name of the field
<     * @param val the string value stored in that field
<     */
<    public void setString(String fldname, String val) {
<       int position = fieldpos(fldname);
<       tx.setString(blk, position, val);
<    }
<    
<    /**
<     * Deletes the current record.
<     * Deletion is performed by just marking the record
<     * as "deleted"; the current record does not change. 
<     * To get to the next record, call next().
<     */
<    public void delete() {
<       int position = currentpos();
<       tx.setInt(blk, position, EMPTY);
<    }
<    
<    /**
<     * Inserts a new, blank record somewhere in the page.
<     * Return false if there were no available slots.
<     * @return false if the insertion was not possible
<     */
<    public boolean insert() {
<       currentslot = -1;
<       boolean found = searchFor(EMPTY);
<       if (found) {
<          int position = currentpos();
<          tx.setInt(blk, position, INUSE);
<       }
<       return found;
<    }
<    
<    /**
<     * Sets the current record to be the record having the
<     * specified ID.
<     * @param id the ID of the record within the page.
<     */
<    public void moveToId(int id) {
<       currentslot = id;
<    }
<    
<    /**
<     * Returns the ID of the current record.
<     * @return the ID of the current record
<     */
<    public int currentId() {
<       return currentslot;
<    }
<    
<    private int currentpos() {
<       return currentslot * slotsize;
<    }
<    
<    private int fieldpos(String fldname) {
<       int offset = INT_SIZE + ti.offset(fldname);
<       return currentpos() + offset;
<    }
<    
<    private boolean isValidSlot() {
<       return currentpos() + slotsize <= BLOCK_SIZE;
<    }
<    
<    private boolean searchFor(int flag) {
<       currentslot++;
<       while (isValidSlot()) {
<          int position = currentpos();
<          if (tx.getInt(blk, position) == flag)
<             return true;
<          currentslot++;
<       }
<       return false;
<    }
< }
---
> package simpledb.record;
> 
> import static simpledb.file.Page.*;
> import simpledb.file.Block;
> import simpledb.tx.Transaction;
> 
> /**
>  * Manages the placement and access of records in a block.
>  * @author Edward Sciore
>  */
> public class RecordPage {
>    public static final int EMPTY = 0, INUSE = 1;
>    
>    private Block blk;
>    private TableInfo ti;
>    private Transaction tx;
>    private int slotsize;
>    private int currentslot = -1;
>    
>    /** Creates the record manager for the specified block.
>      * The current record is set to be prior to the first one.
>      * @param blk a reference to the disk block
>      * @param ti the table's metadata
>      * @param tx the transaction performing the operations
>      */
>    public RecordPage(Block blk, TableInfo ti, Transaction tx) {
>       this.blk = blk;
>       this.ti = ti;
>       this.tx = tx;
>       slotsize = ti.recordLength() + INT_SIZE;
>       tx.pin(blk);
>   }
>    
>    /**
>     * Closes the manager, by unpinning the block.
>     */
>    public void close() {
>       if (blk != null) {
>     	  tx.unpin(blk);
>     	  blk = null;
>       }
>    }
>    
>    /**
>     * Moves to the next record in the block.
>     * @return false if there is no next record.
>     */
>    public boolean next() {
>       return searchFor(INUSE);
>    }
>    
>    /**
>     * Returns the integer value stored for the
>     * specified field of the current record.
>     * @param fldname the name of the field.
>     * @return the integer stored in that field
>     */
>    public int getInt(String fldname) {
>       int position = fieldpos(fldname);
>       return tx.getInt(blk, position);
>    }
>    
>    /**
>     * Returns the string value stored for the
>     * specified field of the current record.
>     * @param fldname the name of the field.
>     * @return the string stored in that field
>     */
>    public String getString(String fldname) {
>       int position = fieldpos(fldname);
>       return tx.getString(blk, position);
>    }
>    
>    /**
>     * Stores an integer at the specified field
>     * of the current record.
>     * @param fldname the name of the field
>     * @param val the integer value stored in that field
>     */
>    public void setInt(String fldname, int val) {
>       int position = fieldpos(fldname);
>       tx.setInt(blk, position, val);
>    }
>    
>    /**
>     * Stores a string at the specified field
>     * of the current record.
>     * @param fldname the name of the field
>     * @param val the string value stored in that field
>     */
>    public void setString(String fldname, String val) {
>       int position = fieldpos(fldname);
>       tx.setString(blk, position, val);
>    }
>    
>    /**
>     * Deletes the current record.
>     * Deletion is performed by just marking the record
>     * as "deleted"; the current record does not change. 
>     * To get to the next record, call next().
>     */
>    public void delete() {
>       int position = currentpos();
>       tx.setInt(blk, position, EMPTY);
>    }
>    
>    /**
>     * Inserts a new, blank record somewhere in the page.
>     * Return false if there were no available slots.
>     * @return false if the insertion was not possible
>     */
>    public boolean insert() {
>       currentslot = -1;
>       boolean found = searchFor(EMPTY);
>       if (found) {
>          int position = currentpos();
>          tx.setInt(blk, position, INUSE);
>       }
>       return found;
>    }
>    
>    /**
>     * Sets the current record to be the record having the
>     * specified ID.
>     * @param id the ID of the record within the page.
>     */
>    public void moveToId(int id) {
>       currentslot = id;
>    }
>    
>    /**
>     * Returns the ID of the current record.
>     * @return the ID of the current record
>     */
>    public int currentId() {
>       return currentslot;
>    }
>    
>    private int currentpos() {
>       return currentslot * slotsize;
>    }
>    
>    private int fieldpos(String fldname) {
>       int offset = INT_SIZE + ti.offset(fldname);
>       return currentpos() + offset;
>    }
>    
>    private boolean isValidSlot() {
>       return currentpos() + slotsize <= BLOCK_SIZE;
>    }
>    
>    private boolean searchFor(int flag) {
>       currentslot++;
>       while (isValidSlot()) {
>          int position = currentpos();
>          if (tx.getInt(blk, position) == flag)
>             return true;
>          currentslot++;
>       }
>       return false;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/record/Schema.java ../cs4432-proj2/src/simpledb/record/Schema.java
1,126c1,126
< package simpledb.record;
< 
< import static java.sql.Types.*;
< import java.util.*;
< 
< /**
<  * The record schema of a table.
<  * A schema contains the name and type of
<  * each field of the table, as well as the length
<  * of each varchar field.
<  * @author Edward Sciore
<  *
<  */
< public class Schema {
<    private Map<String,FieldInfo> info = new HashMap<String,FieldInfo>();
<    
<    /**
<     * Creates an empty schema.
<     * Field information can be added to a schema
<     * via the five addXXX methods. 
<     */
<    public Schema() {}
<    
<    /**
<     * Adds a field to the schema having a specified
<     * name, type, and length.
<     * If the field type is "integer", then the length
<     * value is irrelevant.
<     * @param fldname the name of the field
<     * @param type the type of the field, according to the constants in simpledb.sql.types
<     * @param length the conceptual length of a string field.
<     */
<    public void addField(String fldname, int type, int length) {
<       info.put(fldname, new FieldInfo(type, length));
<    }
<    
<    /**
<     * Adds an integer field to the schema.
<     * @param fldname the name of the field
<     */
<    public void addIntField(String fldname) {
<       addField(fldname, INTEGER, 0);
<    }
<    
<    /**
<     * Adds a string field to the schema.
<     * The length is the conceptual length of the field.
<     * For example, if the field is defined as varchar(8),
<     * then its length is 8.
<     * @param fldname the name of the field
<     * @param length the number of chars in the varchar definition
<     */
<    public void addStringField(String fldname, int length) {
<       addField(fldname, VARCHAR, length);
<    }
<    
<    /**
<     * Adds a field to the schema having the same
<     * type and length as the corresponding field
<     * in another schema.
<     * @param fldname the name of the field
<     * @param sch the other schema
<     */
<    public void add(String fldname, Schema sch) {
<       int type   = sch.type(fldname);
<       int length = sch.length(fldname);
<       addField(fldname, type, length);
<    }
<    
<    /**
<     * Adds all of the fields in the specified schema
<     * to the current schema.
<     * @param sch the other schema
<     */
<    public void addAll(Schema sch) {
<       info.putAll(sch.info);
<    }
<    
<    /**
<     * Returns a collection containing the name of
<     * each field in the schema.
<     * @return the collection of the schema's field names
<     */
<    public Collection<String> fields() {
<       return info.keySet();
<    }
<    
<    /**
<     * Returns true if the specified field
<     * is in the schema
<     * @param fldname the name of the field
<     * @return true if the field is in the schema
<     */
<    public boolean hasField(String fldname) {
<       return fields().contains(fldname);
<    }
<    
<    /**
<     * Returns the type of the specified field, using the
<     * constants in {@link java.sql.Types}.
<     * @param fldname the name of the field
<     * @return the integer type of the field
<     */
<    public int type(String fldname) {
<       return info.get(fldname).type;
<    }
<    
<    /**
<     * Returns the conceptual length of the specified field.
<     * If the field is not a string field, then
<     * the return value is undefined.
<     * @param fldname the name of the field
<     * @return the conceptual length of the field
<     */
<    public int length(String fldname) {
<       return info.get(fldname).length;
<    }
<    
<    class FieldInfo {
<       int type, length;
<       public FieldInfo(int type, int length) {
<          this.type = type;
<          this.length = length;
<       }
<    }
< }
---
> package simpledb.record;
> 
> import static java.sql.Types.*;
> import java.util.*;
> 
> /**
>  * The record schema of a table.
>  * A schema contains the name and type of
>  * each field of the table, as well as the length
>  * of each varchar field.
>  * @author Edward Sciore
>  *
>  */
> public class Schema {
>    private Map<String,FieldInfo> info = new HashMap<String,FieldInfo>();
>    
>    /**
>     * Creates an empty schema.
>     * Field information can be added to a schema
>     * via the five addXXX methods. 
>     */
>    public Schema() {}
>    
>    /**
>     * Adds a field to the schema having a specified
>     * name, type, and length.
>     * If the field type is "integer", then the length
>     * value is irrelevant.
>     * @param fldname the name of the field
>     * @param type the type of the field, according to the constants in simpledb.sql.types
>     * @param length the conceptual length of a string field.
>     */
>    public void addField(String fldname, int type, int length) {
>       info.put(fldname, new FieldInfo(type, length));
>    }
>    
>    /**
>     * Adds an integer field to the schema.
>     * @param fldname the name of the field
>     */
>    public void addIntField(String fldname) {
>       addField(fldname, INTEGER, 0);
>    }
>    
>    /**
>     * Adds a string field to the schema.
>     * The length is the conceptual length of the field.
>     * For example, if the field is defined as varchar(8),
>     * then its length is 8.
>     * @param fldname the name of the field
>     * @param length the number of chars in the varchar definition
>     */
>    public void addStringField(String fldname, int length) {
>       addField(fldname, VARCHAR, length);
>    }
>    
>    /**
>     * Adds a field to the schema having the same
>     * type and length as the corresponding field
>     * in another schema.
>     * @param fldname the name of the field
>     * @param sch the other schema
>     */
>    public void add(String fldname, Schema sch) {
>       int type   = sch.type(fldname);
>       int length = sch.length(fldname);
>       addField(fldname, type, length);
>    }
>    
>    /**
>     * Adds all of the fields in the specified schema
>     * to the current schema.
>     * @param sch the other schema
>     */
>    public void addAll(Schema sch) {
>       info.putAll(sch.info);
>    }
>    
>    /**
>     * Returns a collection containing the name of
>     * each field in the schema.
>     * @return the collection of the schema's field names
>     */
>    public Collection<String> fields() {
>       return info.keySet();
>    }
>    
>    /**
>     * Returns true if the specified field
>     * is in the schema
>     * @param fldname the name of the field
>     * @return true if the field is in the schema
>     */
>    public boolean hasField(String fldname) {
>       return fields().contains(fldname);
>    }
>    
>    /**
>     * Returns the type of the specified field, using the
>     * constants in {@link java.sql.Types}.
>     * @param fldname the name of the field
>     * @return the integer type of the field
>     */
>    public int type(String fldname) {
>       return info.get(fldname).type;
>    }
>    
>    /**
>     * Returns the conceptual length of the specified field.
>     * If the field is not a string field, then
>     * the return value is undefined.
>     * @param fldname the name of the field
>     * @return the conceptual length of the field
>     */
>    public int length(String fldname) {
>       return info.get(fldname).length;
>    }
>    
>    class FieldInfo {
>       int type, length;
>       public FieldInfo(int type, int length) {
>          this.type = type;
>          this.length = length;
>       }
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/record/TableInfo.java ../cs4432-proj2/src/simpledb/record/TableInfo.java
1,95c1,152
< package simpledb.record;
< 
< import static java.sql.Types.INTEGER;
< import static simpledb.file.Page.*;
< import java.util.*;
< 
< /**
<  * The metadata about a table and its records.
<  * @author Edward Sciore
<  */
< public class TableInfo {
<    private Schema schema;
<    private Map<String,Integer> offsets;
<    private int recordlen;
<    private String tblname;
<    
<    /**
<     * Creates a TableInfo object, given a table name
<     * and schema. The constructor calculates the
<     * physical offset of each field.
<     * This constructor is used when a table is created. 
<     * @param tblname the name of the table
<     * @param schema the schema of the table's records
<     */
<    public TableInfo(String tblname, Schema schema) {
<       this.schema = schema;
<       this.tblname = tblname;
<       offsets  = new HashMap<String,Integer>();
<       int pos = 0;
<       for (String fldname : schema.fields()) {
<          offsets.put(fldname, pos);
<          pos += lengthInBytes(fldname);
<       }
<       recordlen = pos;
<    }
<    
<    /**
<     * Creates a TableInfo object from the 
<     * specified metadata.
<     * This constructor is used when the metadata
<     * is retrieved from the catalog.
<     * @param tblname the name of the table
<     * @param schema the schema of the table's records
<     * @param offsets the already-calculated offsets of the fields within a record
<     * @param recordlen the already-calculated length of each record
<     */
<    public TableInfo(String tblname, Schema schema, Map<String,Integer> offsets, int recordlen) {
<       this.tblname   = tblname;
<       this.schema    = schema;
<       this.offsets   = offsets;
<       this.recordlen = recordlen;
<    }
<    
<    /**
<     * Returns the filename assigned to this table.
<     * Currently, the filename is the table name
<     * followed by ".tbl".
<     * @return the name of the file assigned to the table
<     */
<    public String fileName() {
<       return tblname + ".tbl";
<    }
<    
<    /**
<     * Returns the schema of the table's records
<     * @return the table's record schema
<     */
<    public Schema schema() {
<       return schema;
<    }
<    
<    /**
<     * Returns the offset of a specified field within a record
<     * @param fldname the name of the field
<     * @return the offset of that field within a record
<     */
<    public int offset(String fldname) {
<       return offsets.get(fldname);
<    }
<    
<    /**
<     * Returns the length of a record, in bytes.
<     * @return the length in bytes of a record
<     */
<    public int recordLength() {
<       return recordlen;
<    }
<    
<    private int lengthInBytes(String fldname) {
<       int fldtype = schema.type(fldname);
<       if (fldtype == INTEGER)
<          return INT_SIZE;
<       else
<          return STR_SIZE(schema.length(fldname));
<    }
---
> package simpledb.record;
> 
> import static java.sql.Types.INTEGER;
> import static simpledb.file.Page.*;
> import java.util.*;
> 
> /**
>  * The metadata about a table and its records.
>  * @author Edward Sciore
>  *
>  * CS 4432 Project 2
>  * 
>  * Sortfields and a boolean flag were added 
>  */
> public class TableInfo {
>    private Schema schema;
>    private Map<String,Integer> offsets;
>    private int recordlen;
>    private String tblname;
>    private boolean sorted;
>    private List<String> sortFields;
>    
>     /**
>      * Creates a TableInfo object, given a table name
>      * and schema. The constructor calculates the
>      * physical offset of each field.
>      * This constructor is used when a table is created. 
>      * @param tblname the name of the table
>      * @param schema the schema of the table's records
>      */
>     public TableInfo(
>         String tblname, 
>         Schema schema
>         ) {
>         this(tblname, schema, new HashMap<String,Integer>(), 0, false, new ArrayList<String>());
>         for (String fldname : this.schema.fields()) {
>             this.offsets.put(fldname, this.recordlen);
>             this.recordlen += lengthInBytes(fldname);
>         }
>     }
> 
>     /**
>      * Creates a TableInfo object from the 
>      * specified metadata.
>      * This constructor is used when the metadata
>      * is retrieved from the catalog.
>      * @param tblname the name of the table
>      * @param schema the schema of the table's records
>      * @param offsets the already-calculated offsets of the fields within a record
>      * @param recordlen the already-calculated length of each record
>      */
>     public TableInfo(
>         String tblname, 
>         Schema schema, 
>         Map<String,Integer> offsets, 
>         int recordlen
>         ) {
>         this(tblname, schema, offsets, recordlen, false, new ArrayList<String>());
>     }
> 
>     /**
>      * Creates a TableInfo object from the 
>      * specified metadata.
>      * This constructor is used when the metadata
>      * is retrieved from the catalog.
>      * @param tblname the name of the table
>      * @param schema the schema of the table's records
>      * @param offsets the already-calculated offsets of the fields within a record
>      * @param recordlen the already-calculated length of each record
>      */
>     public TableInfo(
>         String tblname, 
>         Schema schema, 
>         Map<String,Integer> offsets, 
>         int recordlen, 
>         boolean sorted,
>         List<String> sortFields
>         ) {
>         this.tblname   = tblname;
>         this.schema    = schema;
>         this.offsets   = offsets;
>         this.recordlen = recordlen;
>         this.sorted = sorted;
>         this.sortFields = sortFields;
>     }
>    
>    /**
>     * Returns the name assigned to this table.
>     * @return the name of the table
>     */
>    public String tableName() {
>       return tblname;
>    }
> 
>    /**
>     * Returns the filename assigned to this table.
>     * Currently, the filename is the table name
>     * followed by ".tbl".
>     * @return the name of the file assigned to the table
>     */
>    public String fileName() {
>       return tblname + ".tbl";
>    }
>    
>    /**
>     * Returns the schema of the table's records
>     * @return the table's record schema
>     */
>    public Schema schema() {
>       return schema;
>    }
>    
>    /**
>     * Returns the offset of a specified field within a record
>     * @param fldname the name of the field
>     * @return the offset of that field within a record
>     */
>    public int offset(String fldname) {
>       return offsets.get(fldname);
>    }
>    
>    /**
>     * Returns the length of a record, in bytes.
>     * @return the length in bytes of a record
>     */
>    public int recordLength() {
>       return recordlen;
>    }
>    
>    private int lengthInBytes(String fldname) {
>       int fldtype = schema.type(fldname);
>       if (fldtype == INTEGER)
>          return INT_SIZE;
>       else
>          return STR_SIZE(schema.length(fldname));
>    }
> 
>     public boolean getSorted() {
>         return sorted;
>     }
> 
>     public void setSorted(boolean new_sorted) {
>         sorted = new_sorted;
>     }
> 
>     public List<String> getSortFields() {
>         return sortFields;
>     }
> 
>     public void setSortFields(List<String> new_sortFields) {
>         sortFields = new_sortFields;
>     }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/ConnectionAdapter.java ../cs4432-proj2/src/simpledb/remote/ConnectionAdapter.java
1,227c1,227
< package simpledb.remote;
< 
< import java.sql.*;
< import java.util.*;
< import java.util.concurrent.*;
< 
< /**
<  * This class implements all of the methods of the Connection interface,
<  * by throwing an exception for each one.
<  * Subclasses (such as SimpleConnection) can override those methods that 
<  * it want to implement.
<  * @author Edward Sciore
<  */
< public abstract class ConnectionAdapter implements Connection {
<    public void clearWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void close() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void commit() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Blob createBlob() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Clob createClob() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public NClob createNClob() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLXML createSQLXML() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Statement createStatement() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean getAutoCommit() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getCatalog() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Properties getClientInfo() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getClientInfo(String name) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getHoldability() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public DatabaseMetaData getMetaData() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getTransactionIsolation() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Map<String,Class<?>> getTypeMap() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLWarning getWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isClosed() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isReadOnly() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isValid(int timeout) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String nativeSQL(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public CallableStatement prepareCall(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void rollback() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void rollback(Savepoint svepoint) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setAutoCommit(boolean autoCommit) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setCatalog(String catalog) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setClientInfo(String name, String value) {
<    }
<    
<    public void setClientInfo(Properties properties) {
<    }
<    
<    public void setHoldability(int holdability) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setReadOnly(boolean readOnly) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Savepoint setSavepoint() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Savepoint setSavepoint(String name) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setTransactionIsolation(int level) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setTypeMap(Map<String,Class<?>> map) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isWrapperFor(Class<?> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T unwrap(Class<T> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void abort(Executor executor) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<   	public int getNetworkTimeout()	 throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<   	
<   	public String getSchema() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<   	
<   	public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<   	
<   	public void setSchema(String schema) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }   
---
> package simpledb.remote;
> 
> import java.sql.*;
> import java.util.*;
> import java.util.concurrent.*;
> 
> /**
>  * This class implements all of the methods of the Connection interface,
>  * by throwing an exception for each one.
>  * Subclasses (such as SimpleConnection) can override those methods that 
>  * it want to implement.
>  * @author Edward Sciore
>  */
> public abstract class ConnectionAdapter implements Connection {
>    public void clearWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void close() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void commit() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Blob createBlob() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Clob createClob() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public NClob createNClob() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLXML createSQLXML() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Statement createStatement() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean getAutoCommit() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getCatalog() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Properties getClientInfo() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getClientInfo(String name) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getHoldability() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public DatabaseMetaData getMetaData() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getTransactionIsolation() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Map<String,Class<?>> getTypeMap() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLWarning getWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isClosed() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isReadOnly() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isValid(int timeout) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String nativeSQL(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public CallableStatement prepareCall(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void rollback() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void rollback(Savepoint svepoint) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setAutoCommit(boolean autoCommit) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setCatalog(String catalog) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setClientInfo(String name, String value) {
>    }
>    
>    public void setClientInfo(Properties properties) {
>    }
>    
>    public void setHoldability(int holdability) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setReadOnly(boolean readOnly) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Savepoint setSavepoint() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Savepoint setSavepoint(String name) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setTransactionIsolation(int level) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setTypeMap(Map<String,Class<?>> map) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isWrapperFor(Class<?> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T unwrap(Class<T> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void abort(Executor executor) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>   	public int getNetworkTimeout()	 throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>   	
>   	public String getSchema() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>   	
>   	public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>   	
>   	public void setSchema(String schema) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }   
diff -r simpledb/SimpleDB_2.10/simpledb/remote/DriverAdapter.java ../cs4432-proj2/src/simpledb/remote/DriverAdapter.java
1,41c1,41
< package simpledb.remote;
< 
< import java.sql.*;
< import java.util.*;
< import java.util.logging.Logger;
< 
< /**
<  * This class implements all of the methods of the Driver interface,
<  * by throwing an exception for each one.
<  * Subclasses (such as SimpleDriver) can override those methods that 
<  * it want to implement.
<  * @author Edward Sciore
<  */
< public abstract class DriverAdapter implements Driver {
<    public boolean acceptsURL(String url) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Connection connect(String url, Properties info) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getMajorVersion() {
<       return 0;
<    }
<    
<    public int getMinorVersion() {
<       return 0;
<    }
<    
<    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
<       return null;
<    }
<    
<    public boolean jdbcCompliant() {
<       return false;
<    }
<    
<    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
<       throw new SQLFeatureNotSupportedException("operation not implemented");
<    }
---
> package simpledb.remote;
> 
> import java.sql.*;
> import java.util.*;
> import java.util.logging.Logger;
> 
> /**
>  * This class implements all of the methods of the Driver interface,
>  * by throwing an exception for each one.
>  * Subclasses (such as SimpleDriver) can override those methods that 
>  * it want to implement.
>  * @author Edward Sciore
>  */
> public abstract class DriverAdapter implements Driver {
>    public boolean acceptsURL(String url) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Connection connect(String url, Properties info) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getMajorVersion() {
>       return 0;
>    }
>    
>    public int getMinorVersion() {
>       return 0;
>    }
>    
>    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
>       return null;
>    }
>    
>    public boolean jdbcCompliant() {
>       return false;
>    }
>    
>    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
>       throw new SQLFeatureNotSupportedException("operation not implemented");
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteConnection.java ../cs4432-proj2/src/simpledb/remote/RemoteConnection.java
1,15c1,15
< package simpledb.remote;
< 
< import java.rmi.*;
< 
< /**
<  * The RMI remote interface corresponding to Connection.
<  * The methods are identical to those of Connection, 
<  * except that they throw RemoteExceptions instead of SQLExceptions.
<  * @author Edward Sciore
<  */
< public interface RemoteConnection extends Remote {
<    public RemoteStatement createStatement() throws RemoteException;
<    public void close() throws RemoteException;
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.*;
> 
> /**
>  * The RMI remote interface corresponding to Connection.
>  * The methods are identical to those of Connection, 
>  * except that they throw RemoteExceptions instead of SQLExceptions.
>  * @author Edward Sciore
>  */
> public interface RemoteConnection extends Remote {
>    public RemoteStatement createStatement() throws RemoteException;
>    public void close() throws RemoteException;
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteConnectionImpl.java ../cs4432-proj2/src/simpledb/remote/RemoteConnectionImpl.java
1,70c1,70
< package simpledb.remote;
< 
< import simpledb.tx.Transaction;
< import java.rmi.RemoteException;
< import java.rmi.server.UnicastRemoteObject;
< 
< /**
<  * The RMI server-side implementation of RemoteConnection.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial") 
< class RemoteConnectionImpl extends UnicastRemoteObject implements RemoteConnection {
<    private Transaction tx;
<    
<    /**
<     * Creates a remote connection
<     * and begins a new transaction for it.
<     * @throws RemoteException
<     */
<    RemoteConnectionImpl() throws RemoteException {
<       tx = new Transaction();
<    }
<    
<    /**
<     * Creates a new RemoteStatement for this connection.
<     * @see simpledb.remote.RemoteConnection#createStatement()
<     */
<    public RemoteStatement createStatement() throws RemoteException {
<       return new RemoteStatementImpl(this);
<    }
<    
<    /**
<     * Closes the connection.
<     * The current transaction is committed.
<     * @see simpledb.remote.RemoteConnection#close()
<     */
<    public void close() throws RemoteException {
<       tx.commit();
<    }
<    
< // The following methods are used by the server-side classes.
<    
<    /**
<     * Returns the transaction currently associated with
<     * this connection.
<     * @return the transaction associated with this connection
<     */
<    Transaction getTransaction() {  
<       return tx;
<    }
<    
<    /**
<     * Commits the current transaction,
<     * and begins a new one.
<     */
<    void commit() {
<       tx.commit();
<       tx = new Transaction();
<    }
<    
<    /**
<     * Rolls back the current transaction,
<     * and begins a new one.
<     */
<    void rollback() {
<       tx.rollback();
<       tx = new Transaction();
<    }
< }
< 
---
> package simpledb.remote;
> 
> import simpledb.tx.Transaction;
> import java.rmi.RemoteException;
> import java.rmi.server.UnicastRemoteObject;
> 
> /**
>  * The RMI server-side implementation of RemoteConnection.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial") 
> class RemoteConnectionImpl extends UnicastRemoteObject implements RemoteConnection {
>    private Transaction tx;
>    
>    /**
>     * Creates a remote connection
>     * and begins a new transaction for it.
>     * @throws RemoteException
>     */
>    RemoteConnectionImpl() throws RemoteException {
>       tx = new Transaction();
>    }
>    
>    /**
>     * Creates a new RemoteStatement for this connection.
>     * @see simpledb.remote.RemoteConnection#createStatement()
>     */
>    public RemoteStatement createStatement() throws RemoteException {
>       return new RemoteStatementImpl(this);
>    }
>    
>    /**
>     * Closes the connection.
>     * The current transaction is committed.
>     * @see simpledb.remote.RemoteConnection#close()
>     */
>    public void close() throws RemoteException {
>       tx.commit();
>    }
>    
> // The following methods are used by the server-side classes.
>    
>    /**
>     * Returns the transaction currently associated with
>     * this connection.
>     * @return the transaction associated with this connection
>     */
>    Transaction getTransaction() {  
>       return tx;
>    }
>    
>    /**
>     * Commits the current transaction,
>     * and begins a new one.
>     */
>    void commit() {
>       tx.commit();
>       tx = new Transaction();
>    }
>    
>    /**
>     * Rolls back the current transaction,
>     * and begins a new one.
>     */
>    void rollback() {
>       tx.rollback();
>       tx = new Transaction();
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteDriver.java ../cs4432-proj2/src/simpledb/remote/RemoteDriver.java
1,15c1,15
< package simpledb.remote;
< 
< import java.rmi.*;
< 
< /**
<  * The RMI remote interface corresponding to Driver.
<  * The method is similar to that of Driver, 
<  * except that it takes no arguments and
<  * throws RemoteExceptions instead of SQLExceptions.
<  * @author Edward Sciore
<  */
< public interface RemoteDriver extends Remote {
<    public RemoteConnection connect() throws RemoteException;
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.*;
> 
> /**
>  * The RMI remote interface corresponding to Driver.
>  * The method is similar to that of Driver, 
>  * except that it takes no arguments and
>  * throws RemoteExceptions instead of SQLExceptions.
>  * @author Edward Sciore
>  */
> public interface RemoteDriver extends Remote {
>    public RemoteConnection connect() throws RemoteException;
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteDriverImpl.java ../cs4432-proj2/src/simpledb/remote/RemoteDriverImpl.java
1,24c1,24
< package simpledb.remote;
< 
< import java.rmi.RemoteException;
< import java.rmi.server.UnicastRemoteObject;
< 
< /**
<  * The RMI server-side implementation of RemoteDriver.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< public class RemoteDriverImpl extends UnicastRemoteObject implements RemoteDriver {
<    public RemoteDriverImpl() throws RemoteException {
<    }
<    
<    /**
<     * Creates a new RemoteConnectionImpl object and 
<     * returns it.
<     * @see simpledb.remote.RemoteDriver#connect()
<     */
<    public RemoteConnection connect() throws RemoteException {
<       return new RemoteConnectionImpl();
<    }
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.RemoteException;
> import java.rmi.server.UnicastRemoteObject;
> 
> /**
>  * The RMI server-side implementation of RemoteDriver.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> public class RemoteDriverImpl extends UnicastRemoteObject implements RemoteDriver {
>    public RemoteDriverImpl() throws RemoteException {
>    }
>    
>    /**
>     * Creates a new RemoteConnectionImpl object and 
>     * returns it.
>     * @see simpledb.remote.RemoteDriver#connect()
>     */
>    public RemoteConnection connect() throws RemoteException {
>       return new RemoteConnectionImpl();
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteMetaData.java ../cs4432-proj2/src/simpledb/remote/RemoteMetaData.java
1,17c1,17
< package simpledb.remote;
< 
< import java.rmi.*;
< 
< /**
<  * The RMI remote interface corresponding to ResultSetMetaData.
<  * The methods are identical to those of ResultSetMetaData, 
<  * except that they throw RemoteExceptions instead of SQLExceptions.
<  * @author Edward Sciore
<  */
< public interface RemoteMetaData extends Remote {
<    public int    getColumnCount()              throws RemoteException;
<    public String getColumnName(int column)     throws RemoteException;
<    public int    getColumnType(int column)     throws RemoteException;
<    public int getColumnDisplaySize(int column) throws RemoteException;
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.*;
> 
> /**
>  * The RMI remote interface corresponding to ResultSetMetaData.
>  * The methods are identical to those of ResultSetMetaData, 
>  * except that they throw RemoteExceptions instead of SQLExceptions.
>  * @author Edward Sciore
>  */
> public interface RemoteMetaData extends Remote {
>    public int    getColumnCount()              throws RemoteException;
>    public String getColumnName(int column)     throws RemoteException;
>    public int    getColumnType(int column)     throws RemoteException;
>    public int getColumnDisplaySize(int column) throws RemoteException;
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteMetaDataImpl.java ../cs4432-proj2/src/simpledb/remote/RemoteMetaDataImpl.java
1,81c1,81
< package simpledb.remote;
< 
< import simpledb.record.Schema;
< import static java.sql.Types.INTEGER;
< import java.rmi.RemoteException;
< import java.rmi.server.UnicastRemoteObject;
< import java.util.*;
< 
< /**
<  * The RMI server-side implementation of RemoteMetaData.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< public class RemoteMetaDataImpl extends UnicastRemoteObject implements RemoteMetaData {
<    private Schema sch;
<    private List<String> fields = new ArrayList<String>();
<    
<    /**
<     * Creates a metadata object that wraps the specified schema.
<     * The method also creates a list to hold the schema's
<     * collection of field names,
<     * so that the fields can be accessed by position.
<     * @param sch the schema
<     * @throws RemoteException
<     */
<    public RemoteMetaDataImpl(Schema sch) throws RemoteException {
<       this.sch = sch;
<       fields.addAll(sch.fields());
<    }
<    
<    /**
<     * Returns the size of the field list.
<     * @see simpledb.remote.RemoteMetaData#getColumnCount()
<     */
<    public int getColumnCount() throws RemoteException {
<       return fields.size();
<    }
<    
<    /**
<     * Returns the field name for the specified column number.
<     * In JDBC, column numbers start with 1, so the field
<     * is taken from position (column-1) in the list.
<     * @see simpledb.remote.RemoteMetaData#getColumnName(int)
<     */
<    public String getColumnName(int column) throws RemoteException {
<       return fields.get(column-1);
<    }
<    
<    /**
<     * Returns the type of the specified column.
<     * The method first finds the name of the field in that column,
<     * and then looks up its type in the schema.
<     * @see simpledb.remote.RemoteMetaData#getColumnType(int)
<     */
<    public int getColumnType(int column) throws RemoteException {
<       String fldname = getColumnName(column);
<       return sch.type(fldname);
<    }
<    
<    /**
<     * Returns the number of characters required to display the
<     * specified column.
<     * For a string-type field, the method simply looks up the 
<     * field's length in the schema and returns that.
<     * For an int-type field, the method needs to decide how
<     * large integers can be.
<     * Here, the method arbitrarily chooses 6 characters,
<     * which means that integers over 999,999 will  
<     * probably get displayed improperly.
<     * @see simpledb.remote.RemoteMetaData#getColumnDisplaySize(int)
<     */
<    public int getColumnDisplaySize(int column) throws RemoteException {
<       String fldname = getColumnName(column);
<       int fldtype = sch.type(fldname);
<       int fldlength = sch.length(fldname);
<       if (fldtype == INTEGER)
<          return 6;  // accommodate 6-digit integers
<       else
<          return fldlength;
<    }
< }
---
> package simpledb.remote;
> 
> import simpledb.record.Schema;
> import static java.sql.Types.INTEGER;
> import java.rmi.RemoteException;
> import java.rmi.server.UnicastRemoteObject;
> import java.util.*;
> 
> /**
>  * The RMI server-side implementation of RemoteMetaData.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> public class RemoteMetaDataImpl extends UnicastRemoteObject implements RemoteMetaData {
>    private Schema sch;
>    private List<String> fields = new ArrayList<String>();
>    
>    /**
>     * Creates a metadata object that wraps the specified schema.
>     * The method also creates a list to hold the schema's
>     * collection of field names,
>     * so that the fields can be accessed by position.
>     * @param sch the schema
>     * @throws RemoteException
>     */
>    public RemoteMetaDataImpl(Schema sch) throws RemoteException {
>       this.sch = sch;
>       fields.addAll(sch.fields());
>    }
>    
>    /**
>     * Returns the size of the field list.
>     * @see simpledb.remote.RemoteMetaData#getColumnCount()
>     */
>    public int getColumnCount() throws RemoteException {
>       return fields.size();
>    }
>    
>    /**
>     * Returns the field name for the specified column number.
>     * In JDBC, column numbers start with 1, so the field
>     * is taken from position (column-1) in the list.
>     * @see simpledb.remote.RemoteMetaData#getColumnName(int)
>     */
>    public String getColumnName(int column) throws RemoteException {
>       return fields.get(column-1);
>    }
>    
>    /**
>     * Returns the type of the specified column.
>     * The method first finds the name of the field in that column,
>     * and then looks up its type in the schema.
>     * @see simpledb.remote.RemoteMetaData#getColumnType(int)
>     */
>    public int getColumnType(int column) throws RemoteException {
>       String fldname = getColumnName(column);
>       return sch.type(fldname);
>    }
>    
>    /**
>     * Returns the number of characters required to display the
>     * specified column.
>     * For a string-type field, the method simply looks up the 
>     * field's length in the schema and returns that.
>     * For an int-type field, the method needs to decide how
>     * large integers can be.
>     * Here, the method arbitrarily chooses 6 characters,
>     * which means that integers over 999,999 will  
>     * probably get displayed improperly.
>     * @see simpledb.remote.RemoteMetaData#getColumnDisplaySize(int)
>     */
>    public int getColumnDisplaySize(int column) throws RemoteException {
>       String fldname = getColumnName(column);
>       int fldtype = sch.type(fldname);
>       int fldlength = sch.length(fldname);
>       if (fldtype == INTEGER)
>          return 6;  // accommodate 6-digit integers
>       else
>          return fldlength;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteResultSet.java ../cs4432-proj2/src/simpledb/remote/RemoteResultSet.java
1,18c1,18
< package simpledb.remote;
< 
< import java.rmi.*;
< 
< /**
<  * The RMI remote interface corresponding to ResultSet.
<  * The methods are identical to those of ResultSet, 
<  * except that they throw RemoteExceptions instead of SQLExceptions.
<  * @author Edward Sciore
<  */
< public interface RemoteResultSet extends Remote {
<    public boolean next()                   throws RemoteException;
<    public int getInt(String fldname)       throws RemoteException;
<    public String getString(String fldname) throws RemoteException;
<    public RemoteMetaData getMetaData()     throws RemoteException;
<    public void close()                     throws RemoteException;
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.*;
> 
> /**
>  * The RMI remote interface corresponding to ResultSet.
>  * The methods are identical to those of ResultSet, 
>  * except that they throw RemoteExceptions instead of SQLExceptions.
>  * @author Edward Sciore
>  */
> public interface RemoteResultSet extends Remote {
>    public boolean next()                   throws RemoteException;
>    public int getInt(String fldname)       throws RemoteException;
>    public String getString(String fldname) throws RemoteException;
>    public RemoteMetaData getMetaData()     throws RemoteException;
>    public void close()                     throws RemoteException;
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteResultSetImpl.java ../cs4432-proj2/src/simpledb/remote/RemoteResultSetImpl.java
1,96c1,96
< package simpledb.remote;
< 
< import simpledb.record.Schema;
< import simpledb.query.*;
< import java.rmi.RemoteException;
< import java.rmi.server.UnicastRemoteObject;
< 
< /**
<  * The RMI server-side implementation of RemoteResultSet.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< class RemoteResultSetImpl extends UnicastRemoteObject implements RemoteResultSet {
<    private Scan s;
<    private Schema sch;
<    private RemoteConnectionImpl rconn;
< 
<    /**
<     * Creates a RemoteResultSet object.
<     * The specified plan is opened, and the scan is saved.
<     * @param plan the query plan
<     * @param rconn TODO
<     * @throws RemoteException
<     */
<    public RemoteResultSetImpl(Plan plan, RemoteConnectionImpl rconn) throws RemoteException {
<       s = plan.open();
<       sch = plan.schema();
<       this.rconn = rconn;
<    }
< 
<    /**
<     * Moves to the next record in the result set,
<     * by moving to the next record in the saved scan.
<     * @see simpledb.remote.RemoteResultSet#next()
<     */
<    public boolean next() throws RemoteException {
< 		try {
< 	      return s.next();
<       }
<       catch(RuntimeException e) {
<          rconn.rollback();
<          throw e;
<       }
<    }
< 
<    /**
<     * Returns the integer value of the specified field,
<     * by returning the corresponding value on the saved scan.
<     * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
<     */
<    public int getInt(String fldname) throws RemoteException {
< 		try {
< 	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
< 	      return s.getInt(fldname);
<       }
<       catch(RuntimeException e) {
<          rconn.rollback();
<          throw e;
<       }
<    }
< 
<    /**
<     * Returns the integer value of the specified field,
<     * by returning the corresponding value on the saved scan.
<     * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
<     */
<    public String getString(String fldname) throws RemoteException {
< 		try {
< 	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
< 	      return s.getString(fldname);
<       }
<       catch(RuntimeException e) {
<          rconn.rollback();
<          throw e;
<       }
<    }
< 
<    /**
<     * Returns the result set's metadata,
<     * by passing its schema into the RemoteMetaData constructor.
<     * @see simpledb.remote.RemoteResultSet#getMetaData()
<     */
<    public RemoteMetaData getMetaData() throws RemoteException {
<       return new RemoteMetaDataImpl(sch);
<    }
< 
<    /**
<     * Closes the result set by closing its scan.
<     * @see simpledb.remote.RemoteResultSet#close()
<     */
<    public void close() throws RemoteException {
<       s.close();
<       rconn.commit();
<    }
< }
< 
---
> package simpledb.remote;
> 
> import simpledb.record.Schema;
> import simpledb.query.*;
> import java.rmi.RemoteException;
> import java.rmi.server.UnicastRemoteObject;
> 
> /**
>  * The RMI server-side implementation of RemoteResultSet.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> class RemoteResultSetImpl extends UnicastRemoteObject implements RemoteResultSet {
>    private Scan s;
>    private Schema sch;
>    private RemoteConnectionImpl rconn;
> 
>    /**
>     * Creates a RemoteResultSet object.
>     * The specified plan is opened, and the scan is saved.
>     * @param plan the query plan
>     * @param rconn TODO
>     * @throws RemoteException
>     */
>    public RemoteResultSetImpl(Plan plan, RemoteConnectionImpl rconn) throws RemoteException {
>       s = plan.open();
>       sch = plan.schema();
>       this.rconn = rconn;
>    }
> 
>    /**
>     * Moves to the next record in the result set,
>     * by moving to the next record in the saved scan.
>     * @see simpledb.remote.RemoteResultSet#next()
>     */
>    public boolean next() throws RemoteException {
> 		try {
> 	      return s.next();
>       }
>       catch(RuntimeException e) {
>          rconn.rollback();
>          throw e;
>       }
>    }
> 
>    /**
>     * Returns the integer value of the specified field,
>     * by returning the corresponding value on the saved scan.
>     * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
>     */
>    public int getInt(String fldname) throws RemoteException {
> 		try {
> 	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
> 	      return s.getInt(fldname);
>       }
>       catch(RuntimeException e) {
>          rconn.rollback();
>          throw e;
>       }
>    }
> 
>    /**
>     * Returns the integer value of the specified field,
>     * by returning the corresponding value on the saved scan.
>     * @see simpledb.remote.RemoteResultSet#getInt(java.lang.String)
>     */
>    public String getString(String fldname) throws RemoteException {
> 		try {
> 	      fldname = fldname.toLowerCase(); // to ensure case-insensitivity
> 	      return s.getString(fldname);
>       }
>       catch(RuntimeException e) {
>          rconn.rollback();
>          throw e;
>       }
>    }
> 
>    /**
>     * Returns the result set's metadata,
>     * by passing its schema into the RemoteMetaData constructor.
>     * @see simpledb.remote.RemoteResultSet#getMetaData()
>     */
>    public RemoteMetaData getMetaData() throws RemoteException {
>       return new RemoteMetaDataImpl(sch);
>    }
> 
>    /**
>     * Closes the result set by closing its scan.
>     * @see simpledb.remote.RemoteResultSet#close()
>     */
>    public void close() throws RemoteException {
>       s.close();
>       rconn.commit();
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteStatement.java ../cs4432-proj2/src/simpledb/remote/RemoteStatement.java
1,15c1,15
< package simpledb.remote;
< 
< import java.rmi.*;
< 
< /**
<  * The RMI remote interface corresponding to Statement.
<  * The methods are identical to those of Statement, 
<  * except that they throw RemoteExceptions instead of SQLExceptions.
<  * @author Edward Sciore
<  */
< public interface RemoteStatement extends Remote {
<    public RemoteResultSet executeQuery(String qry) throws RemoteException;
<    public int            executeUpdate(String cmd) throws RemoteException;
< }
< 
---
> package simpledb.remote;
> 
> import java.rmi.*;
> 
> /**
>  * The RMI remote interface corresponding to Statement.
>  * The methods are identical to those of Statement, 
>  * except that they throw RemoteExceptions instead of SQLExceptions.
>  * @author Edward Sciore
>  */
> public interface RemoteStatement extends Remote {
>    public RemoteResultSet executeQuery(String qry) throws RemoteException;
>    public int            executeUpdate(String cmd) throws RemoteException;
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/RemoteStatementImpl.java ../cs4432-proj2/src/simpledb/remote/RemoteStatementImpl.java
1,58c1,89
< package simpledb.remote;
< 
< import simpledb.tx.Transaction;
< import simpledb.query.Plan;
< import simpledb.server.SimpleDB;
< import java.rmi.RemoteException;
< import java.rmi.server.UnicastRemoteObject;
< 
< /**
<  * The RMI server-side implementation of RemoteStatement.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< class RemoteStatementImpl extends UnicastRemoteObject implements RemoteStatement {
<    private RemoteConnectionImpl rconn;
<    
<    public RemoteStatementImpl(RemoteConnectionImpl rconn) throws RemoteException {
<       this.rconn = rconn;
<    }
<    
<    /**
<     * Executes the specified SQL query string.
<     * The method calls the query planner to create a plan
<     * for the query. It then sends the plan to the
<     * RemoteResultSetImpl constructor for processing.
<     * @see simpledb.remote.RemoteStatement#executeQuery(java.lang.String)
<     */
<    public RemoteResultSet executeQuery(String qry) throws RemoteException {
<       try {
<          Transaction tx = rconn.getTransaction();
<          Plan pln = SimpleDB.planner().createQueryPlan(qry, tx);
<          return new RemoteResultSetImpl(pln, rconn);
<       }
<       catch(RuntimeException e) {
<          rconn.rollback();
<          throw e;
<       }
<    }
<    
<    /**
<     * Executes the specified SQL update command.
<     * The method sends the command to the update planner,
<     * which executes it.
<     * @see simpledb.remote.RemoteStatement#executeUpdate(java.lang.String)
<     */
<    public int executeUpdate(String cmd) throws RemoteException {
<       try {
<          Transaction tx = rconn.getTransaction();
<          int result = SimpleDB.planner().executeUpdate(cmd, tx);
<          rconn.commit();
<          return result;
<       }
<       catch(RuntimeException e) {
<          rconn.rollback();
<          throw e;
<       }
<    }
< }
---
> package simpledb.remote;
> 
> import java.util.logging.Level;
> 
> import simpledb.tx.Transaction;
> import simpledb.query.Plan;
> import simpledb.server.SimpleDB;
> import java.rmi.RemoteException;
> import java.rmi.server.UnicastRemoteObject;
> 
> /**
>  * The RMI server-side implementation of RemoteStatement.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> class RemoteStatementImpl extends UnicastRemoteObject implements RemoteStatement {
>    private RemoteConnectionImpl rconn;
>    
>    public RemoteStatementImpl(RemoteConnectionImpl rconn) throws RemoteException {
>       this.rconn = rconn;
>    }
>    
>     /**
>      * Executes the specified SQL query string.
>      * The method calls the query planner to create a plan
>      * for the query. It then sends the plan to the
>      * RemoteResultSetImpl constructor for processing.
>      * @see simpledb.remote.RemoteStatement#executeQuery(java.lang.String)
>      */
>     public RemoteResultSet executeQuery(String qry) throws RemoteException {
>         try {
>             // Begin performance logging
>             long initIos = SimpleDB.fileMgr().getIos();
>             long startTime = System.nanoTime();
>             
>             Transaction tx = rconn.getTransaction();
>             Plan pln = SimpleDB.planner().createQueryPlan(qry, tx);
> 
>             RemoteResultSetImpl results = new RemoteResultSetImpl(pln, rconn);
>             
>             // Report performance logging
>             float elapsedTime = ((float)(System.nanoTime() - startTime)/1000)/1000;
>             long iosDone = SimpleDB.fileMgr().getIos() - initIos;
>             SimpleDB.getLogger().log(Level.INFO, 
>                 "Query Executed" +
>                 "\n\t" + qry +
>                 "\n\tTime elapsed: " + elapsedTime + " ms" + 
>                 "\n\tIOs done: " + iosDone);
>             return results;
>         }
>         catch(RuntimeException e) {
>             rconn.rollback();
>             throw e;
>         }
>     }
>    
>     /**
>      * Executes the specified SQL update command.
>      * The method sends the command to the update planner,
>      * which executes it.
>      * @see simpledb.remote.RemoteStatement#executeUpdate(java.lang.String)
>      */
>     public int executeUpdate(String cmd) throws RemoteException {
>         try {
>             // Begin performance logging
>             long initIos = SimpleDB.fileMgr().getIos();
>             long startTime = System.nanoTime();
> 
>             Transaction tx = rconn.getTransaction();
>             int result = SimpleDB.planner().executeUpdate(cmd, tx);
>             rconn.commit();
>             
>             // Report performance logging
>             float elapsedTime = ((float)(System.nanoTime() - startTime)/1000)/1000;
>             long iosDone = SimpleDB.fileMgr().getIos() - initIos;
>             SimpleDB.getLogger().log(Level.INFO, 
>                 "Update Executed" +
>                 "\n\t" + cmd +
>                 "\n\tTime elapsed: " + elapsedTime + " ms" + 
>                 "\n\tIOs done: " + iosDone);
>             
>             return result;
>         }
>         catch(RuntimeException e) {
>             rconn.rollback();
>             throw e;
>         }
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/ResultSetAdapter.java ../cs4432-proj2/src/simpledb/remote/ResultSetAdapter.java
1,780c1,780
< package simpledb.remote;
< 
< import java.sql.*;
< import java.util.Map;
< import java.util.Calendar;
< import java.io.*;
< import java.math.BigDecimal;
< import java.net.URL;
< 
< /**
<  * This class implements all of the methods of the ResultSet interface,
<  * by throwing an exception for each one.
<  * Subclasses (such as SimpleResultSet) can override those methods that 
<  * it want to implement.
<  * @author Edward Sciore
<  */
< public abstract class ResultSetAdapter implements ResultSet {
<    public boolean absolute(int row) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void afterLast() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void beforeFirst() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void cancelRowUpdates() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void clearWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void close() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void deleteRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int findColumn(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean first() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Array getArray(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Array getArray(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getAsciiStream(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getAsciiStream(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getBinaryStream(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getBinaryStream(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Blob getBlob(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Blob getBlob(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean getBoolean(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean getBoolean(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public byte getByte(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public byte getByte(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public byte[] getBytes(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public byte[] getBytes(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Reader getCharacterStream(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Reader getCharacterStream(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Clob getClob(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Clob getClob(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getConcurrency() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getCursorName() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Date getDate(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Date getDate(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Date getDate(int columnIndex, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Date getDate(String columnLabel, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public double getDouble(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public double getDouble(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getFetchDirection() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getFetchSize() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public float getFloat(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public float getFloat(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getHoldability() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getInt(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getInt(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public long getLong(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public long getLong(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public ResultSetMetaData getMetaData() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Reader getNCharacterStream(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Reader getNCharacterStream(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public NClob getNClob(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public NClob getNClob(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getNString(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getNString(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Object getObject(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Object getObject(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Object getObject(int columnIndex, Map<String,Class<?>> map) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Object getObject(String columnLabel, Map<String,Class<?>> map) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Ref getRef(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Ref getRef(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public RowId getRowId(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public RowId getRowId(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public short getShort(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public short getShort(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLXML getSQLXML(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLXML getSQLXML(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Statement getStatement() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getString(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getString(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Time getTime(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Time getTime(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Time getTime(int columnIndex, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Time getTime(String columnLabel, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Timestamp getTimestamp(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Timestamp getTimestamp(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getType() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getUnicodeStream(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public InputStream getUnicodeStream(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public URL getURL(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public URL getURL(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLWarning getWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void insertRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isAfterLast() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isBeforeFirst() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isClosed() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isFirst() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isLast() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean last() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void moveToCurrentRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void moveToInsertRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean next() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean previous() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void refreshRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean relative(int rows) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean rowDeleted() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean rowInserted() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean rowUpdated() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setFetchDirection(int direction) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setFetchSize(int rows) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateArray(int columnIndex, Array x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateArray(String columnLabel, Array x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(int columnIndex, Blob x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(String columnLabel, Blob x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBoolean(int columnIndex, boolean x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBoolean(String columnLabel, boolean x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateByte(int columnIndex, byte x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateByte(String columnLabel, byte x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBytes(int columnIndex, byte[] x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateBytes(String columnLabel, byte[] x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(String columnLabel, Reader x, int length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(int columnIndex, Clob x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(String columnLabel, Clob x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(int columnIndex, Reader reader) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(String columnLabel, Reader reader) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateDate(int columnIndex, Date x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateDate(String columnLabel, Date x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateDouble(int columnIndex, double x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateDouble(String columnLabel, double x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateFloat(int columnIndex, float x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateFloat(String columnLabel, float x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateInt(int columnIndex, int x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateInt(String columnLabel, int x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateLong(int columnIndex, long x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateLong(String columnLabel, long x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(int columnIndex, Reader reader) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(String columnLabel, Reader reader) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNString(int columnIndex, String nstring) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNString(String columnLabel, String nstring) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNull(int columnIndex) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateNull(String columnLabel) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateObject(int columnIndex, Object x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateObject(String columnLabel, Object x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateObject(String columnLabel, Object x, int scale) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateRef(int columnIndex, Ref x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateRef(String columnLabel, Ref x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateRow() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateRowId(int columnIndex, RowId x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateRowId(String columnLabel, RowId x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateShort(int columnIndex, short x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateShort(String columnLabel, short x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateString(int columnIndex, String x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateString(String columnLabel, String x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateTime(int columnIndex, Time x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateTime(String columnLabel, Time x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean wasNull() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isWrapperFor(Class<?> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T unwrap(Class<T> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
---
> package simpledb.remote;
> 
> import java.sql.*;
> import java.util.Map;
> import java.util.Calendar;
> import java.io.*;
> import java.math.BigDecimal;
> import java.net.URL;
> 
> /**
>  * This class implements all of the methods of the ResultSet interface,
>  * by throwing an exception for each one.
>  * Subclasses (such as SimpleResultSet) can override those methods that 
>  * it want to implement.
>  * @author Edward Sciore
>  */
> public abstract class ResultSetAdapter implements ResultSet {
>    public boolean absolute(int row) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void afterLast() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void beforeFirst() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void cancelRowUpdates() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void clearWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void close() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void deleteRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int findColumn(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean first() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Array getArray(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Array getArray(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getAsciiStream(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getAsciiStream(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getBinaryStream(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getBinaryStream(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Blob getBlob(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Blob getBlob(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean getBoolean(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean getBoolean(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public byte getByte(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public byte getByte(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public byte[] getBytes(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public byte[] getBytes(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Reader getCharacterStream(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Reader getCharacterStream(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Clob getClob(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Clob getClob(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getConcurrency() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getCursorName() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Date getDate(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Date getDate(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Date getDate(int columnIndex, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Date getDate(String columnLabel, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public double getDouble(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public double getDouble(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getFetchDirection() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getFetchSize() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public float getFloat(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public float getFloat(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getHoldability() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getInt(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getInt(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public long getLong(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public long getLong(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public ResultSetMetaData getMetaData() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Reader getNCharacterStream(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Reader getNCharacterStream(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public NClob getNClob(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public NClob getNClob(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getNString(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getNString(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Object getObject(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Object getObject(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Object getObject(int columnIndex, Map<String,Class<?>> map) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Object getObject(String columnLabel, Map<String,Class<?>> map) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Ref getRef(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Ref getRef(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public RowId getRowId(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public RowId getRowId(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public short getShort(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public short getShort(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLXML getSQLXML(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLXML getSQLXML(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Statement getStatement() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getString(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getString(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Time getTime(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Time getTime(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Time getTime(int columnIndex, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Time getTime(String columnLabel, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Timestamp getTimestamp(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Timestamp getTimestamp(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getType() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getUnicodeStream(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public InputStream getUnicodeStream(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public URL getURL(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public URL getURL(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLWarning getWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void insertRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isAfterLast() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isBeforeFirst() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isClosed() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isFirst() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isLast() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean last() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void moveToCurrentRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void moveToInsertRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean next() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean previous() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void refreshRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean relative(int rows) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean rowDeleted() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean rowInserted() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean rowUpdated() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setFetchDirection(int direction) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setFetchSize(int rows) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateArray(int columnIndex, Array x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateArray(String columnLabel, Array x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(int columnIndex, Blob x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(String columnLabel, Blob x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBoolean(int columnIndex, boolean x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBoolean(String columnLabel, boolean x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateByte(int columnIndex, byte x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateByte(String columnLabel, byte x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBytes(int columnIndex, byte[] x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateBytes(String columnLabel, byte[] x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(String columnLabel, Reader x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(String columnLabel, Reader x, int length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(int columnIndex, Clob x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(String columnLabel, Clob x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(int columnIndex, Reader reader) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(String columnLabel, Reader reader) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateDate(int columnIndex, Date x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateDate(String columnLabel, Date x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateDouble(int columnIndex, double x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateDouble(String columnLabel, double x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateFloat(int columnIndex, float x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateFloat(String columnLabel, float x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateInt(int columnIndex, int x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateInt(String columnLabel, int x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateLong(int columnIndex, long x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateLong(String columnLabel, long x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNCharacterStream(String columnLabel, Reader x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNCharacterStream(String columnLabel, Reader x, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(int columnIndex, NClob nclob) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(String columnLabel, NClob nclob) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(int columnIndex, Reader reader) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(String columnLabel, Reader reader) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNString(int columnIndex, String nstring) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNString(String columnLabel, String nstring) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNull(int columnIndex) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateNull(String columnLabel) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateObject(int columnIndex, Object x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateObject(String columnLabel, Object x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateObject(String columnLabel, Object x, int scale) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateRef(int columnIndex, Ref x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateRef(String columnLabel, Ref x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateRow() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateRowId(int columnIndex, RowId x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateRowId(String columnLabel, RowId x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateShort(int columnIndex, short x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateShort(String columnLabel, short x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateSQLXML(int columnIndex, SQLXML x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateString(int columnIndex, String x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateString(String columnLabel, String x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateTime(int columnIndex, Time x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateTime(String columnLabel, Time x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean wasNull() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isWrapperFor(Class<?> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T unwrap(Class<T> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/ResultSetMetaDataAdapter.java ../cs4432-proj2/src/simpledb/remote/ResultSetMetaDataAdapter.java
1,103c1,103
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * This class implements all of the methods of the ResultSetMetaData interface,
<  * by throwing an exception for each one.
<  * Subclasses (such as SimpleMetaData) can override those methods that 
<  * it want to implement.
<  * @author Edward Sciore
<  */
< public abstract class ResultSetMetaDataAdapter implements ResultSetMetaData {
<    public String getCatalogName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getColumnClassName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getColumnCount() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getColumnDisplaySize(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getColumnLabel(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getColumnName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getColumnType(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getColumnTypeName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getPrecision(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getScale(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getSchemaName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public String getTableName(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isAutoIncrement(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isCaseSensitive(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isCurrency(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isDefinitelyWritable(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int isNullable(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isReadOnly(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isSearchable(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isSigned(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isWritable(int column) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isWrapperFor(Class<?> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T unwrap(Class<T> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * This class implements all of the methods of the ResultSetMetaData interface,
>  * by throwing an exception for each one.
>  * Subclasses (such as SimpleMetaData) can override those methods that 
>  * it want to implement.
>  * @author Edward Sciore
>  */
> public abstract class ResultSetMetaDataAdapter implements ResultSetMetaData {
>    public String getCatalogName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getColumnClassName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getColumnCount() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getColumnDisplaySize(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getColumnLabel(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getColumnName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getColumnType(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getColumnTypeName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getPrecision(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getScale(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getSchemaName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public String getTableName(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isAutoIncrement(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isCaseSensitive(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isCurrency(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isDefinitelyWritable(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int isNullable(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isReadOnly(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isSearchable(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isSigned(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isWritable(int column) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isWrapperFor(Class<?> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T unwrap(Class<T> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/SimpleConnection.java ../cs4432-proj2/src/simpledb/remote/SimpleConnection.java
1,37c1,37
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * An adapter class that wraps RemoteConnection.
<  * Its methods do nothing except transform RemoteExceptions
<  * into SQLExceptions.
<  * @author Edward Sciore
<  */
< public class SimpleConnection extends ConnectionAdapter {
<    private RemoteConnection rconn;
<    
<    public SimpleConnection(RemoteConnection c) {
<       rconn = c;
<    }
<    
<    public Statement createStatement() throws SQLException {
<       try {
<          RemoteStatement rstmt = rconn.createStatement();
<          return new SimpleStatement(rstmt);
<       }
<       catch(Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public void close() throws SQLException {
<       try {
<          rconn.close();
<       }
<       catch(Exception e) {
<          throw new SQLException(e);
<       }
<    }
< }
< 
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * An adapter class that wraps RemoteConnection.
>  * Its methods do nothing except transform RemoteExceptions
>  * into SQLExceptions.
>  * @author Edward Sciore
>  */
> public class SimpleConnection extends ConnectionAdapter {
>    private RemoteConnection rconn;
>    
>    public SimpleConnection(RemoteConnection c) {
>       rconn = c;
>    }
>    
>    public Statement createStatement() throws SQLException {
>       try {
>          RemoteStatement rstmt = rconn.createStatement();
>          return new SimpleStatement(rstmt);
>       }
>       catch(Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public void close() throws SQLException {
>       try {
>          rconn.close();
>       }
>       catch(Exception e) {
>          throw new SQLException(e);
>       }
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/SimpleDriver.java ../cs4432-proj2/src/simpledb/remote/SimpleDriver.java
1,39c1,39
< package simpledb.remote;
< 
< import java.sql.*;
< import java.rmi.registry.*;
< import java.util.Properties;
< 
< /**
<  * The SimpleDB database driver.
<  * @author Edward Sciore
<  */
< public class SimpleDriver extends DriverAdapter {
<    
<    /**
<     * Connects to the SimpleDB server on the specified host.
<     * The method retrieves the RemoteDriver stub from
<     * the RMI registry on the specified host.
<     * It then calls the connect method on that stub,
<     * which in turn creates a new connection and
<     * returns the RemoteConnection stub for it.
<     * This stub is wrapped in a SimpleConnection object
<     * and is returned. 
<     * <P>
<     * The current implementation of this method ignores the 
<     * properties argument.
<     * @see java.sql.Driver#connect(java.lang.String, Properties)
<     */
<    public Connection connect(String url, Properties prop) throws SQLException {
<       try {
<          String host = url.replace("jdbc:simpledb://", "");  //assumes no port specified
<          Registry reg = LocateRegistry.getRegistry(host);
<          RemoteDriver rdvr = (RemoteDriver) reg.lookup("simpledb");
<          RemoteConnection rconn = rdvr.connect();
<          return new SimpleConnection(rconn);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
< }
---
> package simpledb.remote;
> 
> import java.sql.*;
> import java.rmi.registry.*;
> import java.util.Properties;
> 
> /**
>  * The SimpleDB database driver.
>  * @author Edward Sciore
>  */
> public class SimpleDriver extends DriverAdapter {
>    
>    /**
>     * Connects to the SimpleDB server on the specified host.
>     * The method retrieves the RemoteDriver stub from
>     * the RMI registry on the specified host.
>     * It then calls the connect method on that stub,
>     * which in turn creates a new connection and
>     * returns the RemoteConnection stub for it.
>     * This stub is wrapped in a SimpleConnection object
>     * and is returned. 
>     * <P>
>     * The current implementation of this method ignores the 
>     * properties argument.
>     * @see java.sql.Driver#connect(java.lang.String, Properties)
>     */
>    public Connection connect(String url, Properties prop) throws SQLException {
>       try {
>          String host = url.replace("jdbc:simpledb://", "");  //assumes no port specified
>          Registry reg = LocateRegistry.getRegistry(host);
>          RemoteDriver rdvr = (RemoteDriver) reg.lookup("simpledb");
>          RemoteConnection rconn = rdvr.connect();
>          return new SimpleConnection(rconn);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/remote/SimpleMetaData.java ../cs4432-proj2/src/simpledb/remote/SimpleMetaData.java
1,54c1,54
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * An adapter class that wraps RemoteMetaData.
<  * Its methods do nothing except transform RemoteExceptions
<  * into SQLExceptions.
<  * @author Edward Sciore
<  */
< public class SimpleMetaData extends ResultSetMetaDataAdapter {
<    private RemoteMetaData rmd;
<    
<    public SimpleMetaData(RemoteMetaData md) {
<       rmd = md;
<    }
<    
<    public int getColumnCount() throws SQLException {
<       try {
<          return rmd.getColumnCount();
<       }
<       catch(Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public String getColumnName(int column) throws SQLException {
<       try {
<          return rmd.getColumnName(column);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public int getColumnType(int column) throws SQLException {
<       try {
<          return rmd.getColumnType(column);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public int getColumnDisplaySize(int column) throws SQLException {
<       try {
<          return rmd.getColumnDisplaySize(column);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
< }
< 
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * An adapter class that wraps RemoteMetaData.
>  * Its methods do nothing except transform RemoteExceptions
>  * into SQLExceptions.
>  * @author Edward Sciore
>  */
> public class SimpleMetaData extends ResultSetMetaDataAdapter {
>    private RemoteMetaData rmd;
>    
>    public SimpleMetaData(RemoteMetaData md) {
>       rmd = md;
>    }
>    
>    public int getColumnCount() throws SQLException {
>       try {
>          return rmd.getColumnCount();
>       }
>       catch(Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public String getColumnName(int column) throws SQLException {
>       try {
>          return rmd.getColumnName(column);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public int getColumnType(int column) throws SQLException {
>       try {
>          return rmd.getColumnType(column);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public int getColumnDisplaySize(int column) throws SQLException {
>       try {
>          return rmd.getColumnDisplaySize(column);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/SimpleResultSet.java ../cs4432-proj2/src/simpledb/remote/SimpleResultSet.java
1,64c1,64
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * An adapter class that wraps RemoteResultSet.
<  * Its methods do nothing except transform RemoteExceptions
<  * into SQLExceptions.
<  * @author Edward Sciore
<  */
< public class SimpleResultSet extends ResultSetAdapter {
<    private RemoteResultSet rrs;
<    
<    public SimpleResultSet(RemoteResultSet s) {
<       rrs = s;
<    }
<    
<    public boolean next() throws SQLException {
<       try {
<          return rrs.next();
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public int getInt(String fldname) throws SQLException {
<       try {
<          return rrs.getInt(fldname);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public String getString(String fldname) throws SQLException {
<       try {
<          return rrs.getString(fldname);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public ResultSetMetaData getMetaData() throws SQLException {
<       try {
<          RemoteMetaData rmd = rrs.getMetaData();
<          return new SimpleMetaData(rmd);
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public void close() throws SQLException {
<       try {
<          rrs.close();
<       }
<       catch (Exception e) {
<          throw new SQLException(e);
<       }
<    }
< }
< 
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * An adapter class that wraps RemoteResultSet.
>  * Its methods do nothing except transform RemoteExceptions
>  * into SQLExceptions.
>  * @author Edward Sciore
>  */
> public class SimpleResultSet extends ResultSetAdapter {
>    private RemoteResultSet rrs;
>    
>    public SimpleResultSet(RemoteResultSet s) {
>       rrs = s;
>    }
>    
>    public boolean next() throws SQLException {
>       try {
>          return rrs.next();
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public int getInt(String fldname) throws SQLException {
>       try {
>          return rrs.getInt(fldname);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public String getString(String fldname) throws SQLException {
>       try {
>          return rrs.getString(fldname);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public ResultSetMetaData getMetaData() throws SQLException {
>       try {
>          RemoteMetaData rmd = rrs.getMetaData();
>          return new SimpleMetaData(rmd);
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public void close() throws SQLException {
>       try {
>          rrs.close();
>       }
>       catch (Exception e) {
>          throw new SQLException(e);
>       }
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/SimpleStatement.java ../cs4432-proj2/src/simpledb/remote/SimpleStatement.java
1,37c1,37
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * An adapter class that wraps RemoteStatement.
<  * Its methods do nothing except transform RemoteExceptions
<  * into SQLExceptions.
<  * @author Edward Sciore
<  */
< public class SimpleStatement extends StatementAdapter {
<    private RemoteStatement rstmt;
<    
<    public SimpleStatement(RemoteStatement s) {
<       rstmt = s;
<    }
<    
<    public ResultSet executeQuery(String qry) throws SQLException {
<       try {
<          RemoteResultSet rrs = rstmt.executeQuery(qry);
<          return new SimpleResultSet(rrs);
<       }
<       catch(Exception e) {
<          throw new SQLException(e);
<       }
<    }
<    
<    public int executeUpdate(String cmd) throws SQLException {
<       try {
<          return rstmt.executeUpdate(cmd);
<       }
<       catch(Exception e) {
<          throw new SQLException(e);
<       }
<    }
< }
< 
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * An adapter class that wraps RemoteStatement.
>  * Its methods do nothing except transform RemoteExceptions
>  * into SQLExceptions.
>  * @author Edward Sciore
>  */
> public class SimpleStatement extends StatementAdapter {
>    private RemoteStatement rstmt;
>    
>    public SimpleStatement(RemoteStatement s) {
>       rstmt = s;
>    }
>    
>    public ResultSet executeQuery(String qry) throws SQLException {
>       try {
>          RemoteResultSet rrs = rstmt.executeQuery(qry);
>          return new SimpleResultSet(rrs);
>       }
>       catch(Exception e) {
>          throw new SQLException(e);
>       }
>    }
>    
>    public int executeUpdate(String cmd) throws SQLException {
>       try {
>          return rstmt.executeUpdate(cmd);
>       }
>       catch(Exception e) {
>          throw new SQLException(e);
>       }
>    }
> }
> 
diff -r simpledb/SimpleDB_2.10/simpledb/remote/StatementAdapter.java ../cs4432-proj2/src/simpledb/remote/StatementAdapter.java
1,184c1,184
< package simpledb.remote;
< 
< import java.sql.*;
< 
< /**
<  * This class implements all of the methods of the Statement interface,
<  * by throwing an exception for each one.
<  * Subclasses (such as SimpleStatement) can override those methods that 
<  * it want to implement.
<  * @author Edward Sciore
<  */
< public abstract class StatementAdapter implements Statement {
<    public void addBatch(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void cancel() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void clearBatch() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void clearWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void close() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean execute(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean execute(String sql, String[] columnNames) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int[] executeBatch() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public ResultSet executeQuery(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int executeUpdate(String sql) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public Connection getConnection() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getFetchDirection() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getFetchSize() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public ResultSet getGeneratedKeys() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getMaxFieldSize() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getMaxRows() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean getMoreResults() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean getMoreResults(int current) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getQueryTimeout() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public ResultSet getResultSet() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getResultSetConcurrency() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getResultSetHoldability() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getResultSetType() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public int getUpdateCount() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public SQLWarning getWarnings() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isClosed() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isPoolable() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setCursorName(String name) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setEscapeProcessing(boolean enable) {
<    }
<    
<    public void setFetchDirection(int direction) {
<    }
<    
<    public void setFetchSize(int rows) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setMaxFieldSize(int max) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setMaxRows(int max) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setPoolable(boolean poolable) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void setQueryTimeout(int seconds) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    public boolean isWrapperFor(Class<?> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public <T> T unwrap(Class<T> iface) throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public void closeOnCompletion() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
<    
<    public boolean isCloseOnCompletion() throws SQLException {
<       throw new SQLException("operation not implemented");
<    }
---
> package simpledb.remote;
> 
> import java.sql.*;
> 
> /**
>  * This class implements all of the methods of the Statement interface,
>  * by throwing an exception for each one.
>  * Subclasses (such as SimpleStatement) can override those methods that 
>  * it want to implement.
>  * @author Edward Sciore
>  */
> public abstract class StatementAdapter implements Statement {
>    public void addBatch(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void cancel() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void clearBatch() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void clearWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void close() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean execute(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean execute(String sql, String[] columnNames) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int[] executeBatch() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public ResultSet executeQuery(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int executeUpdate(String sql) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public Connection getConnection() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getFetchDirection() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getFetchSize() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public ResultSet getGeneratedKeys() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getMaxFieldSize() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getMaxRows() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean getMoreResults() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean getMoreResults(int current) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getQueryTimeout() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public ResultSet getResultSet() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getResultSetConcurrency() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getResultSetHoldability() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getResultSetType() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public int getUpdateCount() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public SQLWarning getWarnings() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isClosed() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isPoolable() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setCursorName(String name) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setEscapeProcessing(boolean enable) {
>    }
>    
>    public void setFetchDirection(int direction) {
>    }
>    
>    public void setFetchSize(int rows) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setMaxFieldSize(int max) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setMaxRows(int max) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setPoolable(boolean poolable) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void setQueryTimeout(int seconds) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    public boolean isWrapperFor(Class<?> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public <T> T unwrap(Class<T> iface) throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public void closeOnCompletion() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
>    
>    public boolean isCloseOnCompletion() throws SQLException {
>       throw new SQLException("operation not implemented");
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/server/SimpleDB.java ../cs4432-proj2/src/simpledb/server/SimpleDB.java
1,107c1,202
< package simpledb.server;
< 
< import simpledb.file.FileMgr;
< import simpledb.buffer.*;
< import simpledb.tx.Transaction;
< import simpledb.log.LogMgr;
< import simpledb.metadata.MetadataMgr;
< import simpledb.planner.*;
< import simpledb.opt.HeuristicQueryPlanner;
< import simpledb.index.planner.IndexUpdatePlanner;
< 
< /**
<  * The class that provides system-wide static global values.
<  * These values must be initialized by the method
<  * {@link #init(String) init} before use.
<  * The methods {@link #initFileMgr(String) initFileMgr},
<  * {@link #initFileAndLogMgr(String) initFileAndLogMgr},
<  * {@link #initFileLogAndBufferMgr(String) initFileLogAndBufferMgr},
<  * and {@link #initMetadataMgr(boolean, Transaction) initMetadataMgr}
<  * provide limited initialization, and are useful for 
<  * debugging purposes.
<  * 
<  * @author Edward Sciore
<  */
< public class SimpleDB {
<    public static int BUFFER_SIZE = 8;
<    public static String LOG_FILE = "simpledb.log";
<    
<    private static FileMgr     fm;
<    private static BufferMgr   bm;
<    private static LogMgr      logm;
<    private static MetadataMgr mdm;
<    
<    /**
<     * Initializes the system.
<     * This method is called during system startup.
<     * @param dirname the name of the database directory
<     */
<    public static void init(String dirname) {
<       initFileLogAndBufferMgr(dirname);
<       Transaction tx = new Transaction();
<       boolean isnew = fm.isNew();
<       if (isnew)
<          System.out.println("creating new database");
<       else {
<          System.out.println("recovering existing database");
<          tx.recover();
<       }
<       initMetadataMgr(isnew, tx);
<       tx.commit();
<    }
<    
<    // The following initialization methods are useful for 
<    // testing the lower-level components of the system 
<    // without having to initialize everything.
<    
<    /**
<     * Initializes only the file manager.
<     * @param dirname the name of the database directory
<     */
<    public static void initFileMgr(String dirname) {
<       fm = new FileMgr(dirname);
<    }
<    
<    /**
<     * Initializes the file and log managers.
<     * @param dirname the name of the database directory
<     */
<    public static void initFileAndLogMgr(String dirname) {
<       initFileMgr(dirname);
<       logm = new LogMgr(LOG_FILE);
<    }
<    
<    /**
<     * Initializes the file, log, and buffer managers.
<     * @param dirname the name of the database directory
<     */
<    public static void initFileLogAndBufferMgr(String dirname) {
<       initFileAndLogMgr(dirname);
<       bm = new BufferMgr(BUFFER_SIZE);
<    }
<    
<    /**
<     * Initializes metadata manager.
<     * @param isnew an indication of whether a new
<     * database needs to be created.
<     * @param tx the transaction performing the initialization
<     */
<    public static void initMetadataMgr(boolean isnew, Transaction tx) {
<       mdm = new MetadataMgr(isnew, tx);
<    }
<    
<    public static FileMgr     fileMgr()   { return fm; }
<    public static BufferMgr   bufferMgr() { return bm; }
<    public static LogMgr      logMgr()    { return logm; }
<    public static MetadataMgr mdMgr()     { return mdm; }
<    
<    /**
<     * Creates a planner for SQL commands.
<     * To change how the planner works, modify this method.
<     * @return the system's planner for SQL commands
<     */public static Planner planner() {
<       QueryPlanner  qplanner = new BasicQueryPlanner();
<       UpdatePlanner uplanner = new BasicUpdatePlanner();
<       return new Planner(qplanner, uplanner);
<    }
< }
---
> package simpledb.server;
> 
> import java.util.logging.FileHandler;
> import java.util.logging.Level;
> import java.util.logging.Logger;
> import java.util.logging.SimpleFormatter;
> 
> import simpledb.buffer.BufferMgr;
> import simpledb.file.FileMgr;
> import simpledb.index.planner.IndexUpdatePlanner;
> import simpledb.log.LogMgr;
> import simpledb.metadata.MetadataMgr;
> import simpledb.opt.HeuristicQueryPlanner;
> import simpledb.planner.BasicQueryPlanner;
> import simpledb.planner.ExploitSortQueryPlanner;
> import simpledb.planner.Planner;
> import simpledb.planner.QueryPlanner;
> import simpledb.planner.SortQueryPlanner;
> import simpledb.planner.UpdatePlanner;
> import simpledb.tx.Transaction;
> 
> /**
>  * The class that provides system-wide static global values. These values must
>  * be initialized by the method {@link #init(String) init} before use. The
>  * methods {@link #initFileMgr(String) initFileMgr},
>  * {@link #initFileAndLogMgr(String) initFileAndLogMgr},
>  * {@link #initFileLogAndBufferMgr(String) initFileLogAndBufferMgr}, and
>  * {@link #initMetadataMgr(boolean, Transaction) initMetadataMgr} provide
>  * limited initialization, and are useful for debugging purposes.
>  *
>  * @author Edward Sciore
>  */
> public class SimpleDB {
>     public static int BUFFER_SIZE = 32;
>     public static String LOG_FILE = "simpledb.log";
> 
>     public static String LOG_CS4432 = "cs4432.log";
> 
>     private static FileMgr fm;
>     private static BufferMgr bm;
>     private static LogMgr logm;
>     private static MetadataMgr mdm;
> 
>     private static String queryPlanner;
> 
>     // CS 4432 Project 2
>     // Logger for log file output
>     private static Logger logger;
> 
>     /**
>      * Passthrough
>      *
>      * @param dirname
>      *            the name of the database directory
>      */
>     public static void init(String dirname) {
>         init(dirname, "");
>     }
> 
>     /**
>      * Initializes the system. This method is called during system startup.
>      *
>      * @param dirname
>      *            the name of the database directory
>      * @param initQueryPlanner
>      *            The query planner to use
>      */
>     public static void init(String dirname, String initQueryPlanner) {
>         queryPlanner = initQueryPlanner;
> 
>         initFileLogAndBufferMgr(dirname);
>         Transaction tx = new Transaction();
>         boolean isnew = fm.isNew();
>         if (isnew)
>             System.out.println("creating new database");
>         else {
>             System.out.println("recovering existing database");
>             tx.recover();
>         }
>         initMetadataMgr(isnew, tx);
>         tx.commit();
>     }
> 
>     /**
>      * CS 4432 Project 1
>      *
>      * Returns the global SimpleDB file logger.
>      *
>      * @return a Logger
>      */
>     public static Logger getLogger() {
>         return logger;
>     }
> 
>     // The following initialization methods are useful for
>     // testing the lower-level components of the system
>     // without having to initialize everything.
> 
>     /**
>      * Initializes only the file manager.
>      *
>      * @param dirname
>      *            the name of the database directory
>      */
>     public static void initFileMgr(String dirname) {
>         fm = new FileMgr(dirname);
>     }
> 
>     /**
>      * Initializes the file and log managers.
>      *
>      * @param dirname
>      *            the name of the database directory
>      */
>     public static void initFileAndLogMgr(String dirname) {
>         initFileMgr(dirname);
>         logm = new LogMgr(LOG_FILE);
> 
>         // CS 4432 Project 2
>         // Added our own log file logging handlers
>         try {
>             FileHandler logFileHandler = new FileHandler(LOG_CS4432);
>             logFileHandler.setLevel(Level.ALL);
> 
>             SimpleFormatter simpleFormatter = new SimpleFormatter();
>             logFileHandler.setFormatter(simpleFormatter);
> 
>             logger = Logger.getGlobal();
>             logger.setUseParentHandlers(false);
> 
>             logger.addHandler(logFileHandler);
>         } catch (Exception e) {
>             e.printStackTrace();
>         }
> 
>     }
> 
>     /**
>      * Initializes the file, log, and buffer managers.
>      *
>      * @param dirname
>      *            the name of the database directory
>      */
>     public static void initFileLogAndBufferMgr(String dirname) {
>         initFileAndLogMgr(dirname);
>         bm = new BufferMgr(BUFFER_SIZE);
>     }
> 
>     /**
>      * Initializes metadata manager.
>      *
>      * @param isnew
>      *            an indication of whether a new database needs to be created.
>      * @param tx
>      *            the transaction performing the initialization
>      */
>     public static void initMetadataMgr(boolean isnew, Transaction tx) {
>         mdm = new MetadataMgr(isnew, tx);
>     }
> 
>     public static FileMgr fileMgr() {
>         return fm;
>     }
> 
>     public static BufferMgr bufferMgr() {
>         return bm;
>     }
> 
>     public static LogMgr logMgr() {
>         return logm;
>     }
> 
>     public static MetadataMgr mdMgr() {
>         return mdm;
>     }
> 
>     /**
>      * CS 4432 Project 2
>      *
>      * We modified the planner to return a HeuristicQueryPlanner and
>      * IndexUpdatePlanner instead of the basic ones.
>      *
>      * Creates a planner for SQL commands. To change how the planner works,
>      * modify this method.
>      *
>      * @return the system's planner for SQL commands
>      */
>     public static Planner planner() {
>         QueryPlanner qplanner;
>         if (queryPlanner.equals("smart")) {
>             qplanner = new ExploitSortQueryPlanner();
>         } else if (queryPlanner.equals("heuristic")) {
>             qplanner = new HeuristicQueryPlanner();
>         } else if (queryPlanner.equals("sort")) {
>             qplanner = new SortQueryPlanner();
>         } else {
>             qplanner = new BasicQueryPlanner();
>         }
>         UpdatePlanner uplanner = new IndexUpdatePlanner();
>         return new Planner(qplanner, uplanner);
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/server/Startup.java ../cs4432-proj2/src/simpledb/server/Startup.java
1,20c1,24
< package simpledb.server;
< 
< import simpledb.remote.*;
< import java.rmi.registry.*;
< 
< public class Startup {
<    public static void main(String args[]) throws Exception {
<       // configure and initialize the database
<       SimpleDB.init(args[0]);
<       
<       // create a registry specific for the server on the default port
<       Registry reg = LocateRegistry.createRegistry(1099);
<       
<       // and post the server entry in it
<       RemoteDriver d = new RemoteDriverImpl();
<       reg.rebind("simpledb", d);
<       
<       System.out.println("database server ready");
<    }
< }
---
> package simpledb.server;
> 
> import simpledb.remote.*;
> import java.rmi.registry.*;
> 
> public class Startup {
>     public static void main(String args[]) throws Exception {
>         // configure and initialize the database
>         if (args.length > 1) {
>             SimpleDB.init(args[0], args[1]);
>         } else {
>             SimpleDB.init(args[0]);
>         }
>        
>         // create a registry specific for the server on the default port
>         Registry reg = LocateRegistry.createRegistry(1099);
>        
>         // and post the server entry in it
>         RemoteDriver d = new RemoteDriverImpl();
>         reg.rebind("simpledb", d);
>        
>         System.out.println("database server ready");
>     }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/BufferList.java ../cs4432-proj2/src/simpledb/tx/BufferList.java
1,75c1,75
< package simpledb.tx;
< 
< import simpledb.server.SimpleDB;
< import simpledb.file.Block;
< import simpledb.buffer.*;
< import java.util.*;
< 
< /**
<  * Manages the transaction's currently-pinned buffers. 
<  * @author Edward Sciore
<  */
< class BufferList {
<    private Map<Block,Buffer> buffers = new HashMap<Block,Buffer>();
<    private List<Block> pins = new ArrayList<Block>();
<    private BufferMgr bufferMgr = SimpleDB.bufferMgr();
<    
<    /**
<     * Returns the buffer pinned to the specified block.
<     * The method returns null if the transaction has not
<     * pinned the block.
<     * @param blk a reference to the disk block
<     * @return the buffer pinned to that block
<     */
<    Buffer getBuffer(Block blk) {
<       return buffers.get(blk);
<    }
<    
<    /**
<     * Pins the block and keeps track of the buffer internally.
<     * @param blk a reference to the disk block
<     */
<    void pin(Block blk) {
<       Buffer buff = bufferMgr.pin(blk);
<       buffers.put(blk, buff);
<       pins.add(blk);
<    }
<    
<    /**
<     * Appends a new block to the specified file
<     * and pins it.
<     * @param filename the name of the file
<     * @param fmtr the formatter used to initialize the new page
<     * @return a reference to the newly-created block
<     */
<    Block pinNew(String filename, PageFormatter fmtr) {
<       Buffer buff = bufferMgr.pinNew(filename, fmtr);
<       Block blk = buff.block();
<       buffers.put(blk, buff);
<       pins.add(blk);
<       return blk;
<    }
<    
<    /**
<     * Unpins the specified block.
<     * @param blk a reference to the disk block
<     */
<    void unpin(Block blk) {
<       Buffer buff = buffers.get(blk);
<       bufferMgr.unpin(buff);
<       pins.remove(blk);
<       if (!pins.contains(blk))
<          buffers.remove(blk);
<    }
<    
<    /**
<     * Unpins any buffers still pinned by this transaction.
<     */
<    void unpinAll() {
<       for (Block blk : pins) {
<          Buffer buff = buffers.get(blk);
<          bufferMgr.unpin(buff);
<       }
<       buffers.clear();
<       pins.clear();
<    }
---
> package simpledb.tx;
> 
> import simpledb.server.SimpleDB;
> import simpledb.file.Block;
> import simpledb.buffer.*;
> import java.util.*;
> 
> /**
>  * Manages the transaction's currently-pinned buffers. 
>  * @author Edward Sciore
>  */
> class BufferList {
>    private Map<Block,Buffer> buffers = new HashMap<Block,Buffer>();
>    private List<Block> pins = new ArrayList<Block>();
>    private BufferMgr bufferMgr = SimpleDB.bufferMgr();
>    
>    /**
>     * Returns the buffer pinned to the specified block.
>     * The method returns null if the transaction has not
>     * pinned the block.
>     * @param blk a reference to the disk block
>     * @return the buffer pinned to that block
>     */
>    Buffer getBuffer(Block blk) {
>       return buffers.get(blk);
>    }
>    
>    /**
>     * Pins the block and keeps track of the buffer internally.
>     * @param blk a reference to the disk block
>     */
>    void pin(Block blk) {
>       Buffer buff = bufferMgr.pin(blk);
>       buffers.put(blk, buff);
>       pins.add(blk);
>    }
>    
>    /**
>     * Appends a new block to the specified file
>     * and pins it.
>     * @param filename the name of the file
>     * @param fmtr the formatter used to initialize the new page
>     * @return a reference to the newly-created block
>     */
>    Block pinNew(String filename, PageFormatter fmtr) {
>       Buffer buff = bufferMgr.pinNew(filename, fmtr);
>       Block blk = buff.block();
>       buffers.put(blk, buff);
>       pins.add(blk);
>       return blk;
>    }
>    
>    /**
>     * Unpins the specified block.
>     * @param blk a reference to the disk block
>     */
>    void unpin(Block blk) {
>       Buffer buff = buffers.get(blk);
>       bufferMgr.unpin(buff);
>       pins.remove(blk);
>       if (!pins.contains(blk))
>          buffers.remove(blk);
>    }
>    
>    /**
>     * Unpins any buffers still pinned by this transaction.
>     */
>    void unpinAll() {
>       for (Block blk : pins) {
>          Buffer buff = buffers.get(blk);
>          bufferMgr.unpin(buff);
>       }
>       buffers.clear();
>       pins.clear();
>    }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/Transaction.java ../cs4432-proj2/src/simpledb/tx/Transaction.java
1,206c1,214
< package simpledb.tx;
< 
< import simpledb.server.SimpleDB;
< import simpledb.file.Block;
< import simpledb.buffer.*;
< import simpledb.tx.recovery.RecoveryMgr;
< import simpledb.tx.concurrency.ConcurrencyMgr;
< 
< /**
<  * Provides transaction management for clients,
<  * ensuring that all transactions are serializable, recoverable,
<  * and in general satisfy the ACID properties.
<  * @author Edward Sciore
<  */
< public class Transaction {
<    private static int nextTxNum = 0;
<    private static final int END_OF_FILE = -1;
<    private RecoveryMgr    recoveryMgr;
<    private ConcurrencyMgr concurMgr;
<    private int txnum;
<    private BufferList myBuffers = new BufferList();
<    
<    /**
<     * Creates a new transaction and its associated 
<     * recovery and concurrency managers.
<     * This constructor depends on the file, log, and buffer
<     * managers that it gets from the class
<     * {@link simpledb.server.SimpleDB}.
<     * Those objects are created during system initialization.
<     * Thus this constructor cannot be called until either
<     * {@link simpledb.server.SimpleDB#init(String)} or 
<     * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)} or
<     * is called first.
<     */
<    public Transaction() {
<       txnum       = nextTxNumber();
<       recoveryMgr = new RecoveryMgr(txnum);
<       concurMgr   = new ConcurrencyMgr();
<    }
<    
<    /**
<     * Commits the current transaction.
<     * Flushes all modified buffers (and their log records),
<     * writes and flushes a commit record to the log,
<     * releases all locks, and unpins any pinned buffers.
<     */
<    public void commit() {
<       recoveryMgr.commit();
<       concurMgr.release();
<       myBuffers.unpinAll();
<       System.out.println("transaction " + txnum + " committed");
<    }
<    
<    /**
<     * Rolls back the current transaction.
<     * Undoes any modified values,
<     * flushes those buffers,
<     * writes and flushes a rollback record to the log,
<     * releases all locks, and unpins any pinned buffers.
<     */
<    public void rollback() {
<       recoveryMgr.rollback();
<       concurMgr.release();
<       myBuffers.unpinAll();
<       System.out.println("transaction " + txnum + " rolled back");
<    }
<    
<    /**
<     * Flushes all modified buffers.
<     * Then goes through the log, rolling back all
<     * uncommitted transactions.  Finally, 
<     * writes a quiescent checkpoint record to the log.
<     * This method is called only during system startup,
<     * before user transactions begin.
<     */
<    public void recover() {
<       SimpleDB.bufferMgr().flushAll(txnum);
<       recoveryMgr.recover();
<    }
<    
<    /**
<     * Pins the specified block.
<     * The transaction manages the buffer for the client.
<     * @param blk a reference to the disk block
<     */
<    public void pin(Block blk) {
<       myBuffers.pin(blk);
<    }
<    
<    /**
<     * Unpins the specified block.
<     * The transaction looks up the buffer pinned to this block,
<     * and unpins it.
<     * @param blk a reference to the disk block
<     */
<    public void unpin(Block blk) {
<       myBuffers.unpin(blk);
<    }
<    
<    /**
<     * Returns the integer value stored at the
<     * specified offset of the specified block.
<     * The method first obtains an SLock on the block,
<     * then it calls the buffer to retrieve the value.
<     * @param blk a reference to a disk block
<     * @param offset the byte offset within the block
<     * @return the integer stored at that offset
<     */
<    public int getInt(Block blk, int offset) {
<       concurMgr.sLock(blk);
<       Buffer buff = myBuffers.getBuffer(blk);
<       return buff.getInt(offset);
<    }
<    
<    /**
<     * Returns the string value stored at the
<     * specified offset of the specified block.
<     * The method first obtains an SLock on the block,
<     * then it calls the buffer to retrieve the value.
<     * @param blk a reference to a disk block
<     * @param offset the byte offset within the block
<     * @return the string stored at that offset
<     */
<    public String getString(Block blk, int offset) {
<       concurMgr.sLock(blk);
<       Buffer buff = myBuffers.getBuffer(blk);
<       return buff.getString(offset);
<    }
<    
<    /**
<     * Stores an integer at the specified offset 
<     * of the specified block.
<     * The method first obtains an XLock on the block.
<     * It then reads the current value at that offset,
<     * puts it into an update log record, and 
<     * writes that record to the log.
<     * Finally, it calls the buffer to store the value,
<     * passing in the LSN of the log record and the transaction's id. 
<     * @param blk a reference to the disk block
<     * @param offset a byte offset within that block
<     * @param val the value to be stored
<     */
<    public void setInt(Block blk, int offset, int val) {
<       concurMgr.xLock(blk);
<       Buffer buff = myBuffers.getBuffer(blk);
<       int lsn = recoveryMgr.setInt(buff, offset, val);
<       buff.setInt(offset, val, txnum, lsn);
<    }
<    
<    /**
<     * Stores a string at the specified offset 
<     * of the specified block.
<     * The method first obtains an XLock on the block.
<     * It then reads the current value at that offset,
<     * puts it into an update log record, and 
<     * writes that record to the log.
<     * Finally, it calls the buffer to store the value,
<     * passing in the LSN of the log record and the transaction's id. 
<     * @param blk a reference to the disk block
<     * @param offset a byte offset within that block
<     * @param val the value to be stored
<     */
<    public void setString(Block blk, int offset, String val) {
<       concurMgr.xLock(blk);
<       Buffer buff = myBuffers.getBuffer(blk);
<       int lsn = recoveryMgr.setString(buff, offset, val);
<       buff.setString(offset, val, txnum, lsn);
<    }
<    
<    /**
<     * Returns the number of blocks in the specified file.
<     * This method first obtains an SLock on the 
<     * "end of the file", before asking the file manager
<     * to return the file size.
<     * @param filename the name of the file
<     * @return the number of blocks in the file
<     */
<    public int size(String filename) {
<       Block dummyblk = new Block(filename, END_OF_FILE);
<       concurMgr.sLock(dummyblk);
<       return SimpleDB.fileMgr().size(filename);
<    }
<    
<    /**
<     * Appends a new block to the end of the specified file
<     * and returns a reference to it.
<     * This method first obtains an XLock on the
<     * "end of the file", before performing the append.
<     * @param filename the name of the file
<     * @param fmtr the formatter used to initialize the new page
<     * @return a reference to the newly-created disk block
<     */
<    public Block append(String filename, PageFormatter fmtr) {
<       Block dummyblk = new Block(filename, END_OF_FILE);
<       concurMgr.xLock(dummyblk);
<       Block blk = myBuffers.pinNew(filename, fmtr);
<       unpin(blk);
<       return blk;
<    }
<    
<    private static synchronized int nextTxNumber() {
<       nextTxNum++;
<       System.out.println("new transaction: " + nextTxNum);
<       return nextTxNum;
<    }
< }
---
> package simpledb.tx;
> 
> import simpledb.server.SimpleDB;
> import simpledb.file.Block;
> import simpledb.buffer.*;
> import simpledb.tx.recovery.RecoveryMgr;
> import simpledb.tx.concurrency.ConcurrencyMgr;
> 
> /**
>  * Provides transaction management for clients,
>  * ensuring that all transactions are serializable, recoverable,
>  * and in general satisfy the ACID properties.
>  * @author Edward Sciore
>  */
> public class Transaction {
>    private static int nextTxNum = 0;
>    private static final int END_OF_FILE = -1;
>    private RecoveryMgr    recoveryMgr;
>    private ConcurrencyMgr concurMgr;
>    private int txnum;
>    private BufferList myBuffers = new BufferList();
>    
>    /**
>     * Creates a new transaction and its associated 
>     * recovery and concurrency managers.
>     * This constructor depends on the file, log, and buffer
>     * managers that it gets from the class
>     * {@link simpledb.server.SimpleDB}.
>     * Those objects are created during system initialization.
>     * Thus this constructor cannot be called until either
>     * {@link simpledb.server.SimpleDB#init(String)} or 
>     * {@link simpledb.server.SimpleDB#initFileLogAndBufferMgr(String)} or
>     * is called first.
>     */
>    public Transaction() {
>       txnum       = nextTxNumber();
>       recoveryMgr = new RecoveryMgr(txnum);
>       concurMgr   = new ConcurrencyMgr();
>    }
> 
>     /**
>      *
>      * @return txnum
>      */
>     public int txnum() {
>         return txnum;
>     }
>    
>    /**
>     * Commits the current transaction.
>     * Flushes all modified buffers (and their log records),
>     * writes and flushes a commit record to the log,
>     * releases all locks, and unpins any pinned buffers.
>     */
>    public void commit() {
>       recoveryMgr.commit();
>       concurMgr.release();
>       myBuffers.unpinAll();
>       System.out.println("transaction " + txnum + " committed");
>    }
>    
>    /**
>     * Rolls back the current transaction.
>     * Undoes any modified values,
>     * flushes those buffers,
>     * writes and flushes a rollback record to the log,
>     * releases all locks, and unpins any pinned buffers.
>     */
>    public void rollback() {
>       recoveryMgr.rollback();
>       concurMgr.release();
>       myBuffers.unpinAll();
>       System.out.println("transaction " + txnum + " rolled back");
>    }
>    
>    /**
>     * Flushes all modified buffers.
>     * Then goes through the log, rolling back all
>     * uncommitted transactions.  Finally, 
>     * writes a quiescent checkpoint record to the log.
>     * This method is called only during system startup,
>     * before user transactions begin.
>     */
>    public void recover() {
>       SimpleDB.bufferMgr().flushAll(txnum);
>       recoveryMgr.recover();
>    }
>    
>    /**
>     * Pins the specified block.
>     * The transaction manages the buffer for the client.
>     * @param blk a reference to the disk block
>     */
>    public void pin(Block blk) {
>       myBuffers.pin(blk);
>    }
>    
>    /**
>     * Unpins the specified block.
>     * The transaction looks up the buffer pinned to this block,
>     * and unpins it.
>     * @param blk a reference to the disk block
>     */
>    public void unpin(Block blk) {
>       myBuffers.unpin(blk);
>    }
>    
>    /**
>     * Returns the integer value stored at the
>     * specified offset of the specified block.
>     * The method first obtains an SLock on the block,
>     * then it calls the buffer to retrieve the value.
>     * @param blk a reference to a disk block
>     * @param offset the byte offset within the block
>     * @return the integer stored at that offset
>     */
>    public int getInt(Block blk, int offset) {
>       concurMgr.sLock(blk);
>       Buffer buff = myBuffers.getBuffer(blk);
>       return buff.getInt(offset);
>    }
>    
>    /**
>     * Returns the string value stored at the
>     * specified offset of the specified block.
>     * The method first obtains an SLock on the block,
>     * then it calls the buffer to retrieve the value.
>     * @param blk a reference to a disk block
>     * @param offset the byte offset within the block
>     * @return the string stored at that offset
>     */
>    public String getString(Block blk, int offset) {
>       concurMgr.sLock(blk);
>       Buffer buff = myBuffers.getBuffer(blk);
>       return buff.getString(offset);
>    }
>    
>    /**
>     * Stores an integer at the specified offset 
>     * of the specified block.
>     * The method first obtains an XLock on the block.
>     * It then reads the current value at that offset,
>     * puts it into an update log record, and 
>     * writes that record to the log.
>     * Finally, it calls the buffer to store the value,
>     * passing in the LSN of the log record and the transaction's id. 
>     * @param blk a reference to the disk block
>     * @param offset a byte offset within that block
>     * @param val the value to be stored
>     */
>    public void setInt(Block blk, int offset, int val) {
>       concurMgr.xLock(blk);
>       Buffer buff = myBuffers.getBuffer(blk);
>       int lsn = recoveryMgr.setInt(buff, offset, val);
>       buff.setInt(offset, val, txnum, lsn);
>    }
>    
>    /**
>     * Stores a string at the specified offset 
>     * of the specified block.
>     * The method first obtains an XLock on the block.
>     * It then reads the current value at that offset,
>     * puts it into an update log record, and 
>     * writes that record to the log.
>     * Finally, it calls the buffer to store the value,
>     * passing in the LSN of the log record and the transaction's id. 
>     * @param blk a reference to the disk block
>     * @param offset a byte offset within that block
>     * @param val the value to be stored
>     */
>    public void setString(Block blk, int offset, String val) {
>       concurMgr.xLock(blk);
>       Buffer buff = myBuffers.getBuffer(blk);
>       int lsn = recoveryMgr.setString(buff, offset, val);
>       buff.setString(offset, val, txnum, lsn);
>    }
>    
>    /**
>     * Returns the number of blocks in the specified file.
>     * This method first obtains an SLock on the 
>     * "end of the file", before asking the file manager
>     * to return the file size.
>     * @param filename the name of the file
>     * @return the number of blocks in the file
>     */
>    public int size(String filename) {
>       Block dummyblk = new Block(filename, END_OF_FILE);
>       concurMgr.sLock(dummyblk);
>       return SimpleDB.fileMgr().size(filename);
>    }
>    
>    /**
>     * Appends a new block to the end of the specified file
>     * and returns a reference to it.
>     * This method first obtains an XLock on the
>     * "end of the file", before performing the append.
>     * @param filename the name of the file
>     * @param fmtr the formatter used to initialize the new page
>     * @return a reference to the newly-created disk block
>     */
>    public Block append(String filename, PageFormatter fmtr) {
>       Block dummyblk = new Block(filename, END_OF_FILE);
>       concurMgr.xLock(dummyblk);
>       Block blk = myBuffers.pinNew(filename, fmtr);
>       unpin(blk);
>       return blk;
>    }
>    
>    private static synchronized int nextTxNumber() {
>       nextTxNum++;
>       System.out.println("new transaction: " + nextTxNum);
>       return nextTxNum;
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/concurrency/ConcurrencyMgr.java ../cs4432-proj2/src/simpledb/tx/concurrency/ConcurrencyMgr.java
1,65c1,65
< package simpledb.tx.concurrency;
< 
< import simpledb.file.Block;
< import java.util.*;
< 
< /**
<  * The concurrency manager for the transaction.
<  * Each transaction has its own concurrency manager. 
<  * The concurrency manager keeps track of which locks the 
<  * transaction currently has, and interacts with the
<  * global lock table as needed. 
<  * @author Edward Sciore
<  */
< public class ConcurrencyMgr {
<    
<    /**
<     * The global lock table.  This variable is static because all transactions
<     * share the same table.
<     */
<    private static LockTable locktbl = new LockTable();
<    private Map<Block,String> locks  = new HashMap<Block,String>();
<    
<    /**
<     * Obtains an SLock on the block, if necessary.
<     * The method will ask the lock table for an SLock
<     * if the transaction currently has no locks on that block.
<     * @param blk a reference to the disk block
<     */
<    public void sLock(Block blk) {
<       if (locks.get(blk) == null) {
<          locktbl.sLock(blk);
<          locks.put(blk, "S");
<       }
<    }
<    
<    /**
<     * Obtains an XLock on the block, if necessary.
<     * If the transaction does not have an XLock on that block,
<     * then the method first gets an SLock on that block
<     * (if necessary), and then upgrades it to an XLock.
<     * @param blk a refrence to the disk block
<     */
<    public void xLock(Block blk) {
<       if (!hasXLock(blk)) {
<          sLock(blk);
<          locktbl.xLock(blk);
<          locks.put(blk, "X");
<       }
<    }
<    
<    /**
<     * Releases all locks by asking the lock table to
<     * unlock each one.
<     */
<    public void release() {
<       for (Block blk : locks.keySet())
<          locktbl.unlock(blk);
<       locks.clear();
<    }
<    
<    private boolean hasXLock(Block blk) {
<       String locktype = locks.get(blk);
<       return locktype != null && locktype.equals("X");
<    }
< }
---
> package simpledb.tx.concurrency;
> 
> import simpledb.file.Block;
> import java.util.*;
> 
> /**
>  * The concurrency manager for the transaction.
>  * Each transaction has its own concurrency manager. 
>  * The concurrency manager keeps track of which locks the 
>  * transaction currently has, and interacts with the
>  * global lock table as needed. 
>  * @author Edward Sciore
>  */
> public class ConcurrencyMgr {
>    
>    /**
>     * The global lock table.  This variable is static because all transactions
>     * share the same table.
>     */
>    private static LockTable locktbl = new LockTable();
>    private Map<Block,String> locks  = new HashMap<Block,String>();
>    
>    /**
>     * Obtains an SLock on the block, if necessary.
>     * The method will ask the lock table for an SLock
>     * if the transaction currently has no locks on that block.
>     * @param blk a reference to the disk block
>     */
>    public void sLock(Block blk) {
>       if (locks.get(blk) == null) {
>          locktbl.sLock(blk);
>          locks.put(blk, "S");
>       }
>    }
>    
>    /**
>     * Obtains an XLock on the block, if necessary.
>     * If the transaction does not have an XLock on that block,
>     * then the method first gets an SLock on that block
>     * (if necessary), and then upgrades it to an XLock.
>     * @param blk a refrence to the disk block
>     */
>    public void xLock(Block blk) {
>       if (!hasXLock(blk)) {
>          sLock(blk);
>          locktbl.xLock(blk);
>          locks.put(blk, "X");
>       }
>    }
>    
>    /**
>     * Releases all locks by asking the lock table to
>     * unlock each one.
>     */
>    public void release() {
>       for (Block blk : locks.keySet())
>          locktbl.unlock(blk);
>       locks.clear();
>    }
>    
>    private boolean hasXLock(Block blk) {
>       String locktype = locks.get(blk);
>       return locktype != null && locktype.equals("X");
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/concurrency/LockAbortException.java ../cs4432-proj2/src/simpledb/tx/concurrency/LockAbortException.java
1,12c1,12
< package simpledb.tx.concurrency;
< 
< /**
<  * A runtime exception indicating that the transaction
<  * needs to abort because a lock could not be obtained.
<  * @author Edward Sciore
<  */
< @SuppressWarnings("serial")
< public class LockAbortException extends RuntimeException {
<    public LockAbortException() {
<    }
< }
---
> package simpledb.tx.concurrency;
> 
> /**
>  * A runtime exception indicating that the transaction
>  * needs to abort because a lock could not be obtained.
>  * @author Edward Sciore
>  */
> @SuppressWarnings("serial")
> public class LockAbortException extends RuntimeException {
>    public LockAbortException() {
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/concurrency/LockTable.java ../cs4432-proj2/src/simpledb/tx/concurrency/LockTable.java
1,103c1,103
< package simpledb.tx.concurrency;
< 
< import simpledb.file.Block;
< import java.util.*;
< 
< /**
<  * The lock table, which provides methods to lock and unlock blocks.
<  * If a transaction requests a lock that causes a conflict with an
<  * existing lock, then that transaction is placed on a wait list.
<  * There is only one wait list for all blocks.
<  * When the last lock on a block is unlocked, then all transactions
<  * are removed from the wait list and rescheduled.
<  * If one of those transactions discovers that the lock it is waiting for
<  * is still locked, it will place itself back on the wait list.
<  * @author Edward Sciore
<  */
< class LockTable {
<    private static final long MAX_TIME = 10000; // 10 seconds
<    
<    private Map<Block,Integer> locks = new HashMap<Block,Integer>();
<    
<    /**
<     * Grants an SLock on the specified block.
<     * If an XLock exists when the method is called,
<     * then the calling thread will be placed on a wait list
<     * until the lock is released.
<     * If the thread remains on the wait list for a certain 
<     * amount of time (currently 10 seconds),
<     * then an exception is thrown.
<     * @param blk a reference to the disk block
<     */
<    public synchronized void sLock(Block blk) {
<       try {
<          long timestamp = System.currentTimeMillis();
<          while (hasXlock(blk) && !waitingTooLong(timestamp))
<             wait(MAX_TIME);
<          if (hasXlock(blk))
<             throw new LockAbortException();
<          int val = getLockVal(blk);  // will not be negative
<          locks.put(blk, val+1);
<       }
<       catch(InterruptedException e) {
<          throw new LockAbortException();
<       }
<    }
<    
<    /**
<     * Grants an XLock on the specified block.
<     * If a lock of any type exists when the method is called,
<     * then the calling thread will be placed on a wait list
<     * until the locks are released.
<     * If the thread remains on the wait list for a certain 
<     * amount of time (currently 10 seconds),
<     * then an exception is thrown.
<     * @param blk a reference to the disk block
<     */
<    synchronized void xLock(Block blk) {
<       try {
<          long timestamp = System.currentTimeMillis();
<          while (hasOtherSLocks(blk) && !waitingTooLong(timestamp))
<             wait(MAX_TIME);
<          if (hasOtherSLocks(blk))
<             throw new LockAbortException();
<          locks.put(blk, -1);
<       }
<       catch(InterruptedException e) {
<          throw new LockAbortException();
<       }
<    }
<    
<    /**
<     * Releases a lock on the specified block.
<     * If this lock is the last lock on that block,
<     * then the waiting transactions are notified.
<     * @param blk a reference to the disk block
<     */
<    synchronized void unlock(Block blk) {
<       int val = getLockVal(blk);
<       if (val > 1)
<          locks.put(blk, val-1);
<       else {
<          locks.remove(blk);
<          notifyAll();
<       }
<    }
<    
<    private boolean hasXlock(Block blk) {
<       return getLockVal(blk) < 0;
<    }
<    
<    private boolean hasOtherSLocks(Block blk) {
<       return getLockVal(blk) > 1;
<    }
<    
<    private boolean waitingTooLong(long starttime) {
<       return System.currentTimeMillis() - starttime > MAX_TIME;
<    }
<    
<    private int getLockVal(Block blk) {
<       Integer ival = locks.get(blk);
<       return (ival == null) ? 0 : ival.intValue();
<    }
< }
---
> package simpledb.tx.concurrency;
> 
> import simpledb.file.Block;
> import java.util.*;
> 
> /**
>  * The lock table, which provides methods to lock and unlock blocks.
>  * If a transaction requests a lock that causes a conflict with an
>  * existing lock, then that transaction is placed on a wait list.
>  * There is only one wait list for all blocks.
>  * When the last lock on a block is unlocked, then all transactions
>  * are removed from the wait list and rescheduled.
>  * If one of those transactions discovers that the lock it is waiting for
>  * is still locked, it will place itself back on the wait list.
>  * @author Edward Sciore
>  */
> class LockTable {
>    private static final long MAX_TIME = 10000; // 10 seconds
>    
>    private Map<Block,Integer> locks = new HashMap<Block,Integer>();
>    
>    /**
>     * Grants an SLock on the specified block.
>     * If an XLock exists when the method is called,
>     * then the calling thread will be placed on a wait list
>     * until the lock is released.
>     * If the thread remains on the wait list for a certain 
>     * amount of time (currently 10 seconds),
>     * then an exception is thrown.
>     * @param blk a reference to the disk block
>     */
>    public synchronized void sLock(Block blk) {
>       try {
>          long timestamp = System.currentTimeMillis();
>          while (hasXlock(blk) && !waitingTooLong(timestamp))
>             wait(MAX_TIME);
>          if (hasXlock(blk))
>             throw new LockAbortException();
>          int val = getLockVal(blk);  // will not be negative
>          locks.put(blk, val+1);
>       }
>       catch(InterruptedException e) {
>          throw new LockAbortException();
>       }
>    }
>    
>    /**
>     * Grants an XLock on the specified block.
>     * If a lock of any type exists when the method is called,
>     * then the calling thread will be placed on a wait list
>     * until the locks are released.
>     * If the thread remains on the wait list for a certain 
>     * amount of time (currently 10 seconds),
>     * then an exception is thrown.
>     * @param blk a reference to the disk block
>     */
>    synchronized void xLock(Block blk) {
>       try {
>          long timestamp = System.currentTimeMillis();
>          while (hasOtherSLocks(blk) && !waitingTooLong(timestamp))
>             wait(MAX_TIME);
>          if (hasOtherSLocks(blk))
>             throw new LockAbortException();
>          locks.put(blk, -1);
>       }
>       catch(InterruptedException e) {
>          throw new LockAbortException();
>       }
>    }
>    
>    /**
>     * Releases a lock on the specified block.
>     * If this lock is the last lock on that block,
>     * then the waiting transactions are notified.
>     * @param blk a reference to the disk block
>     */
>    synchronized void unlock(Block blk) {
>       int val = getLockVal(blk);
>       if (val > 1)
>          locks.put(blk, val-1);
>       else {
>          locks.remove(blk);
>          notifyAll();
>       }
>    }
>    
>    private boolean hasXlock(Block blk) {
>       return getLockVal(blk) < 0;
>    }
>    
>    private boolean hasOtherSLocks(Block blk) {
>       return getLockVal(blk) > 1;
>    }
>    
>    private boolean waitingTooLong(long starttime) {
>       return System.currentTimeMillis() - starttime > MAX_TIME;
>    }
>    
>    private int getLockVal(Block blk) {
>       Integer ival = locks.get(blk);
>       return (ival == null) ? 0 : ival.intValue();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/CheckpointRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/CheckpointRecord.java
1,55c1,55
< package simpledb.tx.recovery;
< 
< import simpledb.log.BasicLogRecord;
< 
< /**
<  * The CHECKPOINT log record.
<  * @author Edward Sciore
<  */
< class CheckpointRecord implements LogRecord {
<    
<    /**
<     * Creates a quiescent checkpoint record.
<     */
<    public CheckpointRecord() {}
<    
<    /**
<     * Creates a log record by reading no other values 
<     * from the basic log record.
<     * @param rec the basic log record
<     */
<    public CheckpointRecord(BasicLogRecord rec) {}
<    
<    /** 
<     * Writes a checkpoint record to the log.
<     * This log record contains the CHECKPOINT operator,
<     * and nothing else.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {CHECKPOINT};
<       return logMgr.append(rec);
<    }
<    
<    public int op() {
<       return CHECKPOINT;
<    }
<    
<    /**
<     * Checkpoint records have no associated transaction,
<     * and so the method returns a "dummy", negative txid.
<     */
<    public int txNumber() {
<       return -1; // dummy value
<    }
<    
<    /**
<     * Does nothing, because a checkpoint record
<     * contains no undo information.
<     */
<    public void undo(int txnum) {}
<    
<    public String toString() {
<       return "<CHECKPOINT>";
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.log.BasicLogRecord;
> 
> /**
>  * The CHECKPOINT log record.
>  * @author Edward Sciore
>  */
> class CheckpointRecord implements LogRecord {
>    
>    /**
>     * Creates a quiescent checkpoint record.
>     */
>    public CheckpointRecord() {}
>    
>    /**
>     * Creates a log record by reading no other values 
>     * from the basic log record.
>     * @param rec the basic log record
>     */
>    public CheckpointRecord(BasicLogRecord rec) {}
>    
>    /** 
>     * Writes a checkpoint record to the log.
>     * This log record contains the CHECKPOINT operator,
>     * and nothing else.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {CHECKPOINT};
>       return logMgr.append(rec);
>    }
>    
>    public int op() {
>       return CHECKPOINT;
>    }
>    
>    /**
>     * Checkpoint records have no associated transaction,
>     * and so the method returns a "dummy", negative txid.
>     */
>    public int txNumber() {
>       return -1; // dummy value
>    }
>    
>    /**
>     * Does nothing, because a checkpoint record
>     * contains no undo information.
>     */
>    public void undo(int txnum) {}
>    
>    public String toString() {
>       return "<CHECKPOINT>";
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/CommitRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/CommitRecord.java
1,56c1,56
< package simpledb.tx.recovery;
< 
< import simpledb.log.BasicLogRecord;
< 
< /**
<  * The COMMIT log record
<  * @author Edward Sciore
<  */
< class CommitRecord implements LogRecord {
<    private int txnum;
<    
<    /**
<     * Creates a new commit log record for the specified transaction.
<     * @param txnum the ID of the specified transaction
<     */
<    public CommitRecord(int txnum) {
<       this.txnum = txnum;
<    }
<    
<    /**
<     * Creates a log record by reading one other value from the log.
<     * @param rec the basic log record
<     */
<    public CommitRecord(BasicLogRecord rec) {
<       txnum = rec.nextInt();
<    }
<    
<    /** 
<     * Writes a commit record to the log.
<     * This log record contains the COMMIT operator,
<     * followed by the transaction id.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {COMMIT, txnum};
<       return logMgr.append(rec);
<    }
<    
<    public int op() {
<       return COMMIT;
<    }
<    
<    public int txNumber() {
<       return txnum;
<    }
<    
<    /**
<     * Does nothing, because a commit record
<     * contains no undo information.
<     */
<    public void undo(int txnum) {}
<    
<    public String toString() {
<       return "<COMMIT " + txnum + ">";
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.log.BasicLogRecord;
> 
> /**
>  * The COMMIT log record
>  * @author Edward Sciore
>  */
> class CommitRecord implements LogRecord {
>    private int txnum;
>    
>    /**
>     * Creates a new commit log record for the specified transaction.
>     * @param txnum the ID of the specified transaction
>     */
>    public CommitRecord(int txnum) {
>       this.txnum = txnum;
>    }
>    
>    /**
>     * Creates a log record by reading one other value from the log.
>     * @param rec the basic log record
>     */
>    public CommitRecord(BasicLogRecord rec) {
>       txnum = rec.nextInt();
>    }
>    
>    /** 
>     * Writes a commit record to the log.
>     * This log record contains the COMMIT operator,
>     * followed by the transaction id.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {COMMIT, txnum};
>       return logMgr.append(rec);
>    }
>    
>    public int op() {
>       return COMMIT;
>    }
>    
>    public int txNumber() {
>       return txnum;
>    }
>    
>    /**
>     * Does nothing, because a commit record
>     * contains no undo information.
>     */
>    public void undo(int txnum) {}
>    
>    public String toString() {
>       return "<COMMIT " + txnum + ">";
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/LogRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/LogRecord.java
1,45c1,45
< package simpledb.tx.recovery;
< 
< import simpledb.log.LogMgr;
< import simpledb.server.SimpleDB;
< 
< /**
<  * The interface implemented by each type of log record.
<  * @author Edward Sciore
<  */
< public interface LogRecord {
<    /**
<     * The six different types of log record
<     */
<    static final int CHECKPOINT = 0, START = 1,
<       COMMIT = 2, ROLLBACK  = 3,
<       SETINT = 4, SETSTRING = 5;
<    
<    static final LogMgr logMgr = SimpleDB.logMgr();
<    
<    /**
<     * Writes the record to the log and returns its LSN.
<     * @return the LSN of the record in the log
<     */
<    int writeToLog();
<    
<    /**
<     * Returns the log record's type. 
<     * @return the log record's type
<     */
<    int op();
<    
<    /**
<     * Returns the transaction id stored with
<     * the log record.
<     * @return the log record's transaction id
<     */
<    int txNumber();
<    
<    /**
<     * Undoes the operation encoded by this log record.
<     * The only log record types for which this method
<     * does anything interesting are SETINT and SETSTRING.
<     * @param txnum the id of the transaction that is performing the undo.
<     */
<    void undo(int txnum);
---
> package simpledb.tx.recovery;
> 
> import simpledb.log.LogMgr;
> import simpledb.server.SimpleDB;
> 
> /**
>  * The interface implemented by each type of log record.
>  * @author Edward Sciore
>  */
> public interface LogRecord {
>    /**
>     * The six different types of log record
>     */
>    static final int CHECKPOINT = 0, START = 1,
>       COMMIT = 2, ROLLBACK  = 3,
>       SETINT = 4, SETSTRING = 5;
>    
>    static final LogMgr logMgr = SimpleDB.logMgr();
>    
>    /**
>     * Writes the record to the log and returns its LSN.
>     * @return the LSN of the record in the log
>     */
>    int writeToLog();
>    
>    /**
>     * Returns the log record's type. 
>     * @return the log record's type
>     */
>    int op();
>    
>    /**
>     * Returns the transaction id stored with
>     * the log record.
>     * @return the log record's transaction id
>     */
>    int txNumber();
>    
>    /**
>     * Undoes the operation encoded by this log record.
>     * The only log record types for which this method
>     * does anything interesting are SETINT and SETSTRING.
>     * @param txnum the id of the transaction that is performing the undo.
>     */
>    void undo(int txnum);
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/LogRecordIterator.java ../cs4432-proj2/src/simpledb/tx/recovery/LogRecordIterator.java
1,56c1,56
< package simpledb.tx.recovery;
< 
< import static simpledb.tx.recovery.LogRecord.*;
< import java.util.Iterator;
< import simpledb.log.BasicLogRecord;
< import simpledb.server.SimpleDB;
< 
< /**
<  * A class that provides the ability to read records
<  * from the log in reverse order.
<  * Unlike the similar class 
<  * {@link simpledb.log.LogIterator LogIterator},  
<  * this class understands the meaning of the log records.
<  * @author Edward Sciore
<  */
< class LogRecordIterator implements Iterator<LogRecord> {
<    private Iterator<BasicLogRecord> iter = SimpleDB.logMgr().iterator();
<    
<    public boolean hasNext() {
<       return iter.hasNext();
<    }
<    
<    /**
<     * Constructs a log record from the values in the 
<     * current basic log record.
<     * The method first reads an integer, which denotes
<     * the type of the log record.  Based on that type,
<     * the method calls the appropriate LogRecord constructor
<     * to read the remaining values.
<     * @return the next log record, or null if no more records
<     */
<    public LogRecord next() {
<       BasicLogRecord rec = iter.next();
<       int op = rec.nextInt();
<       switch (op) {
<          case CHECKPOINT:
<             return new CheckpointRecord(rec);
<          case START:
<             return new StartRecord(rec);
<          case COMMIT:
<             return new CommitRecord(rec);
<          case ROLLBACK:
<             return new RollbackRecord(rec);
<          case SETINT:
<             return new SetIntRecord(rec);
<          case SETSTRING:
<             return new SetStringRecord(rec);
<          default:
<             return null;
<       }
<    } 
<    
<    public void remove() {
<       throw new UnsupportedOperationException();
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import static simpledb.tx.recovery.LogRecord.*;
> import java.util.Iterator;
> import simpledb.log.BasicLogRecord;
> import simpledb.server.SimpleDB;
> 
> /**
>  * A class that provides the ability to read records
>  * from the log in reverse order.
>  * Unlike the similar class 
>  * {@link simpledb.log.LogIterator LogIterator},  
>  * this class understands the meaning of the log records.
>  * @author Edward Sciore
>  */
> class LogRecordIterator implements Iterator<LogRecord> {
>    private Iterator<BasicLogRecord> iter = SimpleDB.logMgr().iterator();
>    
>    public boolean hasNext() {
>       return iter.hasNext();
>    }
>    
>    /**
>     * Constructs a log record from the values in the 
>     * current basic log record.
>     * The method first reads an integer, which denotes
>     * the type of the log record.  Based on that type,
>     * the method calls the appropriate LogRecord constructor
>     * to read the remaining values.
>     * @return the next log record, or null if no more records
>     */
>    public LogRecord next() {
>       BasicLogRecord rec = iter.next();
>       int op = rec.nextInt();
>       switch (op) {
>          case CHECKPOINT:
>             return new CheckpointRecord(rec);
>          case START:
>             return new StartRecord(rec);
>          case COMMIT:
>             return new CommitRecord(rec);
>          case ROLLBACK:
>             return new RollbackRecord(rec);
>          case SETINT:
>             return new SetIntRecord(rec);
>          case SETSTRING:
>             return new SetStringRecord(rec);
>          default:
>             return null;
>       }
>    } 
>    
>    public void remove() {
>       throw new UnsupportedOperationException();
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/RecoveryMgr.java ../cs4432-proj2/src/simpledb/tx/recovery/RecoveryMgr.java
1,137c1,137
< package simpledb.tx.recovery;
< 
< import static simpledb.tx.recovery.LogRecord.*;
< import simpledb.file.Block;
< import simpledb.buffer.Buffer;
< import simpledb.server.SimpleDB;
< import java.util.*;
< 
< /**
<  * The recovery manager.  Each transaction has its own recovery manager.
<  * @author Edward Sciore
<  */
< public class RecoveryMgr {
<    private int txnum;
< 
<    /**
<     * Creates a recovery manager for the specified transaction.
<     * @param txnum the ID of the specified transaction
<     */
<    public RecoveryMgr(int txnum) {
<       this.txnum = txnum;
<       new StartRecord(txnum).writeToLog();
<    }
< 
<    /**
<     * Writes a commit record to the log, and flushes it to disk.
<     */
<    public void commit() {
<       SimpleDB.bufferMgr().flushAll(txnum);
<       int lsn = new CommitRecord(txnum).writeToLog();
<       SimpleDB.logMgr().flush(lsn);
<    }
< 
<    /**
<     * Writes a rollback record to the log, and flushes it to disk.
<     */
<    public void rollback() {
<       doRollback();
<       SimpleDB.bufferMgr().flushAll(txnum);
<       int lsn = new RollbackRecord(txnum).writeToLog();
<       SimpleDB.logMgr().flush(lsn);
<    }
< 
<    /**
<     * Recovers uncompleted transactions from the log,
<     * then writes a quiescent checkpoint record to the log and flushes it.
<     */
<    public void recover() {
<       doRecover();
<       SimpleDB.bufferMgr().flushAll(txnum);
<       int lsn = new CheckpointRecord().writeToLog();
<       SimpleDB.logMgr().flush(lsn);
< 
<    }
< 
<    /**
<     * Writes a setint record to the log, and returns its lsn.
<     * Updates to temporary files are not logged; instead, a
<     * "dummy" negative lsn is returned.
<     * @param buff the buffer containing the page
<     * @param offset the offset of the value in the page
<     * @param newval the value to be written
<     */
<    public int setInt(Buffer buff, int offset, int newval) {
<       int oldval = buff.getInt(offset);
<       Block blk = buff.block();
<       if (isTempBlock(blk))
<          return -1;
<       else
<          return new SetIntRecord(txnum, blk, offset, oldval).writeToLog();
<    }
< 
<    /**
<     * Writes a setstring record to the log, and returns its lsn.
<     * Updates to temporary files are not logged; instead, a
<     * "dummy" negative lsn is returned.
<     * @param buff the buffer containing the page
<     * @param offset the offset of the value in the page
<     * @param newval the value to be written
<     */
<    public int setString(Buffer buff, int offset, String newval) {
<       String oldval = buff.getString(offset);
<       Block blk = buff.block();
<       if (isTempBlock(blk))
<          return -1;
<       else
<          return new SetStringRecord(txnum, blk, offset, oldval).writeToLog();
<    }
< 
<    /**
<     * Rolls back the transaction.
<     * The method iterates through the log records,
<     * calling undo() for each log record it finds
<     * for the transaction,
<     * until it finds the transaction's START record.
<     */
<    private void doRollback() {
<       Iterator<LogRecord> iter = new LogRecordIterator();
<       while (iter.hasNext()) {
<          LogRecord rec = iter.next();
<          if (rec.txNumber() == txnum) {
<             if (rec.op() == START)
<                return;
<             rec.undo(txnum);
<          }
<       }
<    }
< 
<    /**
<     * Does a complete database recovery.
<     * The method iterates through the log records.
<     * Whenever it finds a log record for an unfinished
<     * transaction, it calls undo() on that record.
<     * The method stops when it encounters a CHECKPOINT record
<     * or the end of the log.
<     */
<    private void doRecover() {
<       Collection<Integer> finishedTxs = new ArrayList<Integer>();
<       Iterator<LogRecord> iter = new LogRecordIterator();
<       while (iter.hasNext()) {
<          LogRecord rec = iter.next();
<          if (rec.op() == CHECKPOINT)
<             return;
<          if (rec.op() == COMMIT || rec.op() == ROLLBACK)
<             finishedTxs.add(rec.txNumber());
<          else if (!finishedTxs.contains(rec.txNumber()))
<             rec.undo(txnum);
<       }
<    }
< 
<    /**
<     * Determines whether a block comes from a temporary file or not.
<     */
<    private boolean isTempBlock(Block blk) {
<       return blk.fileName().startsWith("temp");
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import static simpledb.tx.recovery.LogRecord.*;
> import simpledb.file.Block;
> import simpledb.buffer.Buffer;
> import simpledb.server.SimpleDB;
> import java.util.*;
> 
> /**
>  * The recovery manager.  Each transaction has its own recovery manager.
>  * @author Edward Sciore
>  */
> public class RecoveryMgr {
>    private int txnum;
> 
>    /**
>     * Creates a recovery manager for the specified transaction.
>     * @param txnum the ID of the specified transaction
>     */
>    public RecoveryMgr(int txnum) {
>       this.txnum = txnum;
>       new StartRecord(txnum).writeToLog();
>    }
> 
>    /**
>     * Writes a commit record to the log, and flushes it to disk.
>     */
>    public void commit() {
>       SimpleDB.bufferMgr().flushAll(txnum);
>       int lsn = new CommitRecord(txnum).writeToLog();
>       SimpleDB.logMgr().flush(lsn);
>    }
> 
>    /**
>     * Writes a rollback record to the log, and flushes it to disk.
>     */
>    public void rollback() {
>       doRollback();
>       SimpleDB.bufferMgr().flushAll(txnum);
>       int lsn = new RollbackRecord(txnum).writeToLog();
>       SimpleDB.logMgr().flush(lsn);
>    }
> 
>    /**
>     * Recovers uncompleted transactions from the log,
>     * then writes a quiescent checkpoint record to the log and flushes it.
>     */
>    public void recover() {
>       doRecover();
>       SimpleDB.bufferMgr().flushAll(txnum);
>       int lsn = new CheckpointRecord().writeToLog();
>       SimpleDB.logMgr().flush(lsn);
> 
>    }
> 
>    /**
>     * Writes a setint record to the log, and returns its lsn.
>     * Updates to temporary files are not logged; instead, a
>     * "dummy" negative lsn is returned.
>     * @param buff the buffer containing the page
>     * @param offset the offset of the value in the page
>     * @param newval the value to be written
>     */
>    public int setInt(Buffer buff, int offset, int newval) {
>       int oldval = buff.getInt(offset);
>       Block blk = buff.block();
>       if (isTempBlock(blk))
>          return -1;
>       else
>          return new SetIntRecord(txnum, blk, offset, oldval).writeToLog();
>    }
> 
>    /**
>     * Writes a setstring record to the log, and returns its lsn.
>     * Updates to temporary files are not logged; instead, a
>     * "dummy" negative lsn is returned.
>     * @param buff the buffer containing the page
>     * @param offset the offset of the value in the page
>     * @param newval the value to be written
>     */
>    public int setString(Buffer buff, int offset, String newval) {
>       String oldval = buff.getString(offset);
>       Block blk = buff.block();
>       if (isTempBlock(blk))
>          return -1;
>       else
>          return new SetStringRecord(txnum, blk, offset, oldval).writeToLog();
>    }
> 
>    /**
>     * Rolls back the transaction.
>     * The method iterates through the log records,
>     * calling undo() for each log record it finds
>     * for the transaction,
>     * until it finds the transaction's START record.
>     */
>    private void doRollback() {
>       Iterator<LogRecord> iter = new LogRecordIterator();
>       while (iter.hasNext()) {
>          LogRecord rec = iter.next();
>          if (rec.txNumber() == txnum) {
>             if (rec.op() == START)
>                return;
>             rec.undo(txnum);
>          }
>       }
>    }
> 
>    /**
>     * Does a complete database recovery.
>     * The method iterates through the log records.
>     * Whenever it finds a log record for an unfinished
>     * transaction, it calls undo() on that record.
>     * The method stops when it encounters a CHECKPOINT record
>     * or the end of the log.
>     */
>    private void doRecover() {
>       Collection<Integer> finishedTxs = new ArrayList<Integer>();
>       Iterator<LogRecord> iter = new LogRecordIterator();
>       while (iter.hasNext()) {
>          LogRecord rec = iter.next();
>          if (rec.op() == CHECKPOINT)
>             return;
>          if (rec.op() == COMMIT || rec.op() == ROLLBACK)
>             finishedTxs.add(rec.txNumber());
>          else if (!finishedTxs.contains(rec.txNumber()))
>             rec.undo(txnum);
>       }
>    }
> 
>    /**
>     * Determines whether a block comes from a temporary file or not.
>     */
>    private boolean isTempBlock(Block blk) {
>       return blk.fileName().startsWith("temp");
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/RollbackRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/RollbackRecord.java
1,56c1,56
< package simpledb.tx.recovery;
< 
< import simpledb.log.BasicLogRecord;
< 
< /**
<  * The ROLLBACK log record.
<  * @author Edward Sciore
<  */
< class RollbackRecord implements LogRecord {
<    private int txnum;
<    
<    /**
<     * Creates a new rollback log record for the specified transaction.
<     * @param txnum the ID of the specified transaction
<     */
<    public RollbackRecord(int txnum) {
<       this.txnum = txnum;
<    }
<    
<    /**
<     * Creates a log record by reading one other value from the log.
<     * @param rec the basic log record
<     */
<    public RollbackRecord(BasicLogRecord rec) {
<       txnum = rec.nextInt();
<    }
<    
<    /** 
<     * Writes a rollback record to the log.
<     * This log record contains the ROLLBACK operator,
<     * followed by the transaction id.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {ROLLBACK, txnum};
<       return logMgr.append(rec);
<    }
<    
<    public int op() {
<       return ROLLBACK;
<    }
<    
<    public int txNumber() {
<       return txnum;
<    }
<    
<    /**
<     * Does nothing, because a rollback record
<     * contains no undo information.
<     */
<    public void undo(int txnum) {}
<    
<    public String toString() {
<       return "<ROLLBACK " + txnum + ">";
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.log.BasicLogRecord;
> 
> /**
>  * The ROLLBACK log record.
>  * @author Edward Sciore
>  */
> class RollbackRecord implements LogRecord {
>    private int txnum;
>    
>    /**
>     * Creates a new rollback log record for the specified transaction.
>     * @param txnum the ID of the specified transaction
>     */
>    public RollbackRecord(int txnum) {
>       this.txnum = txnum;
>    }
>    
>    /**
>     * Creates a log record by reading one other value from the log.
>     * @param rec the basic log record
>     */
>    public RollbackRecord(BasicLogRecord rec) {
>       txnum = rec.nextInt();
>    }
>    
>    /** 
>     * Writes a rollback record to the log.
>     * This log record contains the ROLLBACK operator,
>     * followed by the transaction id.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {ROLLBACK, txnum};
>       return logMgr.append(rec);
>    }
>    
>    public int op() {
>       return ROLLBACK;
>    }
>    
>    public int txNumber() {
>       return txnum;
>    }
>    
>    /**
>     * Does nothing, because a rollback record
>     * contains no undo information.
>     */
>    public void undo(int txnum) {}
>    
>    public String toString() {
>       return "<ROLLBACK " + txnum + ">";
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/SetIntRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/SetIntRecord.java
1,78c1,78
< package simpledb.tx.recovery;
< 
< import simpledb.server.SimpleDB;
< import simpledb.buffer.*;
< import simpledb.file.Block;
< import simpledb.log.BasicLogRecord;
< 
< class SetIntRecord implements LogRecord {
<    private int txnum, offset, val;
<    private Block blk;
< 
<    /**
<     * Creates a new setint log record.
<     * @param txnum the ID of the specified transaction
<     * @param blk the block containing the value
<     * @param offset the offset of the value in the block
<     * @param val the new value
<     */
<    public SetIntRecord(int txnum, Block blk, int offset, int val) {
<       this.txnum = txnum;
<       this.blk = blk;
<       this.offset = offset;
<       this.val = val;
<    }
< 
<    /**
<     * Creates a log record by reading five other values from the log.
<     * @param rec the basic log record
<     */
<    public SetIntRecord(BasicLogRecord rec) {
<       txnum = rec.nextInt();
<       String filename = rec.nextString();
<       int blknum = rec.nextInt();
<       blk = new Block(filename, blknum);
<       offset = rec.nextInt();
<       val = rec.nextInt();
<    }
< 
<    /**
<     * Writes a setInt record to the log.
<     * This log record contains the SETINT operator,
<     * followed by the transaction id, the filename, number,
<     * and offset of the modified block, and the previous
<     * integer value at that offset.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {SETINT, txnum, blk.fileName(),
<          blk.number(), offset, val};
<       return logMgr.append(rec);
<    }
< 
<    public int op() {
<       return SETINT;
<    }
< 
<    public int txNumber() {
<       return txnum;
<    }
< 
<    public String toString() {
<       return "<SETINT " + txnum + " " + blk + " " + offset + " " + val + ">";
<    }
< 
<    /**
<     * Replaces the specified data value with the value saved in the log record.
<     * The method pins a buffer to the specified block,
<     * calls setInt to restore the saved value
<     * (using a dummy LSN), and unpins the buffer.
<     * @see simpledb.tx.recovery.LogRecord#undo(int)
<     */
<    public void undo(int txnum) {
<       BufferMgr buffMgr = SimpleDB.bufferMgr();
<       Buffer buff = buffMgr.pin(blk);
<       buff.setInt(offset, val, txnum, -1);
<       buffMgr.unpin(buff);
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.server.SimpleDB;
> import simpledb.buffer.*;
> import simpledb.file.Block;
> import simpledb.log.BasicLogRecord;
> 
> class SetIntRecord implements LogRecord {
>    private int txnum, offset, val;
>    private Block blk;
> 
>    /**
>     * Creates a new setint log record.
>     * @param txnum the ID of the specified transaction
>     * @param blk the block containing the value
>     * @param offset the offset of the value in the block
>     * @param val the new value
>     */
>    public SetIntRecord(int txnum, Block blk, int offset, int val) {
>       this.txnum = txnum;
>       this.blk = blk;
>       this.offset = offset;
>       this.val = val;
>    }
> 
>    /**
>     * Creates a log record by reading five other values from the log.
>     * @param rec the basic log record
>     */
>    public SetIntRecord(BasicLogRecord rec) {
>       txnum = rec.nextInt();
>       String filename = rec.nextString();
>       int blknum = rec.nextInt();
>       blk = new Block(filename, blknum);
>       offset = rec.nextInt();
>       val = rec.nextInt();
>    }
> 
>    /**
>     * Writes a setInt record to the log.
>     * This log record contains the SETINT operator,
>     * followed by the transaction id, the filename, number,
>     * and offset of the modified block, and the previous
>     * integer value at that offset.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {SETINT, txnum, blk.fileName(),
>          blk.number(), offset, val};
>       return logMgr.append(rec);
>    }
> 
>    public int op() {
>       return SETINT;
>    }
> 
>    public int txNumber() {
>       return txnum;
>    }
> 
>    public String toString() {
>       return "<SETINT " + txnum + " " + blk + " " + offset + " " + val + ">";
>    }
> 
>    /**
>     * Replaces the specified data value with the value saved in the log record.
>     * The method pins a buffer to the specified block,
>     * calls setInt to restore the saved value
>     * (using a dummy LSN), and unpins the buffer.
>     * @see simpledb.tx.recovery.LogRecord#undo(int)
>     */
>    public void undo(int txnum) {
>       BufferMgr buffMgr = SimpleDB.bufferMgr();
>       Buffer buff = buffMgr.pin(blk);
>       buff.setInt(offset, val, txnum, -1);
>       buffMgr.unpin(buff);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/SetStringRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/SetStringRecord.java
1,79c1,79
< package simpledb.tx.recovery;
< 
< import simpledb.server.SimpleDB;
< import simpledb.buffer.*;
< import simpledb.file.Block;
< import simpledb.log.BasicLogRecord;
< 
< class SetStringRecord implements LogRecord {
<    private int txnum, offset;
<    private String val;
<    private Block blk;
<    
<    /**
<     * Creates a new setstring log record.
<     * @param txnum the ID of the specified transaction
<     * @param blk the block containing the value
<     * @param offset the offset of the value in the block
<     * @param val the new value
<     */
<    public SetStringRecord(int txnum, Block blk, int offset, String val) {
<       this.txnum = txnum;
<       this.blk = blk;
<       this.offset = offset;
<       this.val = val;
<    }
<    
<    /**
<     * Creates a log record by reading five other values from the log.
<     * @param rec the basic log record
<     */
<    public SetStringRecord(BasicLogRecord rec) {
<       txnum = rec.nextInt();
<       String filename = rec.nextString();
<       int blknum = rec.nextInt();
<       blk = new Block(filename, blknum);
<       offset = rec.nextInt();
<       val = rec.nextString();
<    }
<    
<    /** 
<     * Writes a setString record to the log.
<     * This log record contains the SETSTRING operator,
<     * followed by the transaction id, the filename, number,
<     * and offset of the modified block, and the previous
<     * string value at that offset.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {SETSTRING, txnum, blk.fileName(),
<          blk.number(), offset, val};
<       return logMgr.append(rec);
<    }
<    
<    public int op() {
<       return SETSTRING;
<    }
<    
<    public int txNumber() {
<       return txnum;
<    }
<    
<    public String toString() {
<       return "<SETSTRING " + txnum + " " + blk + " " + offset + " " + val + ">";
<    }
<    
<    /** 
<     * Replaces the specified data value with the value saved in the log record.
<     * The method pins a buffer to the specified block,
<     * calls setString to restore the saved value
<     * (using a dummy LSN), and unpins the buffer.
<     * @see simpledb.tx.recovery.LogRecord#undo(int)
<     */
<    public void undo(int txnum) {
<       BufferMgr buffMgr = SimpleDB.bufferMgr();
<       Buffer buff = buffMgr.pin(blk);
<       buff.setString(offset, val, txnum, -1);
<       buffMgr.unpin(buff);
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.server.SimpleDB;
> import simpledb.buffer.*;
> import simpledb.file.Block;
> import simpledb.log.BasicLogRecord;
> 
> class SetStringRecord implements LogRecord {
>    private int txnum, offset;
>    private String val;
>    private Block blk;
>    
>    /**
>     * Creates a new setstring log record.
>     * @param txnum the ID of the specified transaction
>     * @param blk the block containing the value
>     * @param offset the offset of the value in the block
>     * @param val the new value
>     */
>    public SetStringRecord(int txnum, Block blk, int offset, String val) {
>       this.txnum = txnum;
>       this.blk = blk;
>       this.offset = offset;
>       this.val = val;
>    }
>    
>    /**
>     * Creates a log record by reading five other values from the log.
>     * @param rec the basic log record
>     */
>    public SetStringRecord(BasicLogRecord rec) {
>       txnum = rec.nextInt();
>       String filename = rec.nextString();
>       int blknum = rec.nextInt();
>       blk = new Block(filename, blknum);
>       offset = rec.nextInt();
>       val = rec.nextString();
>    }
>    
>    /** 
>     * Writes a setString record to the log.
>     * This log record contains the SETSTRING operator,
>     * followed by the transaction id, the filename, number,
>     * and offset of the modified block, and the previous
>     * string value at that offset.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {SETSTRING, txnum, blk.fileName(),
>          blk.number(), offset, val};
>       return logMgr.append(rec);
>    }
>    
>    public int op() {
>       return SETSTRING;
>    }
>    
>    public int txNumber() {
>       return txnum;
>    }
>    
>    public String toString() {
>       return "<SETSTRING " + txnum + " " + blk + " " + offset + " " + val + ">";
>    }
>    
>    /** 
>     * Replaces the specified data value with the value saved in the log record.
>     * The method pins a buffer to the specified block,
>     * calls setString to restore the saved value
>     * (using a dummy LSN), and unpins the buffer.
>     * @see simpledb.tx.recovery.LogRecord#undo(int)
>     */
>    public void undo(int txnum) {
>       BufferMgr buffMgr = SimpleDB.bufferMgr();
>       Buffer buff = buffMgr.pin(blk);
>       buff.setString(offset, val, txnum, -1);
>       buffMgr.unpin(buff);
>    }
> }
diff -r simpledb/SimpleDB_2.10/simpledb/tx/recovery/StartRecord.java ../cs4432-proj2/src/simpledb/tx/recovery/StartRecord.java
1,52c1,52
< package simpledb.tx.recovery;
< 
< import simpledb.log.BasicLogRecord;
< 
< class StartRecord implements LogRecord {
<    private int txnum;
<    
<    /**
<     * Creates a new start log record for the specified transaction.
<     * @param txnum the ID of the specified transaction
<     */
<    public StartRecord(int txnum) {
<       this.txnum = txnum;
<    }
<    
<    /**
<     * Creates a log record by reading one other value from the log.
<     * @param rec the basic log record
<     */
<    public StartRecord(BasicLogRecord rec) {
<       txnum = rec.nextInt();
<    }
<    
<    /** 
<     * Writes a start record to the log.
<     * This log record contains the START operator,
<     * followed by the transaction id.
<     * @return the LSN of the last log value
<     */
<    public int writeToLog() {
<       Object[] rec = new Object[] {START, txnum};
<       return logMgr.append(rec);
<    }
<    
<    public int op() {
<       return START;
<    }
<    
<    public int txNumber() {
<       return txnum;
<    }
<    
<    /**
<     * Does nothing, because a start record
<     * contains no undo information.
<     */
<    public void undo(int txnum) {}
<    
<    public String toString() {
<       return "<START " + txnum + ">";
<    }
< }
---
> package simpledb.tx.recovery;
> 
> import simpledb.log.BasicLogRecord;
> 
> class StartRecord implements LogRecord {
>    private int txnum;
>    
>    /**
>     * Creates a new start log record for the specified transaction.
>     * @param txnum the ID of the specified transaction
>     */
>    public StartRecord(int txnum) {
>       this.txnum = txnum;
>    }
>    
>    /**
>     * Creates a log record by reading one other value from the log.
>     * @param rec the basic log record
>     */
>    public StartRecord(BasicLogRecord rec) {
>       txnum = rec.nextInt();
>    }
>    
>    /** 
>     * Writes a start record to the log.
>     * This log record contains the START operator,
>     * followed by the transaction id.
>     * @return the LSN of the last log value
>     */
>    public int writeToLog() {
>       Object[] rec = new Object[] {START, txnum};
>       return logMgr.append(rec);
>    }
>    
>    public int op() {
>       return START;
>    }
>    
>    public int txNumber() {
>       return txnum;
>    }
>    
>    /**
>     * Does nothing, because a start record
>     * contains no undo information.
>     */
>    public void undo(int txnum) {}
>    
>    public String toString() {
>       return "<START " + txnum + ">";
>    }
> }
